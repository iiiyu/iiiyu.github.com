{"pages":[{"title":"关于我","text":"自我描述（2019-01-26更新） 88年大约冬季的时候，诞生在中国西南边陲的一个小城里面。从小没经历过大苦大难，也自然没有体验过大富大贵。城市经过20多年翻天覆地的变化还是只有三条街。 最近两年回去变化还是挺大的，不过增添了陌生感。这种陌生感就是曾经下课时偷偷去看的暗恋女孩，早已经嫁作人妇形同陌路的那种。 一直梦想走出边疆看一看中国的大好河山。吃遍中国各地美食。现在也只能在梦里想一下。 工作几年还是漂泊过一些地方，虽然并没有能周游中国。但是也是慕名去过不同的城市寻找美食。 初中的时候学过几天C语言，就被那老师忽悠觉得自己是吃这碗饭的人。高考时候志愿表上就填了一所大学，一个专业。四年过后事实证明当时我装B了。现在时代变化好快都跟不上时代了。 工作几年，现在只会编写一些简单的iOS程序来糊口。能力没咋长，各种乱七八糟的毛长不少。比如隔几天要去吃顿好的，比如看见了个软件就想买买了又不用，比如看见了书就要买，买了回来就吃灰。 最近一年看到自己可能不是能把技术做到Top 5%的人以上的人，也算热爱这个行业。因此在转型做产品中。 伪独立App开发者、白日空想家、YY大师、嘴炮高手、面基达人。 目前打工，艰难生存中。 住过的城市开远在这长到了18岁，已经没法回去的地方。 昆明在昆明上了四年大学，看过两次雪。收获了一段爱情据说要改成找到了真爱，也失去了母校。 东莞在中国最神奇的城市——东莞。我以为去东莞是去追寻自己的理想去改变这个世界，后来才发现是我想多了。但是来东莞是我开眼看世界的第一步。在东莞，我认识了一群可爱的人和他们一起踢球一起喝酒。认识了会做饭的少年。 厦门才到厦门的几天时间里面，我仿佛就融入了进去，习惯了厦门的这种节奏。 吃遍了斗西路附近的很多小吃。很奇怪的感觉，仿佛早在500年前就约定好今生见面那种。同时也希望我能在这里和曹哥一起做出改变小部分人的一小点点习惯的事情。 北京在帝都大半年，没去过故宫，没去过长城，没去过天安门，天天面基。匆匆而来，匆匆而走。 深圳除了房租就是贵，暂时没感受。 奥克兰钓鱼抓虾，上天入地。我来了。 主要修炼技能 How to Be Rich 思考 读书 品味 值得炫耀 没有任何值得炫耀的东西 主要爱好 看乱七八糟的书 想乱七八糟的事 打乱七八糟的游戏 观乱七八糟的美女 吃乱七八糟的美食 无力改变 懒癌末期 目前为止打过酱油的AppOhMyStar GridDiary 格志已经出了2，跟我理论上没有任何关系了。GridDiary2 哪里可以找到我微博: Yu_我就想叫一个简单的昵称 Bilibili: iiiYu Email: Yu Github: iiiyu Twitter: @iyunsn Facebook: iiiyu Linkedin: Ewan Xiao","link":"/about-me/index.html"},{"title":"时间轴","text":"","link":"/timeline/index.html"},{"title":"标签云","text":"","link":"/tags/index.html"}],"posts":[{"title":"2012年度总结","text":"扯扯其他 又到了一年一度的年度总结了，以前怕写，觉得人生如同复印一般没啥好写的。今年今日却是想好好写一点总结。2012还是自己本命年，12年恰好是一个轮回。12岁那年升入初中，这样使我有机会认识了5个现在值得交心交肺一生的兄弟。虽然现在天各一方，也可能许久没有联系。但是我相信兄弟之间是不必多说什么的。如果没有认识你们，我可能没有这么豁达，开朗。在风华正茂的年纪，我认识你们，你们认识我，是我们的幸运。 2012世界末日年，年初的时候我很彷徨和焦躁。因为我不知道我要做什么，我想做什么。当初觉得自己就是想去做操作系统，什么都不管不顾的去了东莞。其实是毕业那会儿见识的东西不够多，看的书不够多，看问题并不够客观理智。我并看不出来我应该做什么，只觉得做操作系统说出来应该很cool的样子。然而自己其实对这个行业根本不懂。在昆明了四年，虽然互联网触及到了世界。但是在边疆却是跟一线IT距离太过于遥远。 去东莞是抱着一腔热血去的，觉得能改变点什么。去了6个月以后才发现，其实我什么都改变不了。现实照进梦想，然后把梦想砸了个稀烂。有时候去了公司坐着，就想早点下班去踢球。颇有生活就像是一场强奸，既然你不能躲避，那就好好享受吧的意思。有两本书改变了我当时的心境——「浪潮之巅」「黑客与画家」。「浪潮之巅」告诉我不管IT或者是整个世界，都是一波一波的浪潮。如果在一个浪潮还没影子的时候入水，死。如果浪已经开始能看到形成的的时候入水，可以喝点剩汤吃点剩菜。如果浪已经达到顶峰的时候入水，死。如果是能在浪将起，但是还没有人能看出来的时候入水，就有机会站到浪潮的最高处。Apple是最屌的，硬深深的造出了一个移动互联网的大浪。我看到了浪起来了，所以那时候想趁还没有到最高点感觉去抢点剩菜吃吃。「黑客与画家」告诉我，能力够的话创业比打工好。年初的时候就想着辞职了，投入移动互联网的浪潮中。纠结的只是两个事情，一个是我其实并不会移动互联网的开发，甚至连互联网的开发技术都并不具备。二是并没有做满一年，跳槽是大忌。连一年都没有做满更是不是很好，会给人很浮躁的感觉。直接导致了年初的几个月白天在写linux c。晚上回来ruby iOS的乱弄。貌似精神分裂一般。也天天在想这个事情怎么弄。最后，我还是决定跟着感觉走吧。就辞职了。 辞职的事情，一直觉得有些窘迫。因为那会儿项目比较紧需要人手的时候，我提出辞职，感觉就像逃兵一样。然后理由就扯了一个其他的，虽然是事实但是也并不是真正的原因。辞职是裸辞，决定破釜沉舟的去帝都找一个房子住下来，然后慢慢学iOS开发。然后一个月后在去找工作。 直到我遇见了曹哥。在今天回头去看，只能说我的运气确实好了点。本来已经定了去帝都的机票了，结果我收到了一封Email然后加了曹哥的QQ我们聊了聊。曹哥就说要不来厦门当面谈谈把，我那是很是犹豫。虽然在V2EX上就看见招聘，第一是我认为那会儿其实我什么都不会。第二是萌小萌在帝都。这个距离也比较遥远。见我犹豫的时候，曹哥说没关系啊，就当来厦门旅游了。路费住宿报销就好了。士为知己者死，女为悦己者容。在江湖混讲究的就是义气二字。娱乐一下。 我推掉了去帝都的票，赶了火车来到厦门。 厦门逛了逛，跟曹哥谈了谈。那会儿也不知曹哥是有多猛。毕竟我不是混互动广告的啊。只是觉得曹哥人很好，做东西很用心。对技术很成熟的看法。sumi工作室的环境简直就是我觉得现实中的最理想工作场所。如果留下来能做的肯定是接下来几年都能想做的东西。厦门整个城市的节奏也满好。然后曹哥也愿意手把手的教我。唯一的问题就是萌小萌在帝都。然后当天晚上我跟萌小萌说了一下情况。萌小萌决定支持我留在厦门的时候。感谢萌小萌的理解。这样2012我最后留在了厦门至今。 ##工作状态 也许是我的注意力和意志力的问题吧。100分满分。 同情分 友情分全部加加勉强能给一个60分。我的技术进步速度一直在拖沓在项目的进度。以至于需要停下整体进度来等我的部分完成。本来我应该可以做到80分以上的。可是一直顶多能及格的状态下上起伏。这是我人的问题，懒惰，不上进。 ##blog状态 计划中的blog更本就没有更新完。目测起码欠上了十几篇。完成率相当低。不及格。 ##读书状态 回去有时候都懒得看书了，不过还是断断续续看了一些。勉强70分。但是读书笔记写的少 扣10分。 勉强及格 ##感情状态 和萌小萌除了异地 一起都蛮好。2012的最后一天，wwl当爹了。我突然就很难想象我们在一起一人喝一打啤酒的时光。仿佛那些已经是不可重复的往事。一去不复返了。从小学到高中一直都是同学的张娟同学，在大四才开始谈第一恋爱的人——结婚了，并且在上海买了房子。意料之外，情理之中。我一直觉得结婚就是9块钱的事情而已。何时何地不可以。可惜只是我有情，妾无意啊。就暂时让wwl领先我两个等级咯。 ##感谢 2012要感谢一直让我为所欲为的父母。不管是去东莞去帝都去厦门。他们都一直支持我。尽管他们很想让我留在身边。可是我还是跟着我的心一直走并没理会他们的期望。感谢萌小萌，在她最好的年华里面陪在最一穷二白的我身边，支持我。感谢曹哥在我什么都不会的时候手把手一点一点教我。感谢巧玲姐陪我一起去看租房。感谢sumi的90后们。你们让我知道我之前的见识是有多土鳖。感谢海军教我做菜，一起喝酒。感谢对我好或对我坏的人们这样才能使得人生丰富多彩。感谢肠粉在平日里面带给我们的欢乐，虽然他现在去征服世界了。 我，萧宸宇24岁时2013年1月1日这天，在厦门斗西路58号2楼。希望2013年大家都安好。Sumi必胜 Oh Yeah！","link":"/2013/01/01/2012-annual-summary/"},{"title":"新 iOS Human Interface Guidelines  产品解读 （一）","text":"本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. What’s New in iOS 10 小部件 整合Message 整合Siri 扩展通知 产品解读小部件小部件目前感觉用处不大啊，虽然进化了更加强大。但是个人在之前的使用并不多。另外现在一按Home就指纹识别进去了。暂时觉得停留在锁屏的情况略少。 整合MessageMessage 杀入已经不知道竞争有多激烈的 IM 战场。时机看上去偏向略晚，但是有些事情虽然做了有99%失败的可能，但是如果不做的话，那就是完全没可能。在 iOS 10 之前， Message 对我来说只是一个短信的补充，方便我跟用 iPhone 的朋友不需要用短信联系。随着6月14日凌晨的发布以后，看上去做为更加开放的 iOS 生态中重要的一个环节， Message 允许其他应用的调用以后。用户整个关系链就从通讯录直接变成了整个 iPhone。 你们 Facebook、 WeChat、Snapchat 不是号称是巨无霸 App 么。说将来只需要安装这些App就好了，这样其他应用要怎么活啊。Apple 把 Message 这种系统级别的功能开放出来，意味着让关系链从系统级别植入到App，也能缓解一些巨无霸 App 取代系统的趋势。 举个例子：比如说我有个工具类美颜App，想要变成一个社交属性。直接去维护一个用户系统和关系链要投入多少啊，现在只要接入Message，关系链立马就获取到了。我认为是对小型团队和独立开发者是利好消息。由此往下想的话，Message里面迟早会出现类似朋友圈的东西？ 当然 Message 做为 IM 的缺点显而易见。 Apple 封闭的生态环境里面。 Apple 整个系列都可以使用的很爽，但是放到真实的我们这个接近八成都用 Android 的世界里面。仅仅只是 iPhone 关系链是无法做到一个全世界的 IM 的。像不像微软一样，踏不踏入敌人的领域里面去开疆拓土，这是一个我只能静观其变的结果。 PS：开放出发送消息的接口，会不会被国内众多的垃圾信息所利用也是值得当心的一点。 整合Siri从 Siri 出现的第一天起，我就不止一次的 YY Siri 能用到自己的产品上，那种在10年或者20年前电影里面的人工智能场景，终于离我们的生活更加进了一步。 同整合 Message 一样， Siri 的开发 API，为应用的入口增加了一种可能性，让应用跟 iPhone 继续的浑然天成。虽然说对着 iPhone 自顾自的说话确实有点傻，但是我拿Siri定个闹钟，记个提醒事项还是很方便的。所以等待合适场景的App出现，Siri 的利用率会越来越高的。 扩展的通知消息在通知消息上可以定义更多的功能和事件，在一些不想解锁的情况下提高效率。举个例子：欧洲杯刚刚结束一场比赛，一个App推送比分过来，你想知道谁进的球，只用双指一扩，就可以看到比赛的简报，简单方便。 简单的来说是通知可以做的事情更多了。 总结目前为止，我看到大量的 3D Touch 技术在 iOS 10 上的应用。也就是说当前 iPhone 的保鲜期为1年，2年前买的 iPhone 6 和 iPhone 6 Plus 已经不能享受最新的 iOS 版本进化福利。阴谋论的恶意揣测一下这难道是 Apple 为了提高 iPhone 销量的手段之一么？ 也看到了在一个大环境是封闭体系的情况下，Apple 在为开放做出的种种努力和变化。 不论是 Swift 的开源， 还是 iOS 10 把系统应用的一些API逐渐提供出来。至少今天，世界变得美好了那么一点点。","link":"/2016/06/14/2016-iOS-Human-Interface-Guidelines-1/"},{"title":"罗永浩的进化","text":"锤子科技的本质至少从我能接触到所有信息来看，锤子科技对自己的设定都是一个软件公司，致力于做出对人类有价值的软件。对标的对手是苹果，至少从昨天斗鱼上面的弹幕来看，坚持了这几年的形象输出还是获得了一定的辨识度。比如有弹幕在刷手机参数时，就会有弹幕再解释锤子科技是一个软件厂家而不是硬件厂家。 不过在我看来，锤子科技是一个由个人魅力和先描绘一个完美理想而组成并且处于孩提时代的公司。而现实世界在有一次又一次的打击在不断的教育着他。不过此时此刻来看，至少锤子科技还活着不是吗？ 因为锤子科技的最核心和最大价值是罗永浩，而罗永浩首先对应的是其实是广义的精英人群。整个发布会上很多佐证的证据，比如用户群体跟 iPhone 的用户群体高度重合。比如发布会上孜孜不倦的在讲授深度集成的功能。再比如那“有一千种赚钱方式，我就偏偏选择最困难的一种。”的情绪宣泄。 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 锤子科技的进化锤子活了下来，靠的不是运气。是不断的进化，罗永浩的进化。 罗永浩逐渐的进化为一个商人，这个其实是锤子能活下来很重要的一点。仅仅依靠一味的精雕细琢产品是没办法作出一个普罗大众都能受益的产品。但是活下去才是改变世界最根本的基础条件。而生活质量的提高会助力创造力的解放。所以我认为锤子科技要改变世界的终极目标之前，是能尽快的赚钱，赚大钱。而罗永浩显然没有到哪种放低身段在一个臭水潭里面跟一堆饿狼争食。 也行坚果 Pro 是锤子科技进化以后在当下做的最好的答卷了吧。 效率 VS 易用 进而产生的问题看完以后整个发布会后，其实我有点被感动，有点惋惜。感动的是锤子科技在几个强迫症产品经理的带领下，把一些场景下的效率提高了很多。 惋惜的是这注定不是普罗大众的产品。 高效率和高易用就是天生相克的，在一定科技生产力下目前看来是成立的。 举几个例子，飞机比汽车快，操作起来飞机比汽车复杂。Emacs 和 Vim 比记事本要有效率，上手难度大家心知肚明。 所以，发布会上罗永浩和锤子科技用了剧情反转和巨大的篇幅来介绍整个 Smartisan OS 中三个深入的功能集成。 剧情反转为的是注意力不要被硬件分散注意力。长时间的演示是为了，真的是为了想把这些提高效率的功能讲清楚而已。 抛开是否原创的问题， One Setp， BigBand，Idea pills。能这样深度的集成到系统里面。其实真的非常非常不容易。自己做过开发知道按时发布，演示时候顺利通过是需要付出多少努力。在能够想象的场景里面确实提高了效率。 而且当你学习越多，使用更多的时候。在特定场景下，就是效率神器。而且我认为在效率上去做努力，进而切到移动效率平台上，貌似是有价值的。iPad 不就是切这个领域为目标么。 但是，随之而来的就是，本来就是精英用户人群的市场，在进一步切到了精英用户中高效率用户人群。目标人群进一步缩窄。在面临着赚钱，赚大钱的这样阶段上，从纯粹赚钱的角度来说，坚果 Pro 和 Smartisan OS 并没达到一个较好的预期。 在我的世界观里面，绝大部分人类还是遵循着一些原始的行为。 比如偏爱高热量的食物、看书就发困、在夜深人静依靠着荷尔蒙在摇一摇等。如果需要做一个爆款产品，在同一科技水平下很可能不会是一个高效率的产品，但一定是一个易用的产品。举个例子：我认为 Slack 比 Wechat 要高效的多。 Wechat 比 Slack 易用的多。 所以 Wechat 比 Slack 用户多的多的多。 很多时候在大科技的同一水平下，人类并不会太过追求效率。 所以，有点惋惜。只是在今天，我看不出坚果 Pro 是一个爆品手机。 再举一个类似的例子，但是我认为是爆品手机的例子是美图手机。 因为解决拍照好不好看这个用户痛点的价值在我看来比高效的编辑一段文字要有值钱的多。 恰好在微博看见了这两个有趣的图 再意淫一下，如果现在我有资源能做一款手机，我会把打王者荣耀上分容易作为这款手机的最大卖点。 发布会上几个可以改进的地方 请一定要按时开始 发布会节奏简练一些 老罗做串场和最关键演示，多几个人分段。（一个人做整场，需要花费的精力和效果没发保证） 口头禅 “听明白了吗？” 配合着介绍着那些高效率的功能，有种还在新东方的即视感。（我没注意到，萌小萌说很突兀） 好不容易做了接近整场的企业家罗永浩，到最后情绪激动时候还是没有绷住。变为了老罗，脱口而出了今天我在微博上看到转发最广的这句话“如果有一天，卖了几百几千万台，SB都在用我们的手机，你要知道这是给你们做的。”（一声叹息） 少年的英雄主义去现场看一看老罗，听一听老罗的单口相声一直是一个心愿。 那天大麦网两点放票， 结果有事情，忙完以后都四点多。我点过去已经没票了。 老罗在我心中一直是一个很特别的存在。每次提起老罗，我的思绪都会飘荡在10多年前的高三教室某个下午，老师在说着无聊的卷子。我猫在教室的后排用一个廉价的 mp3 听着网络上下载的老罗语录。听到好笑的部分，憋着满脸通红的抖动。至今我都能回忆起来“华盛顿的樱桃树”，“俞敏洪在拉斯维加斯的离婚感慨”，“手心手背都是肉，掐一下手背更疼”，“如何减肥”，“走在大街上被查居住证，如何应对”。那个声音在一定程度上使我成为了今天的我。 以至于后面自己创业的时候，也是按照这样的思路去做。结果就是不赚钱儿。 没人理你。所以一直传言锤子要倒闭的消息，我是认为锤子科技真的过的很艰难。 所以，老罗作为一个商人、企业家。把自己的价值贡献出去，尽可能的在挽救公司。我认为是商人罗永浩进化的一面。也是怼天怼地的老罗悲壮的一面。 我更喜欢我记忆里面那个在新东方课堂上被录音的老罗。随意的怼天怼地怼世界。 当然我也很希望看到一个怀着理想主义的商人罗永浩站着，克服了千辛万苦站着把钱给挣了。这样至少证明这样做事是可以成事的。世界可能会变的那么美好一点点。 当然最后的代价可能是老罗的消失和完全体的商人罗永浩了吧。 可是最后没崩住那句高高在上的态度，说用户是傻逼。 说前一代设计是耻辱的时候。我不知道用户怎么想，我不知道锤子员工怎么想。至少如果同一时间要变成老罗和商人罗永浩是不可兼得。这样的混合着老罗&amp;商人罗永浩我不想看到。 所以，还是希望罗永浩能变成一个成功纯粹的商人。把老罗留在 mp3 文件里面吧。","link":"/2017/05/10/2017-smartisan-digital-conference-view/"},{"title":"一个关于电子烟的互联网生意设计","text":"电子烟火了？今天君神发了张图给我。 然后我的思绪，就忍不住飘到两年前。我决定全力投入电子烟产业的4个月时间里。 现在回顾过去，貌似没有留下啥。又是一个我没能完成的想法。可是心有戚戚焉，不吐不快。那我就把对电子烟产品的整个思考记录一下。如果真的有从事者得到一起启示也是一件乐事。 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 我与电子烟首先我其实不抽烟。了解到电子烟纯属偶然。我一直都在乱七八糟的想一些奇奇怪怪的事情。一段时间里面在思考如何能赚个钱。大概在2017年3月份的某一天晚上，躺着无聊刷手机的发呆的时候看到一篇关于电子烟的文章。然后用了5分钟思考了一下感觉是一个未来的行业。就兴奋的睡不着。通宵研究了一下整个烟草市场。觉得大有可图，但是有点闲钱和时间。就决定尽情投入一次。 我大概投入过 30瓦-250瓦不等的一系列盒子。 两根机械干。 第一批发货的山岚电子烟。 一堆正品、精工雾化器。 一堆进口不进口的发热丝。 两包无印良平的化妆棉和几袋进口棉花。 超过20种从美国到马来西亚的各种味道烟油。 几大瓶VG、PG 一套当时最好的做丝工具。 两个域名 一个花钱请设计师设计的Logo 一堆社交媒体的账号 几个有电子烟affiliate的平台账号 往返了三次福永 加了几十个电子烟销售 每天看老董的视频和蒸汽巴士的测评 例举出来，主要是证明一下。对于电子烟我虽然不精通，但是还是算刚刚入门。所以下面的观点建立在2017年我入门的基础上。如有不妥，欢迎讨论。 设计Logo 电子烟 VS 传统香烟先说结论，我认为电子烟在健康方面是优于传统香烟的存在。如果烟草这个事物不会消亡，那电子烟一定就是进化来的下一代。 我有关电子烟最基本的知识结构全部来源于BBC的记录 电子烟：奇迹抑或威胁【中英字幕】 其中对于为什么电子烟会更健康的阐述，对于我一个具备高中科学素养的人来说能看懂并且具有强大的说服力。 简单来说就是香烟中最有害的部分是因为使用燃烧这种剧烈的化学变化，产生6000多中物质混合。过程很难控制并且验证那些物质会致癌有害。 而电子烟是一个气化过程，是物理变化。烟雾中的物质很稳定。生成物成分有限，过程过程容易控制。这就给研究验证提供了坚实的基础。 在换个角度来解释，如果把传统烟草和电子烟当作一个要过FDA的新药。我认为电子烟会更容易的通过检测。 电子烟当前市场 用户画像众所周知，烟草市场在全世界都是庞然大物的存在。电子烟目前的市场非常非常小。根据我的了解，电子烟的使用者为两类 Vape是一种潮流文化，我爱这种潮流文化 因为对尼古丁已有依赖，使用电子烟对自己健康和周围人的健康会更好。所以使用电子烟来替代传统香烟的人。 现实中两类用户虽然略有重叠。但是如果把所有烟民看作电子烟的潜在客户群体归类为第二种的话，那两类用户就是完全不同的用户群体，对于不同的市场。 如果做Vape的市场，需要使用垂直行业潮流时尚打法来设计。 如果做烟民市场，看看各大烟厂的税收记录，那你面对是星辰大海。 设想中的电子烟生意扯了这么多，来说说我YY中基于自己情况感觉比较好的一个方案吧。 首先，我对于电子烟除了上述所说，基本算个外行。其次，我没有调香技能（做不了烟油），没有工业技能（做不了设备），没有工业设计技能（做不了山岚）再次，我想做一个离钱近一些的东西。这样容易赚到钱。最后，我有的只是一些所谓的互联网思维。 然后从场景的高频低频和走访福永后分析得出，卖烟油比卖设备要赚钱。然后肯定要做整个烟民的生意才是好生意。不要局限在Vape潮流文化里面。 所以我YY中如果有那么几百万的天使投资。我要做电子烟行业的订阅服务商。简单类比就是移动、电信、联通模式 —— 充值话费送手机。 “订阅烟油送设备” 显而易见的好处是，为烟民进入电子烟的门槛尽量降低。并且拥有话题度。最后流量模式起来以后，不跟我玩的。都要bye bye。 不投资建厂，去谈OEM。 最后再去背靠一个烟草厂。让他给我收购掉就美滋滋了。 然后在用在移动互联网学到的一套运营起来。设想中能起来。 电子烟的困境电子烟其实目前我认为在黎明的前夕，就不知道能不能熬到天亮。 我认为电子烟本身的缺陷在于3点： 有让未成年尝试并且依赖上的便捷性。毕竟有Vape潮流文化在那边。就像当初我们看周润发、张国荣、古惑仔抽烟很帅一样。 因为烟油的生产是工业化的流程，新型毒品很容易结合到电子烟上。而且生产脱离了产地的限制。使得监管困难度上升。 烟油中香精的安全界定不完善。可能将会发生的事故会导致整个电子烟行业备受质疑。 在现实中，目前很多国家对电子烟都保持了很谨慎的态度。 而且如果在中国做这门生意，很大程度上会依赖政策法规的问题。 总结我坚定的认为烟草会逐渐的被电子烟取代，这个趋势不可逆转。我们会逐渐过度到一个二手烟没那么难闻，那么有害的世界里面。 乱乱的也不知道写了些啥。就算一个肄业产品的碎碎念吧。思考了、行动了。最后如果连一篇文字都没有留下。可能会有点难过吧。很多细节其实考虑了的，只是太杂太碎不知道怎么写完备。虽然最有用的就是一句“订阅烟油送设备”。但是其实里面很多东西的。如果哪天出现了一个类似的模式做大做强了。吹牛逼也就有了话题。 很多东西我都是在脑子里面想到。但是不能做到的。这点是我老婆告诉我的。希望自己以后能想到并且做到吧。 硬广时间我现在生活在新西兰。如果需要婴儿奶粉、保健品、程序员熬夜神器代购可以通过么么爪新西兰代购。价格跟淘宝没法比，但是只能用我可能并不存在的程序员信誉担保都是正品。","link":"/2019/01/25/A-Product-Design-About-E-cigarette/"},{"title":"2017年世界进化论","text":"世界观我认为在2017之初，人类文明世界将进入一个新的阶段。不过回顾人类历史，相似的情况时有发生。所以这应该能用螺旋式的上升来说明情况。所以本文会以作者自己的视角来阐述几个思考过的方向。并且简单下结论。 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 人类文明世界得力于科技进步，在过去的100年的时间里面。整个地球上的人类文明世界进行了前所未有的交流和融合。特别是过去30年里面基于互联网的全球化，让地球上人与人之间的交流变的唾手可得。产生了不可想象的信息和前所未有的巨大财富。同时全球化的黑暗面也一同长大。 这两年发生的大事件——欧洲难民问题、川普当选总统、英国退欧等等。都揭示着，全球化带来的副作用已经开始蔓延。 在基于自私人性的考量下。 人类文明世界将从之前100年的全球化发展。逐渐变成局部自己跟自己玩的发展。毕竟“一室之不治，何以天下家国为？” 这是人类文明世界的自我进化。属于历史洪流无法抵挡和改变。 互联网世界我接触互联网根深蒂固的思想免费、开放。得力于免费和开放，互联网的信息量在过去20年间增长数量应该每年都会刷新之前的总和。我们称为信息大爆炸。可是人生100来年。整个世界的信息量对个人来说是远远过剩的。无门槛的免费和开放不再具备更多的吸引力。所以我们能看到做信息筛选和信息推荐的公司迅猛发展。把握着社交关系的巨头们都在逐渐的封闭自己。 所以下一个20年的互联网世界真的会不太一样。会变的更加封闭，更加聚焦领域。 地球新世界AlphaGo 先赢李世石后用马甲在各大围棋网站横扫顶尖职业棋手。貌似预示着一个智能的新纪元的开启。我不禁思考人类的本质和我自己存在的意义。 如果从最大的广义宇宙来说，整个里面的物质都是恒定的。里面有什么东西都不重要。那作为一个生命体是为什么存在？那作为一个智慧体又是为什么存在。 存在的意义在我18岁的时候无法明白，到28岁的时候还是一样无法明白。而现在我能想清楚一个事情就是。从地球上第一个有机物到我这里，都在做一个事情——那就是进化。 进化其实是没有目标的，只是环境选择了一些进化得以延续。一些进化消亡了。 随便说一句，很小的时候我就在想，凭什么智慧都必须建立在碳水化合物上。就因为我们自己是碳水化合物么？就不能是几根排列玄妙莫测的石柱子，一个内回旋特别的岩洞。自己经过千百万年的进化，自动的产生了更加高明的智慧么？我们无法理解的智慧。 说回来，难道你们觉得人类作为一个智慧生物。在当下这种科技和信息爆炸的时代。我们的肉体和灵魂进化实在是太落后了。简单来说一个人类需要18年消耗无数资源才能到达一个勉强智慧的个体。而且当千辛万苦获得了大智慧以后，100年后必定消亡，无法延续，无法直接继承。 而且作为人类这样的智慧体，还有各种缺陷。生物欲望，黑暗面欲望。如果把地球文明看作一个整体进化的话。人类这样的基本个体几乎太不合适了。 但是现在，我能看到下一个阶段地球文明进化的基本个体——机器智能。人工智能的说法只是一厢情愿，将来的机器一定比我们不知道高明到那里去。 所以最后说我的结论，在今后的这100年里面。人类最重要的进化已经不是通过生产下一代人类来完成。而是做出来一个类似电影终结者里面天启类似的机器智能。替代人类作为地球文明继续在宇宙里持续进化。一直到下一次文明的新个体替代出现。 总结可能写的有些凌乱，但是这样想法一直一直在我脑海里面游荡。所以我还是决定把它们写下来。作为一个智慧体对这个世界当下的思考。与君共勉。","link":"/2017/01/20/2017-world-theory-of-evolution/"},{"title":"鱼子酱的胡思乱想 —— 天下武功唯快不破","text":"用快强行解释什么是价值我们常常说，要做带给用户有价值的东西。但是到底什么是有价值的东西呢？如果用快来解释的话，大概分两种情况 之前做不到，但是之后可以做到。 之前只能很慢的做到，之后能更快的做到。这两种情况都能给用户带来价值。 用快强行解释传统行业的例子 为了更快的行动速度：飞机&gt;高铁&gt;汽车&gt;马车&gt;双腿。 麦当劳肯德基更快的做出食物 机械化农业更快的完成工作 机械化工业同上 他们产生的经济效益也是类似的，越快得到的利润越多。 用快强行解释移动互联网的例子 微信是做到了更快的交流（个人认为 Telegram 更快一些） Uber做到了更快的叫车服务（滴滴一样） ele做到了更快的送餐服务（美团、百度等等外卖一样） 陌陌做到了更快搭讪陌生人 支付宝做到了更快的付款（微信跟支付宝差不多， Apple Pay 更快但是层面不是同样的东西） 众地图应用做到了更快的导航寻路 微博做到了更快的扩散内容……等等等这个列表可以一直列下去。所有做的好的产品都可以强行用快来解释。 得到的简单结论 —— 天下武功唯快不破简单的判断一个产品有没用价值，价值的大小。可以跟现有产品进行比较，如果它比现有产品更快达到目的那就是有价值的东西。提高的速度越快，相应的价值也就越大。 因此在做产品或者是创业中， 就算撞车到了一个相同领域。只要你能保持是同类产品中最快解决问题的。那就是能保持竞争优势。而且这里的快是更加广义的快，你的技术团队比对手跟快的迭代产品，你的公关比对手更快的消除负面影响。你的运营团队能比对手更快的写出高质量的内容。 殊途同归 —— 天下武功唯快不破 当然只用快来衡量价值是片面的，不严谨的。思考到这里，我突然觉的可以用一些简单的理论和数值来构建一个简单的价值计算公式。不过那就是后面看看我有没有心情把他写出来吧。 碎碎念年前爆出的张小龙的饭否其中有句这样的话“要提防那些blog写得好的产品经理，因为在Blog上花的时间越多，在产品上花的时间就越少。原来还以为有例外，现在看起来无一例外。” 由此引发出来“要提防那些Blog写得好的程序员，因为在Blog上花的时间越多，在工作上花的时间就越少。原来还以为有例外，现在看起来无一例外。” 五味杂陈，到底要不要写Blog的。我不知道自己算不算blog写的好。如果不算，那岂不是变成Blog也写的烂，产品 or 技术也烂的人。 如果算，那是不是仅仅是Blog写的好呢。 我承认，如果我要产出一个我觉得还行的文章，我起码需要四五个小时的时间，一般横跨2-3天的时间。我也知道很多对这个世界有着很多独特的思考的产品大牛和技术大牛。他们忙着做自己想做的事情，并没有时间写Blog。不写Blog并不妨碍他们成为大牛。我也还见过一些天天在SNS上蹦跶，发篇Blog恨不得把所有人都@上，其实水平可能还需要更多时间的打磨的人。 兜兜转转，我想天下熙熙攘攘，就算是一条咸鱼，我要努力证明我的不同。继续写Blog吧！！！ PS: 欢迎关注我的微信公众号:","link":"/2016/02/23/A-product-manager-cranky-Martial-arts-world-but-not-fast-breaking/"},{"title":"被误解的微信小程序","text":"自媒体的瞎几把解读前几天一篇《小程序上线7天，罗胖带着1000万用户跑了……》到处都能看见，而里面就罗振宇的一个微信聊天截图而已。搞得好像仿佛微信掉了1000万日活似的。好像得到的那些用户就不用微信似的。都TM瞎几把跟着起哄。当下这个时间点怎么看着黑小程序变成了一个政治正确的事情。跟两三个月前万众瞩目，全民吹捧形成了巨大的反差。 所以，需要带着独立思考去看待小程序这个事情。对理解小程序、理解这个世界的基本前提。 其实吧，不必把小程序这么妖魔化。在我看来这是微信进化自然的结果。不负责任的猜想，类似的进化应该也在 Facebook、Line 里面发生着。（PS：支付宝那个小程序技术上算同类型，但是我觉得产品上不是一个东西。因为支付宝本来就不应该是微信 Copy 啊） 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 微信 OS ？要弄清小程序，首先要弄清楚什么是微信。小程序为什么诞生在现在这个时间点？是因为微信自身发展进化到了一个操作系统！ 传统操作系统是什么，是管理计算机硬件与软件资源的计算机程序，它提供了进程管理、内存管理以及磁盘与文件系统等等基础功能，而在这个基础功能上，我们才能提供使用这些资源开发出来的更多的软件比如：Office、Photoshop、游戏等等。为人类带来价值的事情。 如果微信已经是一个操作系统。这个观点并不是我第一个提出，很早之前就有人在说这个话了。微信是一个操作系统这个怎么来理解呢？ 在我个人来看在小程序之前，微信都是在进化成接管所有用户的使用入口。把基于硬件之上的真正的操作系统，又再一次的抽象和封装了起来。这样的进化结果有： 所有用户都可以用微信作为主要移动互联网的使用基础平台。 超越了不同硬件和不同平台。iOS 用户和 Android 用户的大统一。 微信操作系统的基本元素是基于社交关系和 IM 的基本功能，所以如果以传统操作系统的思维去思考肯定行不通。 微信小程序的正确姿势首先，明确一下概念： 不要以做 App 的思路做小程序！ 不要照搬 App 的样子做小程序！ 不要觉得 App 是什么小程序就要做到什么！ 最简单的道理就是 App 是简历在手机操作系统上的产物，你用手机操作系统为基础的产品思路去弄了微信操作系统上的小程序产品。怎么可能做的好么。 微信操作系统的特点： 做到了中国境内迄今为止最大的用户覆盖 几乎做到用户唯一识别 有最好的移动互联网沟通体验 然后，我认为小程序适合做什么： 通过二维码连接人与万物，本质是连接物后面的服务。 做微信操作系统的功能增强，简单说来就是 IM 插件。 举两个例子： 共享单车特别适合这个人与物连接的场景，最大的价值是用户使用了单车服务。线上产品不论是 App 还是小程序都只是为了连接人和单车的关系然后提供服务。所以，我坚信除非这些共享自行车企业倒闭。只要做了小程序的，我相信在不远的将来小程序里面的使用量一定会超过自己的 App。 知道 Slack 不。 如果你的产品能增强现有微信的聊天功能，一定是微信操作系统下需要的东西。针对细分聊天情景下的聊天增强辅助一定是有价值的。如果还是无法想象，那去搜索一个叫“动动文字”的小程序试试看。 所以只有对自己提供的服务和微信生态有深入的了解。才能思考产品价值和微信生态之间共处的关系。设计基于小程序的产品，业务流程都会为了适应微信生态发生改变。信任微信操作系统这一基本建设，才是做一个合格微信小程序的前提。你把 App 整个思路搬进来，我个人是呵呵呵的态度。 对微信的期望虽然现在小程序开放的功能有限。但是微信如果真的是以一个操作系统方向去进化的话，功能增强指日可待。我能想象一堆协同服务的都只用专注于服务。而不用在纠结 IM 上的基本功能。 罗马不是一天建成的， iOS 也不是第一天就有这么多功能的。在2017年1月这个时间点里面。我依然对微信未来的进化会变的更好。 最后的碎碎念对了，我也觉得微信封闭不好。但是从宏观来说微信封闭是历史选择进化的部分，不想细说。只是作为被国内同行衬托的一股清流。给微信多一点期待还是一件自然而然的事情。希望微信真的能做到微信操作系统的那一天，我拭目以待。","link":"/2017/01/22/Be-misunderstood-of-the-miniapp/"},{"title":"新西兰徒步指北 - 奥克兰 Maraetai Coastal","text":"本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 步道地址265 Maraetai Dr, Maraetai, Auckland 2018 GPS定位：(-36.8816430, 175.0477450) 从City出发，开车大概需要40-50分钟不等。开车的路都很好走，没有山路。 步道难度1星 123451星 —— 合家欢乐2星 —— 稍微需要一点体力3星 —— 路面较原生态，具有一定挑战性4星 —— 需要具备专业知识和做好充足的准备5星 —— 路程远，路途中有较多危险路面。需要专业素养。不要轻易挑战 步道适合年龄0-99岁，全年龄段。 步道路线 &amp;&amp; 步道长度 到休整点返回的时候，可以原路返回。这样就来回都是海岸线。 来回大概12km 按照吃完晚饭遛弯的速度，3个半小时足以来回。 徒步装备 普通运动鞋 750ml左右的水（推荐：功能性饮料） 如果徒步时间跨越了饭点，请准备好一些食物。（推荐：巧克力、士力架以及想要带着吃的东西） 准备好防晒霜（推荐：可以直接喷雾剂样的防晒霜，路途中随时补防晒） 帽子 透气性好的衣物 由于全程几乎95%以上的路面都是人工路面，路况非常的好。 可以骑行 可以带小滑板车 甚至可以带电动平衡车 路线上有巨大的草坪和在一开始停车的地方有沙滩草坪，可以携带足球、排球等。跟朋友一起嗨。 注意事项任何步道和徒步中全程严禁抽烟！请多带一个搜集垃圾的垃圾袋。任何垃圾(包括果皮和果核)请带回家。 一些体会人比较多，其实大部分就是修的很棒的泊油路。所以完全是0难度的徒步。 由于是东海岸和整个海岸线是向北的。如果想要拍照好看的照片和录视频。建议再日落前4小时出发。这样回来的时候可以拍到很漂亮的照片。 我们是早上10点左右到达的，太阳直射，拍出来的照片，曝光惨不忍睹。 在出发大概20分钟左右，在一个Playgroups的旁边。海边有一棵很大的歪脖子树，反正随行的同事爬上去照相了。感觉是个不错的照相地点。 而且看到有人钓鱼，所以有钓鱼打算的话，需要注意一下潮水时间，你可以在涨潮前钓鱼一波，然后开始退潮的时候 一些图片 一些视频","link":"/2018/08/15/New-Zealand-Hiking-Guide-No-1-Maraetai-Coastal/"},{"title":"新西兰徒步指北 - 奥克兰 - Shakespear Regional Park","text":"本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 步道地址Shakespear Regional Park - Waterfall Gully Bruce Harvey Drive, Army Bay, Whangaparaoa GPS定位：(-36.7012993, 174.7044689, 11z) 从City出发，开车大概需要1个小时-1个半小时不等。开车的路都很好走，没有山路。可以走一号高速 步道难度2星 123451星 —— 合家欢乐2星 —— 稍微需要一点体力3星 —— 路面较原生态，具有一定挑战性4星 —— 需要具备专业知识和做好充足的准备5星 —— 路程远，路途中有较多危险路面。需要专业素养。不要轻易挑战 步道适合年龄10-60岁，虽然没有什么特别难走的地方。但是一个上小坡还是有点角度。而且很多地方是没路的草地只是有路标。所以如果没有行走能力需要辅助器材。或者体力不太好的人是不适合此条徒步路线的。 步道路线 &amp;&amp; 步道长度 全长大概6KM 正常速度1个半小时左右，今天是有个朋友腰不好，我们走走停停。 徒步装备 普通运动鞋 750ml左右的水（推荐：功能性饮料） 如果徒步时间跨越了饭点，请准备好一些食物。（推荐：巧克力、士力架以及想要带着吃的东西） 准备好防晒霜（推荐：可以直接喷雾剂样的防晒霜，路途中随时补防晒） 帽子 透气性好的衣物 注意事项任何步道和徒步中全程严禁抽烟！请多带一个搜集垃圾的垃圾袋。任何垃圾(包括果皮和果核)请带回家。 一些体会Shakespear Regional Park 里面有烧烤炉，是众多聚会 BBQ 的地点之一。可以约上几个好友。带上食材前往烧烤。 这里还有绝美的沙滩。如果你注意潮汐时间，赶上了退潮的时候，还可以捡到美味的 cockle。 （注意：只有下去捡贝壳的人可以带走50个。所以如果捡多了，就把小的再放到海里吧。） 我们是2018年8月26日去的。路线上好多草地都处于放牧状态，所以在徒步路线上，牛羊排泄物较多。请做好心理准备。而且途中可能就会直接面对牛和羊。请不要惊吓他们。安静的走开是合适的处理方式。 在步道入口出，有大相框。建议打扮漂漂亮亮的去拍一张。作为打卡照片。 一些图片 一些视频","link":"/2018/08/27/New-Zealand-Hiking-Guide-No-2-Shakespear-Regional-Park/"},{"title":"读书笔记「微信思维」","text":"本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭。本文仅作为个人学习记录使用，也欢迎在许可协议范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助，您可以使用RSS方式订阅本站，这样您将能在第一时间获取本站信息。 碎碎念先感慨一句，在看不见的地方，有很多人都比我更加努力！ 导读厚厚一本，其实读起来还是挺快的。3个小时左右初略的看完一次。整个书是用了一些真实的案例来说明。但微信这个天朝移动互联网最大的平台。在开放现有资源的情况下是怎么建立新的世界次序的。微信真的改变了中国人的生活。 以下文字重点在看案例以后的感想 第一章案例：好药师 感想：看的时候嘘唏不已。在2013年的时候，无意得知云南一心堂在想推进电子商务，过年回家的时候就过去跟某部门负责人谈了谈。心中冒出很多有趣的想法，其中最重要的就是，一心堂已经有售药牌照的情况下，在已有的店铺和仓储物流上。以最后一公里送药上门的切入点，最后变成一个综合性电商。可以自己做或者考虑跟京东置换资源(当时觉得两家都没有上市，虽然jd大，但是一心堂的地区优势明显，而且有药品这种类型是jd缺乏的)。不过鉴于我一直是微小一般的存在。也许根本无法推动这种事情的发生。 案例：联想 感想：当联想在我家那种一百八十五线小城市里面都可以开起2、3家专门店的庞然大物（也许是山寨的）。通过微信的平台，转化建立了一个更加现代的销售渠道。 第二章案例：唯品会案例：小米 感想：就算是这两年的当红炸子鸡，也非常重视微信里面的服务接入。也是他们在玩更加大的社群。比起，之前见过那些号称微信营销专业公司来说。他们玩的更正道，更大。 第三章案例：泰康 感想：我妈貌似退休以后，闲不下来，去参加了什么保险业务。没记错的话就是泰康，我是没有耐心教我妈一点一点用微信的。但是她最近一次见我，在说泰康这个好科学，用微信就可以获得什么什么疾病金额。我想能覆盖到那么边疆的地区确实做的很牛逼。当互联网袭卷全行业的时候，保险这一大块必定是巨大的蛋糕。不过也不是随随便便能玩起的。玩不好就是跟那些P2P跑路金融一个样子了。 案例：汇添富 感想：微信是个好东西 案例：智能酒店 感想：跟北京的冯总在做类似的东西，但是比冯总那种东西要高级多了。另外他们都以为酒店里面可以做社交，怎么想都不可能。除非你是提供生理需求服务。要不谁会去认识住你隔壁昨天传出销魂声音的人。然后也都有一个点，就是说酒店里面的东西可以买回家。无可厚非，但是也只是一个客流量小到忽略不计的山寨宜家而已。反正我觉得不赚钱。 案例：美丽说 感想：绕不开的微信 第四章案例：武汉交管局 感想：天朝行政机关如果都这样搞，天朝人民的幸福指数会得到指数级别的增长。但是聪明人都知道这里不好弄，所以我们可预见的时间里面很难看到好事情的发生。 案例：王府井 感想：微信改变传统零售行业 第五章案例：海底捞 感想：海底捞无愧良心企业。目前没看到第二家。 案例：顺丰 感想：说完就打了自己的脸，顺丰就是第二家。有个事情其实挺好玩的，就是顺丰已开始有推送完整的路由节点过来。后面因为干扰用户太多自己改掉了。这跟张小龙的思维是一模一样的啊，其实我还挺喜欢那个功能的。 案例：蘑菇街 感想：有了美丽说，怎么能没有蘑菇街。而且当下这个时间点，美丽说和蘑菇街都合体了。 案例：深圳供电局 感想：跟上面交管局一样，其实互联网发展到今天。我们在一些基础功能服务上可以优化的地方太多太多了。稍微努力一点点，就能让我们在天朝的生活指数上升几个台阶 在微信里面观察到有趣的事情平台中诞生了新的平台在某一个时刻，我突然观察到一个有趣的现象。老的平台中会出现一个新的完全不一样的平台，然后在某个时刻点会有人跳出来说，新的平台即将替代老的平台。最近的例子就是张小龙说要出现应用号，又有各种分析家再说，iOS，Android等要死。以后一个微信就够了。这里我只关心其中有趣的部分，iOS 等作为移动互联网的基本平台，让所有的 App 能发挥其价值。而当出现了一个类似微信这种体量级别的 App 形成新的平台的时候，居然要代替他们了。如果这一天真的会发生，那 Apple 当初还会提供开放出来整个生态环境吗？那是不是在将来微信这样的平台里面也会诞生一个新的平台并且取代微信呢？ 我觉得这种思路想想就特别有趣。 当然新旧更替是正常的自然法则，应当抱有一个积极的态度去迎接技术和时代的变革。只是对于我这样一个念旧的人来说，断舍离还是说容易，做到其实很难。 为用户的利益为第一考虑要素其实类似的思想的说法有很多，“用户是上帝”，“用户说的都是对的”，等等。但是95%以上都在说说而已。我都觉得我都不必特别说明，大家都可以举出一大堆的例子出来。 而在张小龙最近在微信公开课里面演讲中，他明确的表示，希望在微信里面用户用完即走。我保守估计微信在手机上的使用时长绝对能排进中国移动互联网用户99%人里面的前三。但是微信的最高决策者却在思考怎么让用户用完即走。但全世界都在争留存，争打开率，争使用时长的时候。居然龙头老大是在做相反的事情，是以用户利益为导向的事情。 这时候，我就在想。是先做了以用户利益为导向的事情，才获得了龙头老大的江湖地位。还是以龙头老大的江湖地位，才想到了用户利益为重要。我想，微信在这里是前者。而天朝某些厂家是连后者都不是。他们信奉着以钱为导向，如果出现一些还不错的产品，那是副产品。不能算初心。 总结这本书告诉我们，用现代的方式提供有价值的产品，是会获得巨大的成功的。而这个现代的方式就是微信这样一个中国移动互联网最大的平台。作为一个产品，我应该去深刻的理解这个事情的价值。","link":"/2016/01/25/Read-Wechat-Thinking-Note/"},{"title":"调教Emacs(二)——更好 更强 更快","text":"更好 更强 更快上次的那些操作只能让你存活下来。 现在让我们感觉更好一些。 有时候，你可能按了一次C-c或者M-x。然后发现自己按错了。想消除这些命令这时候你可是使用 C-g 取消操作 如果你不确定你现在按没有按命令。你可以狂按几次C-g。 光标移动更好的光标移动C-a 行首 C-e 行尾 M-f 下一个单词 M-b 上一个单词 更快的光标移动M-m 移动到第一个非空格字符 (back-to-indentation) M-a 句子头 M-e 句子尾 M-{ 段落头 M-} 段落尾 C-v 下一页 M-v 上一页 M-&lt; 文件头 M-&gt; 文件尾 M-r 窗口中间 M-x goto-char RET N 文件的第 N 字节 M-x goto-line RET N 文件第 N 行 更强的光标移动C-M-a 到函数头 C-M-e 到函数尾 C-M-f 到下一个同级语法结构 C-M-b 到上一个同级语法结构 C-M-d 进入到下一级结构里 C-M-u 进入到上一级结构里 文档一般都有各种结构，比如LISP里有S表达式，C语言里的函数，LaTeX 里的 \\begin{…}…\\end{…} … 如果我们能够已文档的语法单位来移动，就会使操作非常高效。 defun。efun 在 LISP 里就是最高一级的 sexp，而在 C 语言里，它的含义就是函数。 C-M-a 到 defun 头C-M-e 到 defun 尾 这样，我们在C语言程序里可以一个函数一个函数的跳过。也可以从一个函数中间一下跳到函数开头或末尾。 语法单位(sexp)。语法单位在各种 major mode 有不同的定义： lisp-mode: 一个S表达式。 c-mode: 一个变量名，一个 (…), 一个 {…}, 一个 […], …所以在 Emacs 里，寻找匹配的括号可以在括号处使用 C-M-f 和 C-M-b. Gnus: 一个thread。包括所有的 Re:其实 defun 可以被看作最高一级的 sexp。所以范围小一点的移动操作就是在同级 sexp 之间移动。 C-M-f 到下一个同级语法结构C-M-b 到上一个同级语法结构 注意，这种移动不能越过语法结构的边界而进入上一级结构。所以，你如果在 1for (i=0; i&lt;10; i++) { ...} 的 for 循环的括号里向右移动，到达右边括号时，就会被提示到达边界。注意，文档中的注释在这两个操作中会被跳过，这是非常方便的。 进入和退出子结构: 在LISP中，S表达式是嵌套的括号，进入子结构就是进入到这一级 (…) 里面。而在 C 语言中，进入子结构就是进入 (…), {…}, […] 的里面。 C-M-d: 进入到下一级结构里。C-M-u: 进入到上一级结构里。 C-M-a, C-M-e, C-M-f, C-M-b, C-M-d, C-M-u 这几个命令组合起来可以迅速的在程序里移动。往往手可以按住 C-M 不放，所以还是很顺手的。 如果你还对光标移动欲罢不能，这里有高清大图让你慢慢把玩。 操作C-g 取消操作 C-space = C-@ 选择操作区 C-d 删除一个字符 M-d 删除一个单词 C-u xxx 多次命令 C-k 删除到尾 C-w 删除区域 M-w 复制区域 C-y 粘贴 M-0 C-y 向前剪切 M-z x 从光标删除到第一x C-s 搜索 C-r 逆向搜索 C-M-s 正则搜索 M-x replace-string 替换文本 其实不管是Emacs还是Vim。这些动作你都要在不断的使用中变成下意识的动作。这样，你在键盘上的效率就会越来越高。 随便说一句，推荐学Emacs的原因还有。在终端里面我用过的bash和zsh都是支持Emacs按键的。Mac OS里面所有的文本输入框也是部分支持Emacs的。虽然man等是支持vim的按键方式，可是我们不是还有info是Emacs的方式么。","link":"/2012/02/29/emacs-set-up-2/"},{"title":"调教Emacs(一)——存活","text":"序 一直以来，各界对编辑器的争论由来依旧。最后都会沦为Emacs vs Vim。这里就不在过多的讨论了。 不管是Emacs还是Vim都是需要一个长期的调教过程。才会让你用的很爽。如果你妄想今天安上他们，明天就变得像魔术师一样的按键。那你洗洗睡吧亲。明天去泡妞别做宅男了。它们会耗费你大量的时间，用那些时间说不定你都可以找一个妹子了。 在我学习使用Emacs的时候，入门资料相当少。有一些写的好的，却又各种Lisp配置。可是要了亲的命了。就想找一个先教我用的爽的，那些各种配置，各种文件能不能先放放。就只是先让我用的爽爽。 我提供了一些基本配置。几乎没有改里面的内容，但是可以用。可能用的不是很爽，但是基本的功能都有了。先用用心里有个谱。然后再去研究高深的使用。 我不会Lisp，所以这些配置最多算我这个工具仔拼凑起来的。 所以，看这系列Blog的亲们。 只要安装Emacs 23.3-23.4 (其他版本不知) 会git clone 知道~/目录 不需要会Lisp 就可以开始了。 安装首先确认你已经安装了Emacs。 然后备份你之前的配置文件 12mv ~/.emacs ~/emacs.conf.bakmv ~/.emacs.d ~/emacs.d.bak 然后clone我的配置 1git clone git://github.com/iiiyu/.emacs.d.git 然后你点开你的Emacs，如果他是这样的颜色并且下面没有提示报错的话。恭喜你。我们开始存活在Emacs中吧。 存活 启动Emacs 什么都别干 阅读Emacs Tutorial（它就再你启动Emacs的那个图片下面第一个，而且如果你的环境是中文的话，它应该是中文的） 科普键位 大写字母C == Ctrl 大写字母M == command（Mac）or alt（PC） C-c == 按住Ctrl不放 然后按c M-x == 按住command不放 然后按x C-x C-f == 按住Ctrl不放 然后按x（此时可以两个键位都放开）再按Ctrl不放 然后按f 小技巧：你可以按住Ctrl一直不放 分别按x键 f键 C-M-x == 按住Ctrl和command不放， 然后按x RET == 回车 高级键位：一般情况下，用Emacs或者Vim的人都会把右边的Ctrl键和Caps Lock键交换位置，这可以大大提高使用Emacs的按键舒适度。强烈建议交换。Mac os在系统设置里面有。Gnome在键盘设置里面也有。Windows据说可以改注册表和软件修改具体要自己google哈。我用的是KBC proker 40%的键盘，硬件就支持了交换。 幸存在Emacs 当你安装好一个编辑器后，你一定会想在其中输入点什么东西，然后看看这个编辑器是什么样子。但Emacs不是这样的，请按照下面的命令操作： 1234C-x C-f (会在Emacs的底部让你输入你想编辑的文件路径，输入完成以后，Emacs打开一个buffer，然后你就可以再里面尽情的输入文字了。)C-d 删除一个字符C-x C-s 保存文件C-x C-c 退出Emacs 123456推荐移动光标方法C-p 上一行 C-n 下一行C-f 下一个字符C-b 上一个字符(强例推荐使用其移动光标，但不必需) →你也可以使用光标键 (←↓↑→). 你能在Emacs幸存下来只需要上述的那8个命令，你就可以编辑文本了，你一定要把这些命令练成一种下意识的状态。恭喜你，你已经在Emacs里面存活了。","link":"/2012/02/26/emacs-set-up-1/"},{"title":"调教Emacs(三)——完结篇","text":"调教Emacs(完结篇)Buffer我記得剛開始用emacs，每次都被buffer嚇到：buffer, buffer，怎麼到處都是buffer？那我要怎麼編檔案（file）？ 其實概略的說，buffer就是file。所以呢，每次看到buffer，你就想是file。那用我們平日的概念，就可以明白了。叫buffer更精確。為什麼呢？比方說你用XX文書處理，我們都用New去建一個新檔，還沒存的時候就叫什麼「未命名的檔案」之類的。其實，還沒存，硬碟都還沒紀錄下來，怎麼能叫檔案？所以，emacs叫buffer。 再深入一點，buffer的名字和檔案通常一樣，但也可以不一樣。還有呢，emacs的buffer可以有很多模式，有些buffer還真的不準備變成檔案的。 因此呢，buffer的函意比檔案廣。不過我們初學，就把buffer當檔案好了。 来自 buffer的快捷键C-x b 切换buffer（要输入buffer名字） C-x 方向键也可以切换buffer C-x C-w 保存buffer（也可以看做是另存为） C-x l : 显示文件(buffer)总行数 C-x 1 : 当前窗口最大化 C-x 2 : 上下两窗口模式 C-x 3 : 左右两窗口模式 C-x 0 : 关闭当前窗口(Buffer仍然存在) C-x o : 切换窗口 mode什么是mode当我们启动某一文件时，Emacs会判断文件的类型，从而自动选择相应的模式。当然，我们也可以手动启动各种模式。先按M-x，然后输入模式的名称。 mode有什么好处mode的好处是不同的mode里面有不同的功能，比如“C模式”里面的源码可以高亮，可以缩进。org-mode里面可以分层等。不同的mode对于不同的文件类型做出正确的操作。这就用着很爽了嘛。 怎样启动mode一般来说Emacs是根据你的文件后缀名来判断你的文件类型，进而自动启动相应的模式。比如.py就启动python-mode，.c就启动c-mode等。如果你想自己启动某一模式：比如启动“C模式”，就是M-x c-mode。直接按下M-x，然后按两下Tab键，你将得到所有可执行的命令，这里面当然包括所有的模式。因此，你要想不起来某个命令的名称，就用这个方法。如果是perl就是， M-x perl-mode或者是M-x cperl-mode 块操作emacs以C-x r开头的命令来进行矩形操作。先用C-space或者C-@设一个mark，移动光标到另一点，用以下命令进行列操作： C-x r k 剪切一个矩形块 C-x r y 粘贴一个矩形块 C-x r o 插入一个矩形块 C-x r c 清除一个矩形块(使其变成空白) C-x r t 在选定区域的所有列前插入样的字符 鼠标操作按住鼠标左键移动 -- 标记文本块 鼠标右键单击 -- 将标记的文本块复制到剪贴板 鼠标左键双击 -- 标记单词 鼠标左键三击 -- 标记行 cua-modecua-mode支持的可视化块模式 除了emacs本身支持的列模式外，emacs还可以通过cua-mode支持一种可视化的列模式。在cua-mode下，按[C-return]会进入cua rectangle模式。在这个模式下可以通过鼠标点击确认起点，然后通过光标键来选中一个rect范围，这个rect会用另外的颜色显示出来。 之后我们 就可以很方便地对这个rect进行操作。比如[M-up],[M-down],[M-left],[M-right]可以移动这个rect，[C- return]可以取消这个rect，[C-space]可以退出cua-rect模式并激活普通模式下的选择。cua-mode下可以用以下命令进行列操作： 直接输入字符: 在每行前(或后)都插入这个字符 [M-a]: 将rect中的文字左对齐 [M-b]: 用空格(tabs或者spaces)替换所有rect中的字符 [M-c]: 去掉所有行左侧的空格 [M-f]: 用单个字符替换所有rect中的字符(提示输入一个字符) [M-i]: 对每行中第一个找到的数字进行加1操作(自动把0x开头的当作十六进制数字) [M-k]: 剪切rect [M-l]: 把rect中的内容全部转换为小写 [M-m]: 拷贝rect [M-n]: 用一串自增的数字替换rect中的每一行(这个功能可以用来给每行编号) [M-o]: rect的内容右移，选中的rect用空格填充 [M-r]: 用字符串替换符满足正则表达式的字符串 [M-R]: 上下反转 [M-s]: 把rect中的每一行替换为一个字符串(提示输入) [M-t]: 把rect整个替换为一个字符串(提示输入) [M-u]: 把rect中的内容全部转换为大写 [M-|]: 对rect执行一个shell命令 我的配置的Emacs的独有功能说是独有功能其实也是很多配置文件拼凑起来的。只是之前介绍的都是emacs默认的东西。下面的功能对于大神来说都是很常见，我只是绑定了几个快捷键或者记录了几个常用的快捷键而已怎样用我的配置的Emacs， 看这里 tabbar-mode 看到上面图上面那一排像标签页的东西了么，这个就是tabbar-mode的效果。启动配置了我的配置Emacs就默认启动了。这些像标签的东西都是buffer。 tabbar-mode切换buffer快捷键M-n 下一个buffer M-p 上一个buffer ecb-active 哈哈有点IDE的感觉吧。 启动ecb先打开一个你的源文件。然后 M-x ecb-activate 就启动ecb了 使用ecb的好处是你可以在左边的第一个小窗口选择文件夹，第二个小窗口选择文件，第三个小窗口选择当前文件里面的函数，第四个小窗口选择你打开过的文件。 python-mode只说一个 执行当前文件按 C-c C-c 有个bug，执行的python是Emacs启动的，如果python文件里面有中文，那在Emacs启动的这个python线程下执行会报错。编码问题，但是没有找到解决的方法。 c-mode or cc-mode该模式下，tab被我替换成空格，一个tab设置为4个空格，缩进也是4个空格。 整理代码有一个比较常用的就是格式整理代码可以选择部分代码整理，也可以整理全部代码。这样你的代码缩进就会非常漂亮了。 C-M-\\ 整理代码 跳入函数但我们查看某个函数想知道它实现的地方的时候 C-M-0 跳到函数实现的地方 C-M-9 跳回来 高亮这个高亮功能大爱 看见这些花花绿绿没有，相同的函数或者变量是同一个颜色。非常好区分。使用方法非常简单 C-f3 第一次标记颜色，第二次取消 f3 查找相同的下一个 快捷键补遗S-方向键 可以在不同的窗口切换 完结语零零碎碎，我把能一次想到的都一股脑的全部写完了。当然不可能面面俱到，比如强大如org-mode只字未提。而且大部份都是快捷键的说明而已。本来开始打算写调教Emacs系列能写十几篇。但个人思想上发生了一些变化，所以可能以后Emacs不会是主力编辑器了。 不过也指不定那天抽风的有写出调教Emacs第二季强势归来 写了两小篇在blog上挂着也不是事啊。就像写小说写了太监一样，不舒服。所以还是来完结一下。有始有终。做一个真男人。:)","link":"/2012/03/14/emacs-set-up-3/"},{"title":"iOS笔记导航","text":"iOS笔记导航说明发现我的笔记是越来越多了(混蛋，才10几篇而已这种能叫多)XD. 查看起来不是很方便。所以，我预见性的写一篇blog来导航一下。方便大家(其实是自己吧，混蛋)查看。 编程基础iOS笔记1 关于MVC的定义和 Objective-C语法的简单介绍。 iOS笔记2 简单的说了一些一开始写iOS的感悟。关于MVC ARC和strong、weak iOS笔记12 Block简单使用 iOS笔记17 iOS读写文件 基本控件iOS笔记4 九宫解锁基础部分 iOS笔记5 ViewController的生命周期 iOS笔记7 Core Location定位 iOS笔记13 UIViewController的一些事儿 设计模式iOS笔记10 关于回调函数——Delegate的那些事 iOS笔记11 关于Target-Action设计模式 网络断点续传iOS笔记6 利用ASIHTTPRequest做断点续传 iOS笔记8 基于MKNetworkKit的断点续传 工具iOS笔记3 关于git的一些链接和xCode的快捷键 iOS笔记9 xCode4 配色主题 iOS笔记14 使用CocoaPods iOS笔记15 Mogenerator的初级使用 iOS笔记16 配置自己的CocoaPods库 Core DataiOS笔记18 Core Data 一 iOS笔记19 Core Data 二","link":"/2012/10/25/ios-notes-navigation/"},{"title":"优秀的设计 vs 糟糕的设计","text":"这篇blog缘由这张图片 然后我转发了一下这里可以围观。 然后 有几个人评论了一下。觉得我像一2b青年一样乱说。现在却找不到那几个评论了。不过后来我看了看，我写的这条微薄确实就是2b青年的评论的范。为表示深深的歉意,我决定写这篇blog来阐述一下我的观点。 关于坚果云在天朝这样的环境里面,做云存储的。我试用了各家国产货以后就觉得就坚果云靠谱。so可能觉得靠谱公司就应该有更理智的判断更有梦想的想法。所以如果那个微博是以个人名义发的，ok。可能我也不会去说什么。但是一个公众的号说这样的想法出来的时候。我第一个感觉是哎。我心目中国的Dropbox也就这样了。有点失望的意味在里面。然后有感而发的发了这个微博。 声明以下观点仅仅代表个人想法，完全没有任何恶意。如果表达出了感觉不适的内容，你可以联系告诉我。我来修改。我并不想伤害任何人。(接着写的时候，我突然觉得可能会写偏离。先声明一下) 第一个失望点“标准答案都来自外国人。真的什么事情都要迷信极简设计吗？”。 首先关于外国，我觉得我很肯定的是,我在天朝这24年来所能学到的现代科学、思考方式。几乎都是来自国外的。套用蒋教授的一句话”一切来自西方”。除了那依稀记得的那几句诗词。我觉得我拥有知识的大部分都来自国外。长大以后，我已经很少去YY什么上下五千年了。我们活着的是当下，而不是YY。 然后关于标准答案。我觉得任何地方都没有什么标准答案。只是在说一个优秀的设计和糟糕的设计。 然后关于迷信极简设计。同上。依然我觉得只是一个优秀的设计和糟糕的设计。 这句话还会让我想到，”不顶就不是天朝人类似的口号之类。” 很能戳中某些人的G点。 现在的世界上一流的生产力第一次诞生大部分来自国外,这是事实。所以,有优秀的设计来自于国外,这也是事实。而且很正常。当然都来自国外不是绝对的事情，前两天某宝抗下了我觉得可能是世上最nb的24小时各种数据。就是证明。可是这样的例子能在天朝举出来的次数少的一只手就能数得清。所以，一个好的行业标准。一个优秀的东西。首先出现在国外是一个很正常的事情。退回来说这图上的两个遥控器的设计。怎么才是好的设计。跟来自国外无关，跟极简设计无关 第二个失望点“咱们中国老百姓用了十几年的电视遥控器都长右边的样子。看看楼下的回复，让你更了解中国的用户，而不是老外~” 勤劳善良的天朝人民因为习惯就不能用更好更方便的设计了么。 再说，你口中的老外也用过十几年右边这样的吧。为啥人家有能用上左边的遥控了。老外十几年的习惯怎么就可以一下改变了呢？顺着这个说一句盗版，天朝内很多人觉得用盗版是理所应当因为在天朝。天朝国情就这样。国情呵呵。人家是人，你就不是人了么。什么都找个借口,还冠冕堂皇的样子。自己把自己当人看,才是应该做的事情。 再来说说我认为的优秀的设计在我的理念里面作为一个用户，第一条也是最后一条。优秀的设计就是用起来爽的设计。跟其他什么设计分类，设计风格，设计派别半分关系都没有。只要它用起来爽。怎么让这个物件用起来爽。不是我考虑的事情。这是设计师要考虑的问题。 参考视频 优秀的设计都在努力提供用的更爽的感觉。就拿iPhone来说。因为简单明了。 回到iPhone。iPhone出来之前。所谓的标准答案是不是诺基亚那种设计，上面屏幕下面按键的样子。这个标准答案也用了好久了吧。替换成跟开篇类似的图就像这个样子 额，偷懒。用tinyfool的观点来说为啥iPhone的设计是好的,因为iPhone它用着很爽。所以才是一个优秀的设计。而不是去附和狗屁达达的诺基亚很久的用户习惯。而天朝总有人认为用iPhone是装。我觉得这种肯定是存在的,我不否认。但是我听过很多很多说用过iPhone就回不去的例子。可能第一部iPhone有装的原因，可是之后他捡到了一个大便宜。因为他肯定会用的很爽。而天朝的iOS根据上次我看友盟的数据是有6000w个设备的。(如果觉得我记错了，可以翻翻友盟的官方微薄) 6000w个设备。是因为它真的很好用。 遥控器回到遥控器来。其实我觉得两个东西放到一起对比是不公平的。因为明显apple tv的遥控器是已经超越了右边遥控器一个时代的东西。而在这种情况下,还跳出来说右边设计的更好。额，真心有点不知从何说起的感觉。 而且, apple tv的遥控器还有一个相对应的经过精心打造的系统来配合使用。右边的遥控器能配合的有什么咯。自己点开机顶盒自带的那个menu来看看。而且,我保证那个全部是按钮的遥控器。有一半以上的按键你按到它是因为你按错了。而且你也不知道一个莫名其妙的图标到底代表的是什么意思。(好，写完这段以后我特意回到最上面看了看图。右边那个有中文标识。但是思考了一下，我决定保留这段。) 而且这两个真心不是一个时代的东西了。他们的应用场景也是完全不同的。apple tv的内容是精确定位的。意味着你找到的内容你停留的时间会比较长。而传统电视内容是模糊的，我们会在不同的电视台之间快速的切换。我们不知道下一个是什么。我们会看什么。看到这里会不会又有人出来说，“你看你自己都说右边的符合它的应用场景那它也是一个好的设计。”错！ 好的设计是用的更爽的，apple tv能让我们选择自己感兴趣的内容观看。而传统的电视只能逆来顺受的看。能遇到想看的固然好。可是你能每次都遇到么。我们有没有过从第一个台换到最后。又回到第一个台还是没有找到想看的东西的情况呢。显然，在这里。apple tv的设计已经超越了传统的电视。让用户可以用的更爽。 写到这里，我的讨论已经超越了单单的一个遥控器。可是确实要把遥控器和他们所依赖的系统精密的联合在了一起。如果单独的去看他们其实是盲人摸象。所以，我想我能尽量的看的全面一些。 总结写了这么多。无非我就是想证明一点。我的观点没有错而已。其实我更想证明的是开头第一张图左边的系统比右边的系统不仅仅是设计优秀的问题。而是已经领先了一个时代的问题。其实很多时候，我是不太想争论的。因为我本身也没有做成什么好的东西来。怕有一天也变成”xx评论家”–说是天下无敌，打是无能为力。 至此，谢谢观看。","link":"/2012/11/18/excellent-design-vs-baddesign/"},{"title":"怎样搭建一个Octopress","text":"其实我就是上来放几个链接的. 安装点这里 安装某个主题这里 增加关于我 增加评论 写blog用到的Markdown语法 添加高亮代码语法 然后我备注一些。首先你要有一个ruby环境。git环境。类unix环境。那你的搭建过程就是几个命令。在windows下的话，我师兄遇到了编码的问题。应该是ruby在windows下的各种莫名错误。不过大神的他还是搞定了。你可以去他的里面留言问他怎么搞定的。","link":"/2012/02/07/how-to-install-octopress-on-heroku/"},{"title":"iCloud 和 iCloud Drive","text":"本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 开篇扯淡 好久没有写 blog 了。 最近发现很多人对 iCloud 和 iCloud Drive 有些误解。而还没有看见中文里面有一个比较正确的说法。 加上近两年来工作就是在学习 iCloud 如何使用。最近一个月做客服小弟回复了 N 个 iCloud 的问题。所以感觉还是有一些价值的。特意想记录一下。 是否升级到 iCloud Drive在 iOS 8 刚刚上线的时候，用户更新了以后。第一次会跳出来，说需要重新升级的 iCloud Drive。因为没有更多的信息和提示，我想一个正常的用户应该都会去点击升级。结果就是导致很多使用 iCloud 这个功能的 App 数据出现问题。或者导致了设备之间的不同步。那会有很多文章在建议不要升级 iCloud Drive。所以可能会给后来升级到 iOS 8 的用户造成一定的心里作用说升级 iCloud Drive 是不可靠的。 其实根据我两年来 iCloud 的经验和测试结果。 iOS 8 的 iCloud Drive 是一个 Apple 云端的一次最重要的里程碑。 是 iCloud 这个技术在 Apple 产品系列上第一次做到了可用的状态。等了三年终于有个云的模样了。 当时不建议升级 iCloud Drive 的理由其实就两个： 对于开发者来说，由于 Apple 为了保密 iPhone 6 和 iPhone 6 Plus。 其实在9月发布会之前。 iOS 8 的 最后两个 Beta 版本是没有提供给开发者的。在能获得的最后的 Beta 版本上。 开发者使用 iCloud 依然各种莫名其妙的问题。一直到 GM 版本才变得正常。这样导致 GM 到发布正式的版本之间的时间。大部分开发者还无法把更新 iCloud 的技术及时的完善在自己的 App 里面。 另外一个是在 iOS 8 已经放出来的时候，OS X 10.10 还没有放出来。这样如果你是一个 Apple 一套的普通用户。就会导致你一些全平台使用 iCloud 技术的 App无法相互同步。所以在当时确实这样情况的普通用户应该谨慎更新。 现在11月了这两个问题随着开发者对 App 的完善和 OS X 10.10 释出。其实都不是问题了。大家可以放心大胆的升级了。 iCloud 升级到 iCloud Drive 具体是做了什么事情首先需要明确的是，iCloud 升级到 iCloud Drive。只跟你的 Apple ID 相关。并且这个过程不可以逆转。 普通用户对于普通用户来说应当就是一次在服务端的数据迁移。把之前的存储在 iCloud 服务器上的全部数据迁移到了 iCloud Drive 的服务器。从此以后你的 iCloud 数据都是从 iCloud Drive 服务器上读取了。 基于这种逻辑支持 iCloud 的应用，理论上 100% 可以使用 iCloud Drive。 但是事实上并不是所有的应用在升级了 iCloud Drive 以后都可以使用。 Why？ 先解释一个现象，就是在一开始升级了 iOS 8 然后升级了 iCloud Drive 立马就打开了某 App 发现 iCloud 的数据没了。 结果睡觉起来再打开就有了。这种的原因很简单，就是 iCloud 服务器上的数据迁移到 iCloud Drive 服务器上是需要拷贝时间的。数据还没有迁移完成的时候你打开当然没有。等到数据迁移完成了，你再打开它就有数据了。 开发者PS：普通用户可以略过此小结这次 iOS 8 的升级，一开始就是对使用 iCloud 开发者的一次噩梦。 iCloud 服务器数据到 iCloud Drive 服务器数据的迁移。 客户端下面 iCloud 的 Container ID 发生变化。之前是 Term ID.xxxx。现在是 iCloud.xxxx。当然已经上架的应用的 Container ID 是还存在的。但是这个变化从来就没有在文档里面提过（可能现在有了，反正当时没有看见过）导致的结果就是如果容器空间没有选择正确。必然读取不到老数据。 由于 iOS 8 升级需要很大的空间，有部分用户可能是选择重新安装一个新 iOS 8 或者是入了一台新的手机。 但是没有升级 iCloud Drive。这种情况下，会导致 App 无法找到 iCloud 的路径。也是坑的不行 目前能回忆起来比较坑的就这两个，这些都是开发者必须处理的情况。如果开发者花费巨大的力气处理好了，用户其实是感受不到的。这是最好的情况。如果技术不过关，处理不好。用户就上门开始骂了。（PS：这是一个悲伤的故事） CloudKitCloudKit 是今年提出来的新技术。 普通用户使用这个技术的 App 都是靠谱的 开发者简单说来就是一个 Apple 版本的 Parse。具体去看文档不展开说明了。 一些存储路径的说明iOSiOS 由于沙箱的原因。其实普通用户看不见什么。不过可以肯定的是。在系统路径下面。 iOS 是有 iCloud 数据的缓存目录进行数据缓存的。简单说来就是使用 iCloud 的应用在删除的时候。 iCloud 缓存里面的数据是不会立马删除的。什么时候清空，未知。 OS XOS X 可以看见的就比较多了。 Finder 里面的 iCloud Drive这里其实由两个部分组成： 是 /Library/Mobile Documents/comappleCloudDocs 是使用 iCloud 技术把一些数据文件存储到了自己 iCloud 容器路径下的 Documents 目录里面。 把 Finder 里面这个 iCloud Drive 当作 Dropbox （网盘）使用。那你丢进去的文件数据都是在1`/Library/Mobile Documents/comappleCloudDocs `这里路径下面。 而你为什么可以看见一些 App 名字的文件夹呢。就是第二个部分容器自己的 Documents 目录。你可能会问为啥不是全部使用 iCloud 技术的都有这个目录呢？ 我来举例说明把在 Apple 生态里面。商店里面的程序都是沙盒的。相互之间都是独立的。不过有一个地方是可以看到沙盒内部，在开发文档里面也是同样描述那就是 Documents 的路径。举例一个 iOS App 如果你在Documents 下面有文件，那你在 iTunes App 的那页下面是可以看到这些文件。同样的概念延续到了 iCloud 上。当 App 的文件存于他自己 iCloud 路径下的 Documents 文件夹下面的时候。你就可以在 Finder 中 iCloud Drive看到。App iCloud 容器下另外的路径是不会显示到 Finder 下面的时候，所以并不是使用了 iCloud 的应用都在这里有文件夹。这些都取决于开发商对自己 App 的设计和实现。 /Library/Mobile Documents这个路径下就是 iCloud 数据在 OS X 的缓存路径。理论上来说，这个路径下是跟 iCloud Drive 服务器上的数据同步的。（没升级 iCloud Drive 就是跟 iCloud 服务器上的数据同步的） /Library/Caches/CloudKitCloudKit 的缓存路径 总结毫不谦虚的说，本文虽然条例不是清晰。但是是目前中文说明里面对这次 iCloud 变更目前位置最详细的解释。（PS：看在写到凌晨n点的情况下。做自己吹一下） 一定要升级 iCloud Drive，这样对大家都好。用户可以得到更好的体验。开发者可以使用新的技术做出更加好玩的东西出来。 能使用 iCloud 技术的厂家都不容易。请善待他们。 我是一个 iCloud 黑。","link":"/2014/10/20/iCloud-and-iCloud-Drive/"},{"title":"一月读书笔记","text":"一月读书笔记 疯狂的周末。拿起积灰的kindle，看完了2本书。在信哥的推荐下，用了两天看完了《天才在左，疯子在右》。看的是天涯的整理版。知道是最初发在天涯鬼话的。有宣传说是真实的案例，看豆瓣书评说很假。仁者见仁智者见智吧。之所以很快看完了。是因为引起了我深深的共鸣。里面说的案例除了两个杀人的精神病的想法看着很恶心恐怖。其他的案例我都能看懂，更有的想法我也曾经想过。里面有一个说法，就是说这些沉浸在自己世界里面的人们，都有一套自己完美的逻辑，而且无法反驳。疯了的可能是我，也可能是世界。这个书不错，当做恐怖小说看吧。 桃花坞里桃花庵，桃花庵下桃花仙。桃花仙人种桃树，又摘桃花换酒钱。酒醒只在花前坐，酒醉还来花下眠。半醉半醒日复日，花落花开年复年。但愿老死花酒间，不愿鞠躬车马前。车尘马足显者事，酒盏花枝隐士缘。若将显者比隐士，一在平地一在天。若将花酒比车马，彼何碌碌我何闲。别人笑我太疯癫，我笑他人看不穿。不见五陵豪杰墓，无花无酒锄作田。——唐寅 前几天珂姐才说过我，想的太透彻了。自我反省了一下，觉得确实如此。有过出家and云游四海的念头。其实人生不过匆匆几十年，何苦呢。看了大概10%的《西藏生死书》神书，才看10%我就觉得我要开始信仰密宗了。宗教其实是一个好东西，因为他里面有无数有智慧的人思考过人生终极问题——生死。如果小时候我有宗教信仰的话我就不会去需找人活着是为什么这种哲学上的问题。困惑的时间会少很多，进而可能有时间多看看其他的书。可能就不搞IT这种苦逼的工作了。 最后，萌小萌 sorry。。。我看完了《那些年，我们一起追过的女孩》。不是电影是小说。我确实想起了我曾经喜欢过的女孩，我大大方方的承认。这样还可以营造出一种我是君子坦荡啊的形象。。。我真他妹的耿直。可是我知道有些时候，其实是一些小事情的，但是相互隐瞒，最终就会导致问题的爆发。所以，很多事情我都跟你说哦。可能你会生气个小几天。可是，着以后就不会变成大问题了啊。而且你知道我是一个怎样的人啊。 最后。。。计划一月2本书再半月的时候是完成了。 可是计划中的《什么是数学》却还么有看。。。是不是老了不中用了，感觉白天上班的时候学搞linux，晚上回来搞ios。脑子有些转不过弯来。跟用一386的cpu要开多线程并且要并行一样。那不是直接不支持么，硬上的话，肯定不支持。结果是男人多自己狠一些，就只能上水冷加个100伏特的电压了么。这样的结果就是，觉得神经再崩溃的边缘一触即发。索性年关将至。哎。。还有3天就回家了。希望blog不断更。 PS：最近几篇自己写的文章都逻辑很差，一是很久没有系统的写过什么。二是没精力去把他理通啊。 推荐 《那些年，我们一起追过的女孩》 《西藏生死书》 《天才在左，疯子在右》","link":"/2012/02/26/january-reading-notea/"},{"title":"2013 一月读书笔记","text":"#2013 一月读书笔记 2013的一月嗖一下就过去了，都还没有反应过来，在过几天就回家过年了果然时间入流水阿。 看看之前的blog，上一篇也是唯一的一篇读书笔记刚刚好是2012的。随带检讨一下自己的懒惰。 之前用的Octopress，不知为什么我手贱update了一下就各种错误。搞了两天也不明白问题在哪里。 那会还有写点东西的冲动。给我急的阿。后来想起在@Lucifrblog里面见过一个类似的框架，跟过去看了看。原来是之前见过的台湾小朋友写的Octopress主题Slash的作者@tommy351新项目Hexo。果然自古英雄出少年阿。感谢@tommy351的Hexo。 现在我的blog生产静态html的框架用的是Hexo 强烈推荐。 一月我以极快的速度翻完了三本书。 「打造Facebook」 「看见」 「全世界人民都知道」 打造Facebook这本书我购入多看电子版。起初我看这本书很多人在推荐。就想入了一本。点到书的内容介绍里面一看。各种李开复、薛蛮子联袂推荐。顿时拉入黑名单中。结果微博上几个靠谱的人还在推荐。曹哥也说已经看了一半感觉还好的情况下。就入了电子版。(PS:貌似那会儿在特价) 通篇读下来就是个人打工体会。 干货确实有。但是也无法重现Facebook不是么 推荐指数 3星 看见CCTV里面我待见的主持人不多(ps:已经多少年没有看过CCTV的人了，浑氮。你能待见谁)。女主持更不多了。 印象中就两一个是柴静，另外一个连名字都不知道就记得带一个眼睛播报过天气预报笑容甜美的妹子。看过柴静节目里面的内容都忘记差不多了，记忆里面就知道她坐着一个问题一个问题问对面的人。虽然感觉上咄咄逼人的样子，可是反而感觉是一个有自己独立思考和智慧的人。这样的人我看着顺眼。本来预售的时候就想买了，但是我想买电子版。还在微博上问了多看官方帐号。然后他们的副总说这本书有难度，才去亚马逊上下单。（PS：昨天躺在床上翻多看发现有「看见」的试读版本了。这是什么情况） 「看见」的封面我觉得很好，柴静微笑的坐在一群朴实的天朝公民中，笑容清澈见底，旁边有老人和孩子。这书名根据内容看下来也感觉很好。因为都是柴静的亲眼所见。从这本书里面，我隐约看见某腐朽的帝国主义的某电视剧「The Newsroom」的样子。让我感慨出来CCTV也是有一群有良知的人儿阿。这本书其实算柴静的一个小自传 or 十年的工作史。如果我给起名字的话——「给黑心矿老板CCTV打工的血泪史」。希望寄托一个开心的名字能冲淡一些书中的悲伤。 看见是一本好书因为里面写了人性和理性。 推荐指数 5星 全世界人民都知道本来应该跟看见一起买的，结果下单的时候忘记了。后来为了凑够免邮费。又搞了一本韩寒的什么书。(什么书还真忘记了。没看的欲望) 本来我以为今年看过最好的中文非技术书应该是「看见」了。「全世界人民都知道」带给我的比「看见」更多。很早认识李承鹏是写足球的。后来多少看过一些他的事，微博什么。实在觉得是一个好人。一直到这本书发售的各种事情。都暗示着这人肯定很靠谱。那书应该也不差。而且有这么欢乐的发售会。肯定会买一本过来看看。 里面写了他为什么要转变的原因。里面写的事情，我都有过想法。但是他写的更加直白深刻，却又那么容易看懂。我只用了几个小时就全部扫完。有种酣畅淋漓的感觉。 推荐指数 5+星 总结我看来 三本书都是写人。 「打造Facebook」说做互联网，最重要的是人。只有一流的人才能做出一流的产品出来。所以Facebook只找最好的人。 「看见」说的是个人。以柴静的眼，人性的眼去看待这个世界。 「全世界人民都知道」还是说的是人。人构成了这个世界，而这个世界有问题了。最后反射到具体的每一个人身上。«","link":"/2013/02/02/january-reading-noteb/"},{"title":"学习UI设计笔记(一)","text":"本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 开篇扯淡那啥， 我知道NSDate的坑没有搞定。缓缓，缓缓。我在开个新坑来着。恩恩这个坑就是记录一下怎么学习Sketch 这个软件的。 首先，我买了本更优秀的APP-31个APP用户界面设计经典案例。 高手勿喷，这种图文并茂，手把手的交比较适合我这种菜鸟。 这本书的唯一好处是他的例子是Ai的。而Sketch也是矢量图。所以我以为会有些类似的操作。（其实根本是两个软件啊！！！！） 然后我准备把他说的31个例子都用Sketch来模仿一边。恩，先把Sketch的大部分功能运用熟练再说（就是花了小几百不想让他吃灰而已） Sketch资料官网 Sketch的资料其实并不是很多，原因之一是能熟练使用Adobe一套的大家（除了我）都能很快的入手。所以像我这样完全没有用过Photoshop的人在贵圈是一种奇葩。 所以中文资料就特别特别不多，不多的意思是图灵社区的某个大神把操作手册翻译了一下 Sketch中文手册 在没有发布的时候我就知道了，我满怀憧憬的等待这本书的上线。结果，嗯嗯很不错的一本使用手册。 洋文资料最多的就是MengTo大神的 大神blog 而且大神最近在预发售一本design+code。现在购买打5折哦。(免费为大神打个广告) 官方视频都在Vimeo上自带神器 iOS Design using Sketch. Part one: iOS Navigation Bar iOS Design using Sketch. Part two: iOS Toolbar 对了，据可靠小道消息，这货的3.0要发布了。又是一次交钱的时刻。穷死了。 Github地址咱程序员就要有程序员的范，每次的Sketch我都会丢到这个地址上，如果需要下源文件研究一下的同学知道去哪里找了把。 learn-ui-design 鉴于最近的网络情况，自带神器。 大幅大幅的贴图0 恩，按照教程，我手绘了一张图片，然后用手机拍照了放到Sketch里面。 1 拖了一个椭圆，然后选中铅笔工具，描绘了一下那个小尾巴。 2 选中他们两个，进行Union操作。 3 拖一个正方形出来 4 正方形旋转45度 5 在正方形上双击会出现可以编辑的关键点 6 删除掉最右边的关键点，变成一个三角形 7 把气泡弄出来看一下整体效果 8 随便上个颜色试试 9 最终版本，我尽力了。 总结恩，2014年的一个要努力的目标就是把自己的品味搞上去。恩呢，加油。","link":"/2014/03/25/learn-ui-design-one/"},{"title":"怎样使用Sketch 3切图 —— 从想入设计大门的菜逼进化到切图仔（未完成）","text":"本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 本文未完成懒得屏蔽了 开篇扯淡Sketch 3发布了，而且在国内设计圈产生了一阵不小的影响。（好吧，我承认我混的不是这个圈子）作为一个拥有Sketch 2的老用户来说。这颗闪亮的钻石本来只我才知道他的好。就像小时候发现了一个出租激情小电影的小店铺，突然某一天冒出来一堆人也来租。那种小秘密被打破莫名的失落感。 好吧，其实这个是一个好事情。用的人多了，素材也会多。教程也会多。 顺便一提Sketch 3的发布之前MengTo大神的Design Code新书也在不断更新中。严重怀疑是商量好一起来坑钱包的。 配合的这么天衣无缝。在Sketch 3还没有正式发布的时候，MengTo大神更新的视频就是用的Sketch 3 beta版本。弄的我还以为我的Sketch 2是不是打开姿势不正确。 写这篇的原型是因为看到weibo上有小朋友，居然用我大切图神器Sketch的姿势不对。所以虽然不是什么高级的功能。但是鉴于跟我一样徘徊在设计大门的朋友还是很多，我就记录一下。 在没有Sketch之前，设计师给过来的素材都是psd的。作为一个有节操的少年，虽然我拥有CS4的教育版本，但是我还是会用Pixelmator去切图。（PS：主要是不会使用PS！）不过由于兼容性的问题Pixelmator切图会丢失psd的一些图层效果。所以后来一直是设计师把图给切好了在给过来。（明明是想办法偷懒！！） 不过后来，有了Sketch这货，我也就开始自己尝试切图。而且Sketch可以直接切出1x和2x。莫名的快感。（不要说PS有插件能做这个事情。我真不会和买不起PS） 崭新的Sketch 3新切图功能虽然Sketch 2中切图可以导出1x和2x。可是很多时候还是感觉切图不方便。主要是因为Slice在更加深的一层。如果画布上的图有更新和变动。Slice需要一起更新的话还要点过去。但是一般情况下，只有需要切图的时候才要点过去。导致每次需要调整Slice的位置和大小很不爽快。而且Slice的命名也需要多余的点击去修改。 这些问题在Sketch 3里面都得到了改进！ 把Slice提到最外面，做为设计的同一个层级。 Slice虽然现在是一等公民，可是有可以选择显示or不显示。相当方便。 更加智能的认出要切的部分。 切图技能进化小结","link":"/2014/04/23/learn-ui-design-two/"},{"title":"iOS笔记 (11)","text":"关于Target-Action设计模式序上回提到了在iOS的MVC中。delegate其实是一种View跟Controller直接交流的方式。 这次我们来说Target Action这种View跟Controller的交流方法。 什么是selector官方解释请看这里 在Objective-C里面, selector有两种意思: 当用源码向一个对象发送消息的时候,表示简单的方法名字。 作为一个方法的唯一标识符去替换源码编译的时候的方法。 突然觉得我再怎么写也没有官方文档写的好。那就看文档把。 总结几个我理解以后的要点 SEL是一种类型，跟int float一样。 @selector 其实就是取得一个SEL。 12345678SEL press;press = @selector(pressed:);UIButton* btn = [UIButton alloc]init];[btn addTarget:self action:press forControlEvents:UIControlEventTouchUpInside];-(void)pressed:(id)sender{ .....} @selector()取得的其实一个ASCII的方法名字符串 我们可以通过performSelector:, performSelector:withObject:, performSelector:withObject:withObject: 这三个方法去调用selector 123id helper = getTheReceiver();SEL request = getTheSelector();[helper performSelector:request]; 什么是Target-Action设计模式官方解释在这里target-action是个设计模式。对象保持必要的信息，当事件发生的时候发送消息给其他对象。所保持的信息有两部分数据组成： action selector，定义要调用的方法名称标识； target，接收消息的对象。 当被称作action message的事件发生，将向target发送action selector定义的方法消息。 target-action模式一般用于自定义的controller按照应用规范定义的方式处理action message。 怎么用Target-ActionUIButton用法在iOS里面有些控件是继承UIControl这个类的。比如UIButton,理论上只要继承这个UIControl这个类的子类都可以用Target-Action。 1- (void)addTarget:(id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents UIControl的子类都可以覆盖这个方法，来调用自己的事件对应的函数。 12345678UIButton *btn = [UIButton buttonWithType:UIButtonTypeInfoLight];[btn addTarget:self action:@selector(method:) forControlEvents:UIControlEventTouchUpInside];[view addSubview:btn];- (void)method:(id)sender{// do something} 解释一下addTarget:self。就是把要去哪里查找实现方法的目标。action:@selector(method:)就是把动作要执行什么方法。forControlEvents:就是要添加的事件是什么。而- (void)method:(id)sender这里的sender就是发出Event的这个东西。在这里就是我们的这个UIButton。 简单的用@selector还有另外一个应用场景就是Notification。这个另外写一篇把。","link":"/2012/09/02/learning-ios-notes-eleven/"},{"title":"iOS笔记 (15)","text":"Mogenerator的初级使用什么是Mogenerator最近在用Core Data来进行开发。Core Data其实封装的很好了。把存储底层都屏蔽了（sqlite，xml，内存）。不管是用那种方式存储下来。用Core Data都是在操作对象了。但是Core Data一套东西下来，单是学习就学习的泪流满面。天资有限，只能找一些看上去更简单的第三方类库来使用。 github上找了很久，最后在使用的是MagicalRecord。不为其他，只是用起来很爽。特别是目前升级到了2.1版本以后，保存的方法名字不那么逆天了。更是好用多了。 而Mogenerator是什么东西呢。 它漂亮的主页上是这样写的： mogenerator为你定义了的Core Data生成默认的数据类。与xCode不一样的是(xCode一个Entity只生成一个NSManagedObject的子类)，mogenerator会为每一个Entity生成两个类。一个为机器准备，一个为人类准备。为机器准备的类一直去匹配data model。为人类准备的类就给你轻松愉快的去修改和保存。 为什么需要Mogenerator安装MogeneratorMogenerator其实是一个命令行的工具，因此也就可以轻松愉快的用homebrew去安装。 1$ brew install mogenerator 升级 1$ brew update &amp;&amp; brew upgrade mogenerator 在项目里面添加Mogenerator按照这篇的教程我添加了脚本以后运行不成功 12cd testMogeneratormogenerator -m myDataBase.xcdatamodeld/myDataBase.xcdatamodel/ 提示: /Volumes/Data/iYu/Library/Developer/Xcode/DerivedData/testMogenerator-adwdmrbsvjjxqtawmqvnhfdhubts/Build/Intermediates/testMogenerator.build/Debug-iphonesimulator/Mogenerator.build/Script-5B80B84A16D9EC8F00E8E3A3.sh: line 3: mogenerator: command not found Command /bin/sh failed with exit code 127 自己打命令测试Mogenerator是成功的 xCode使用的是/bin/sh,我怀疑是用homebrew安装的以后的Path跟xCode的/bin/sh/执行的 思考以后在命令之前之前导入mogenerator的路径。 由于我是用homebrew按照的自然在homebrew的路径下面 123cd testMogeneratorexport PATH=\"/usr/local/Cellar/mogenerator/1.27/bin:$PATH\"mogenerator -m myDataBase.xcdatamodeld/myDataBase.xcdatamodel/ 这次mogenerator是找到了，但是xcadatamodeld又没有找到。看到 mogenerator: error loading file at myDataBase.xcdatamodeld/myDataBase.xcdatamodel/: no such file exists Command /bin/sh failed with exit code 66 pwd出来路径观察以后把cd去掉 12export PATH=\"/usr/local/Cellar/mogenerator/1.27/bin:$PATH\"mogenerator -m myDataBase.xcdatamodeld/myDataBase.xcdatamodel/ 这次就对了 使用Mogenerator我创建了一个叫testMogenerator的工程并且在工程的data model名字叫myDataBase 如图： mogenerator安装以后是这样的 然后安command+B 运行一下这个target。 运行以后生成的文件在这里 PS: 第一次生成的文件位置不对。所以脚本又改了一下 123cd testMogeneratorexport PATH=\"/usr/local/Cellar/mogenerator/1.27/bin:$PATH\"mogenerator -m ../myDataBase.xcdatamodeld/myDataBase.xcdatamodel/ 每一个Entity生成了两个类 一个Entity的名字的类， 一个下划线Entity的名字的类。_XXXX.*这个类不要去修改，修改XXX\u0010X这个类就好了。 如果是一个新的entity，需要你自己加入自己的工程里面工程，如果Entity已经加入现在只是更新了Entity的话。就不用加入工程了。 最后编译的时候还是不对 脚本继续改 囧 123cd testMogeneratorexport PATH=\"/usr/local/Cellar/mogenerator/1.27/bin:$PATH\"mogenerator -m ../myDataBase.xcdatamodeld/myDataBase.xcdatamodel/ --template-var arc=YES 总结断断续续折腾了两天。大概明白了mogenerator怎么一个事情。但是好用好还有带研究。这篇blog先发吧。不然又难产了。","link":"/2013/02/22/learning-ios-notes-fifteen/"},{"title":"iOS笔记 (14)","text":"使用CocoaPods序在iOS开发中，经常性的引用第三方开源的库。github上大量的库为我们开发iOS提供了强大丰富多样的资源。从新手一直过来的我们，面对使用越来越多的第三方库。手足无措。CocoaPods的出现使得一切变得Hacker起来。使用CocoaPods一定会让每次copy文件到项目的你喜极而泣的。 之前的方式在使用CocoaPods一般情况下是这样应用第三方库的。 人工copy —— 为了使用，首先用git clone到某个目录。然后自己手动copy到自己的项目里面。(之前的大部分时间里面我都是这么干的)缺点: 跟原来的版本控制失去联系，如果库有升级，你需要从头来一次才能进行升级。然后自己的项目也会顺带管理这些代码，显得臃肿。 在尝试很多次人工copy以后，发现一些github上的第三方库使用git submodule来进行第三方库的版本管理。具体使用方法参考这里.这样我的第三方库也能保持更新而不用重新进行人工copy。缺点是，每次使用的时候我都需要打一堆我记不住的命令和打开浏览器查找第三方库的git地址。 什么是CocoaPodsCocoaPods是Objective-C项目中最好用的第三方依赖包管理工具。只要安装好CocoaPods，在自己的iOS项目路径下建立一份Podfile配置文件，在里面说明要使用哪些第三方库，CocoaPods就会帮忙你搞定所有第三方库的相依性，从clone第三方库甚至到设定好Xcode的项目设置，一切都相当的轻松愉快。你能想像这些工作都是CocoaPods帮我们做好了。 官网 项目地址 Get StartedCocoaPods 是一个 Ruby 的 Gem，所以只要在 Terminal 下输入一下就ok了。(因为os x自带了ruby，但是如果你要升级ruby这是另外一个事情了) 安装12$ [sudo] gem install cocoapods$ pod setup 搜索我们可以用cocoapods来先看看有没有我们需要添加的第三方库 比如我们想用一个json库 123456789101112131415161718192021222324252627282930313233343536373839404142pod search json -&gt; AnyJSON (0.0.1) Encode / Decode JSON by any means possible. - Homepage: https://github.com/mattt/AnyJSON - Source: https://github.com/mattt/AnyJSON.git - Versions: 0.0.1 [master repo]-&gt; JSONKit (1.5pre) A Very High Performance Objective-C JSON Library. - Homepage: https://github.com/johnezang/JSONKit - Source: git://github.com/johnezang/JSONKit.git - Versions: 1.5pre, 1.4 [master repo]-&gt; MTJSONDictionary (0.0.4) An NSDictionary category for when you're working with it converting to/from JSON. DEPRECATED, use MTJSONUtils instead. - Homepage: https://github.com/mysterioustrousers/MTJSONDictionary.git - Source: https://github.com/mysterioustrousers/MTJSONDictionary.git - Versions: 0.0.4, 0.0.3, 0.0.2 [master repo]-&gt; MTJSONUtils (0.0.1) NSObject category for working JSON convertions with suport keypaths ([dict valueForComplexKeyPath:@\"parents[0].children[first].toys[last]\"]) - Homepage: https://github.com/mysterioustrousers/MTJSONUtils.git - Source: https://github.com/mysterioustrousers/MTJSONUtils.git - Versions: 0.0.1 [master repo]-&gt; SBJson (3.1.1) This library implements strict JSON parsing and generation in Objective-C. - Homepage: http://stig.github.com/json-framework/ - Source: https://github.com/stig/json-framework.git - Versions: 3.1.1, 3.1, 3.0.4, 2.2.3 [master repo]-&gt; TouchJSON (1.0) TouchJSON is an Objective-C based parser and generator for JSON encoded data. - Homepage: https://github.com/TouchCode/TouchJSON - Source: https://github.com/TouchCode/TouchJSON.git - Versions: 1.0 [master repo] 恩出现很多 我们选一个自己会用的就好了。 添加我们进入我们的iOS项目目录下，然后新建立一个配置文件Podfile 12touch Podfilevim Podfile 然后加入我们想要的第三方库和库的Version号(Podfile内容) 12platform :iosdependency 'JSONKit', '~&gt; 1.5pre' 保存 执行 1pod install 完成以后你在目录下可以看见一个后缀为.xcworkspace的文件(其实是一个目录，代表着xCode的workspace) 然后。以后你写项目都打开这个就好了。打开看以后会发现其实cocoapods做了一个事情就是他把第三方库都编译成了一个库文件。然后你的项目中去包含头文件，libPods.a被作为framework集成到目标项目。Pods.xcconfig 中配置了XCode编译的查找路径，通过这种方式将所有的第三方包来引入到项目中。 啊哈哈，立马感觉引入一个第三方包都变得很现代有木有。 如果需要加入新的库编写Podfile里面 再次执行 1pod install 就好了。 向cocoapods提交新的第三方库如果你在pod search里面没有找到你想要的库怎么弄。cocoapods允许你自己提交，然后他们审核发布。(太人性化了，感动的想哭啊) 简单的说，Spec就是每个包在CocoaPods中的配置文件，其中包括Package的名字，版本号，每个版本对应的下载地址，编译时的参数。等等。 这是该项目的地址，https://github.com/CocoaPods/Specs，在页面上有介绍如何创新新的包，可以Fork该项目，然后通过pull request提交所建的新包。 官方有视频教程 wiki 参考Git Submodule 的認識與正確使用！ CocoaPods：管理 Objective-C 專案裡頭各種 Library 關聯性最棒的方式 Use CocoaPods for Packages Management in Xcode","link":"/2012/10/26/learning-ios-notes-fourteen/"},{"title":"iOS笔记 (5)","text":"iOS笔记——ViewController的生命周期生命周期这个宇宙中，我们认知当中所有事物都是有一个起点然后到达一个终点。在四维的世界里面，衡量的介质就是时间。所以我们写的程序也是一样的，不管是C还是iOS程序里面，每一个东西在时间流逝中它都有自己的一个起点，终点。 了解程序里面大部分东西的起点和终点的意义是，我们想在这个东西诞生时候和结束的时候做一些事情，一些是我们自愿加入的(比如初始化一个美女的图片)，有些是不得不做的(比如指向这个图片已经销毁，但是这个指针你没有赋值nil，其他的地方还在调用它，就会出错)。 ViewController的生命周期中的过程和方法viewDidLoad在UIViewController初始化完毕和outlets进行hooked完成之后，第一个调用的是viewDidLoad方法。 1- (void)viewDidLoad; 我们可以把大部分初始化需要做的事情通过重载viewDidLoad来完成。仅仅需要小心的事情只有一个就是如果你要设置view的大小(比如:bounds)你应该使用下面这个方法。 viewWillAppear1- (void)viewWillAppear:(BOOL)animated; viewWillAppear这个方法在你的view正要显示的时候调用，因为此时view已经初始化了，但是没有显示出来。如果想要改变view大小，view的排列，view的形状。重载这个方法是很好的时机。 viewWillAppear还适合做另外的一个事情——lazily to stuff。(没听太懂大概是在初始化时候做的一些事情) 如果viewWillAppear里面要做一个耗时很长的事情，这时候，我们一应该开一个线程去做，而且不是这个主进程在阻塞等待。然后再view上显示一个风火轮(spinning wheel) viewWillAppear适合做的两件事情： 在显示view的最后时刻加载一些高开销的操作 改变view的几何特性 viewWillDisappearviewWillDisappear是view将要从屏幕消失的时候调用的方法。这时候你可能想要记住一些view上此时的状态，比如真正浏览的女神图片的网址或者一些你想稍后恢复NSUserDefaults用户的设置。 老头说在这个方法下他有两种比较倾向的做法: 另开进程处理UI的变化 把所有的配置写入长期存储器中存储 第一个理由很简单，为了更快更好的用户体验，第二个也是，可以保存用户的数据，防止意外发生。 viewDidAppear viewDidDisappear这两个方法对应上面的两个方法。他们都在view显示之后调用。老头的举例是说view出现以后你想有一个动画，这时候就可以在这两个方法里面调用。 不管是Wills的方法还是Dids的方法。想要调用时候都是用super，例如 12345678- (void)viewWillDisappear:(BOOL)animated{ [super viewWillDisappear:animated]; // call super in all the viewWill/Did... methods // let’s be nice to the user and remember the scroll position they were at ...￼￼ [self rememberScrollPosition]; // we’ll have to implement this, of course // do some other clean up now that we’ve been removed from the screen [self saveDataToPermanentStore]; // maybe do in did instead?// but be careful not to do anything time-consuming here, or app will be sluggish// maybe even kick off a thread to do what needs doing here} view{Will,Did}LayoutSubviews;frame改变之前会调用viewWillLayoutSubviews(例如，横向iPhone时候frame就改变了。) 同理可得viewDidLayoutSubviews是frame改变之后调用。 这样我们就可以根据不同的屏幕状态来调整显示，以便获得最佳效果。 viewDidUnload如果iOS中内存过低，这时候，系统会自动的卸载view。意味着系统把viewController从内存里面干掉，也就是停止所有指向viewController的strong类型的指针。做完这些以后，viewDidUnLoad会被调用。也就是self.view设置为nil时候调用。 直觉上来说，这时候貌似不用做什么事情。可是为了最佳实践。虽然你的outlets都是weak类型的。但是你还是需要手动在viewDidUnload把它们设置为nil。这起码算是一种好的iOS编程习惯,我们应该把所有的outlet都设置为nil。 1234- (void)viewDidUnload{ self.faceView = nil;} 如果你还是想知其然：大概就是可能在其他地方，有个指向这里某个outlet的strong类型的指针。根据ARC，这时候你的outlet是已经释放了。但是那个strong指针仍然指向了之前的那个内存地址，如果这时候使用，内存就会错误，而设置了为nil以后，向nil是可以发送任何消息，不会错误的。(我是这样理解，可能跟现实有出入。欢迎指正。) 随便说一声，不管内存有多低，正在现实的view是不会被unload的。所以只是针对屏幕以外的viewController进行unload。","link":"/2012/04/03/learning-ios-notes-five/"},{"title":"iOS笔记 (9)","text":"xCode4 配色主题一直以来，我对写代码的各种颜色就乱折腾不不管是Vim还是Emacs花在上面的时间都蛮多的。也不知道是哪里来的精神。这次换xCode了。也折腾过很多。今天小文问了一下。恩，觉得这个东西可以拿出来写一篇blog，来填补我还差3篇的坑。 Path1cd ~/Library/Developer/Xcode/UserData/ 看看里面有没有一个叫FontAndColorThemes的文件夹，没有就新建立一个 1mkdir ~/Library/Developer/Xcode/UserData/FontAndColorThemes 然后你下载的那些Themes就可以丢里面。重启xCode就能看见了。 Themessolarized我见过史上最全最多的配色方案solarized 它居然支持我用过的所用编辑器和IDE:Vim,Emacs, IntelliJ IDEA, NetBeans, SeeStyle theme for Coda &amp; SubEthaEdit, TextMate, TextWrangler &amp; BBEdit ,Visual Studio, Xcode 而且不仅仅是编辑器，连总端配色都用。一条龙服务啊 Xresources, iTerm2, OS X Terminal.app, Putty. 完整版的地址在这里 https://github.com/altercation/solarized xCode4 https://github.com/brianmichel/solarized/tree/master/apple-xcode4-solarized 把Solarized - Dark.dvtcolortheme和Solarized - Light.dvtcolortheme这两个文件丢到刚刚新建的~/Library/Developer/Xcode/UserData/FontAndColorThemes目录下重启xCode就可以用了。效果如下: Solarized - Dark Solarized - Light zenburnzenburn的评价也很高，可是我不喜欢那灰蒙蒙的感觉我是在这里下载的 zenburn ObjectiveSheep看上去也还可以 但是缺少色彩变化我是在这里找到 ObjectiveSheep DarkCity这个本来是boss在用，今天小文也用这个。看着确实色彩丰富了一些。试试看。找到的还是Robin Lu制作的。他的blog很不错，顺带推荐一下。 我是在这里下载到的 DarkCity tomorrow-themesummer推荐，也是各种编辑器方案都有 https://github.com/chriskempson/tomorrow-theme 找到xCode4的两个文件 就ok了 小结选个喜欢的进去根据自己的需求改吧。等等。怎么就完了。为什么在xCode里面不可以改变刚刚拷贝上去的主题 修改主题因为刚刚考进去的文件权限的问题，并不能修改主题怎么办 1chmod 666 ~/Library/Developer/Xcode/UserData/FontAndColorThemes/* 这下，你可以爽快的修改各种主题了。","link":"/2012/08/12/learning-ios-notes-nine/"},{"title":"iOS笔记 (4)","text":"iOS笔记——九宫解锁基础部分目的为了第一个App，一步一步的做出来。所以先弄最基本的想做一个类似Android九宫解锁的View。一开始完全没有思路啊。后来看了好几遍老头的画笑脸以后才有点思路。所以来一步一步做吧。 继续扯淡MVC作为一个从iOS5开始学起开发的娃来说，什么nib xib文件都是浮云。哥只懂在Xcode里面的storyboard里面拖拖拽拽。奈何没几个代码实例是Storyboard写的。让想重用代码的我，无法直接⌘-c ⌘-v。很是郁闷哈。不过经过慢慢理解，对于Xcode4里面用stroyboard有了一些小小的心得。分享一下。 一个VC是怎么构成的。在新建工程storyboard里面，我新拖入一个view如图 这是此时，这个仅仅是一个无人管的一段xml而已。因为你的程序里面没有相应的类去接管这个view。就像一个没人要的狗腿子。好可怜的。你需要把他找一个C的主子管着他，让view知道他应该怎么显示什么东西，对发生的事情做出什么样的反应。 首先，你至少已经建立了接管这个view的controller类。 接着点击你view的这里 从右侧选择你看见的这里的class的下拉框，选中你的controller 有时候拖出来的view，并不能够满足你的需求。你可能会写一个subclass继承UIview来进行扩展。你也需要指定你拖出来的view他本身指向这个subview。 这是跟刚刚大同小异 首先，你至少已经建立了这个继承UIView的view类。 接着点击你view的这里 从右侧选择你看见的这里的class的下拉框，选中你的controller 这样你就完成了一对VC的创建了。 程序基本要做的事情 有一个view，view上有背景色 view上画9个按钮 view上能画线 controller能控制手指开始的地方，移动的地方，结束的地方。 一步一步clone工程1git clone git://github.com/iiiyu/Draw-Lock-Login.git 项目结构 Draw_Lock类分析(UIView)点开Draw_Lock.m可以看到两个方法,其中一个还是注释掉的。 123456789101112131415- (id)initWithFrame:(CGRect)frame{ self = [super initWithFrame:frame]; if (self) { // Initialization code } return self;}// Only override drawRect: if you perform custom drawing.// An empty implementation adversely affects performance during animation.- (void)drawRect:(CGRect)rect{} initWithFrame虽然看起来像初始化函数的样子，但是如果我们想初始化做一些事情的时候。是要重新写一个函数 123456// 老头说过不直接调用initWithFrame 而是调用awakeFromNib来进行初始化// 进过测试 initWithFrame也不会被调用- (void)awakeFromNib{ } 如果需要初始化做一些事情，请重载awakeFromNib。 drawRect函数一开始是被注释掉。但是此函数可以在view上进行绘画。关于Quartz请参考相关官方文档。 仅仅记录我觉得重要的地方。 12// 这个context就是画布，官方叫上下文。每次作画前要有。CGContextRef context = UIGraphicsGetCurrentContext(); 一开始我不会设置view的背景，就想把画一个和view相等的矩形。这样不就是背景了。后来发现是可以直接设置的。 12// 设置view的背景颜色self.backgroundColor = [UIColor darkGrayColor]; 把要加入的9个宫。看做一个个的view。我们先创建这些view。然后用addSubview加入Draw_Lock这个view当中，最后调整这些宫的位置就完成了图像的绘制。 每一个宫由两张图片构成。一张为默认，一张为highlighted属性的。当我们碰到宫时候，设置他的highlighted为YES。 然后是线的绘制。当手指触碰到宫的时候，才吧宫的中心作为起点开始绘制线。绘制的线在没有遇到第二个宫的时候跟随手指，如果遇到宫。就绘制完成一条直线。然后把终点的坐标为下一条线的起点。直到手指离开屏幕。 ViewController类分析（UIViewController）手指触摸开始 1234- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{} 手指移动 1234- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event{ } 触摸结束 1234- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event{ } 最后大概在山寨这个九宫的时候就遇到很多问题。隔了一天，能想到一一记录。当然，还有更多的问题。所以最好就直接看github项目里面有更详细的注释和完整的代码。很多时候，觉得写代码比写blog轻松多了。","link":"/2012/03/21/learning-ios-notes-four/"},{"title":"iOS笔记(19)","text":"Core Data (二)序上次只是说了三个Core Data栈基本类。这次准备介绍一下常用的类。 NSManagedObject Core Data是一次底层数据封装成面向对象的技术。最直接的表现就是在SQLite里面的一条记录在Core Data里面的表现是一个NSManagedObject对象。因此我们的增删改查都是基于操作对象的。恩这里多说一句，NSManagedObject是相对NSManagedObjectContext里面是唯一的。而真实的应用情况可能是NSManagedObjectContext会有多个。而NSManagedObjectContext线程不是安全的，所以可能有你多个NSManagedObjectContext里面各自有指向同一条数据的不同的NSManagedObject。这个情况需要你的程序设计和逻辑上去解决。暂时不讨论。 使用NSManagedObject所经历的三种方法对于NSManagedObject来说一般有以下几种使用方法： 第一种就是我直接使用NSManagedObject来访问我的数据，因为Cocoa特有的KVC机制，使得NSManagedObject可以用KVC的方法去访问属性内容。这样的好处是你不用在NSManagedObject上去写特别的代码，就可以使用。一般入门例子都是这样写的。 第二种是老头视频里面教过的。在点击Data Model选择Entity以后，在xCode的菜单里面有这样一个选项： next都按完了以后，会生成选择了的Entity对应的一个NSManagedObject子类。这样的话我们就可以用生成的类来进行增删改查。这样的话看起来代码里面也会变得清晰一些。我们也不必去写KVC的方法去访问修改属性。可以直接就访问修改。在我看来还是好处多多的。为了OO的原则，我们可能会对不同的Entity类去写一些只是公开接口的方法。但是这样生成的NSManagedObject子类是不好修改的。因此我们会去建立一个category类。来进行扩写自己的方法。这样项目里面就会出现一票category感觉不是很好的样子。 第三种方法是我现在在使用的方法。就是使用Mogenerator. Mogenerator已经写过一篇blog了。详细查看Mogenerator的初级使用好处是生成一次以后，再次生成并会在工程里面重复引用。而且机制上可以直接在生成的类里面进行方法的扩写。不用使用category类。这样整个工程就看起来高级素雅很多。 NSManagedObject其他注意事项NSManagedObject就是我们拿来操作数据的基本单位。因此对应，增加一条数据是在NSManagedObjectContext新建一个NSManagedObject。查找数据是查找NSManagedObject。修改是修改NSManagedObject类的属性。删除是从NSManagedObjectContext里面删除NSManagedObject类。最后我们保存NSManagedObjectContext，然后一直向上传递到磁盘上面去。才是持久化的修改。 NSFetchRequestNSFetchRequest是一个查询的动作类。我们使用它来在NSManagedObjectContext里面查询相应的NSManagedObject。 一般使用的顺序是先生成NSFetchRequest。指定要查询的NSManagedObjectContext和Entity的名字。然后设置NSPredicate进行过滤。NSSortDescriptor来进行排序。最后用想要查询的NSManagedObjectContext执行NSFetchRequest。就可以得到返回结果了。 NSPredicateNSPredicate的作用不仅仅局限于Core Data里面。其他时候也有用到的地方。而在Core Data里面使用简单的说就是作为一个过滤条件。过滤掉我们不想查找的数据。就相当于SQL语句WHERE后面的那些条件。 NSSortDescriptor查找到的数据是杂乱无章的。而我们往往希望是具有一定顺序的返回结果。NSSortDescriptor就是用来指定排序的属性和方式的。把NSSortDescriptor生成设置好然后给NSFetchRequest设置。这样我们的结果就可以是按照我们希望的顺序返回回来。以便我们操作。 实例代码新建NSManagedObject 12NSManagedObject *newManagedObject = [NSEntityDescription insertNewObjectForEntityForName:[entity name] inManagedObjectContext:context];[newManagedObject setValue:[NSDate date] forKey:@\"timeStamp\"]; 删除NSManagedObject 1[context deleteObject:managedObject]; 初始化NSPredicate 123NSUInteger numberOfServings = 10;NSPredicate *predicate = nil;predicate = [NSPredicate predicateWithFormat:@\"serves &gt; %i\", numberOfServings]; 初始化NSSortDescriptor 1NSSortDescriptor *sort = [[NSSortDescriptor alloc] initWithKey:@\"name\" ascending:YES]; 初始化NSFetchRequest 12NSManagedObjectContext *moc = [self managedObjectContext]; NSFetchRequest *request = [[NSFetchRequest alloc] init]; [request setEntity:[NSEntityDescription entityForName:@\"Recipe\" inManagedObjectContext:moc]]; 带有NSPredicate的初始化NSFetchRequest 12345NSUInteger numberOfServings = 10;NSManagedObjectContext *moc = [self managedObjectContext]; NSFetchRequest *request = [[NSFetchRequest alloc] init]; [request setEntity:[NSEntityDescription entityForName:@\"Recipe\" inManagedObjectContext:moc]];NSPredicate *predicate = nil;predicate = [NSPredicate predicateWithFormat:@\"serves &gt; %i\", numberOfServings]; [request setPredicate:predicate]; 带有NSSortDescriptor的初始化NSFetchRequest 1234NSFetchRequest *fetchRequest = nil;fetchRequest = [NSFetchRequest fetchRequestWithEntityName:@\"Recipe\"];NSSortDescriptor *sort = [[NSSortDescriptor alloc] initWithKey:@\"name\" ascending:YES];[fetchRequest setSortDescriptors:[NSArray arrayWithObject:sort]];","link":"/2013/04/01/learning-ios-notes-nineteen/"},{"title":"iOS笔记 (7)","text":"iOS笔记 Core Location定位主要问题很多应用上需要获得当前用户所在的位置，有或者需要在地图上根据座标显示一些点一些信息。这次主要分享Core Location定位当前位置我遇到的问题。 第一个方案根据我看的文档所示定位分为一下几个步骤： 包含Core Location framework 创建一个CLLocationManager的实例 设置CLLocationManagerDelegate委托 实现CLLocationManagerDelegate委托里面的- (void)locationManager:(CLLocationManager )manager didUpdateToLocation:(CLLocation )newLocation fromLocation:(CLLocation *)oldLocation方法 其中原理就不细说了。只说实现问题。在完成了- (void)locationManager:(CLLocationManager )manager didUpdateToLocation:(CLLocation )newLocation fromLocation:(CLLocation *)oldLocation以后。当我们想要定位的时候。需要启动startUpdatingLocation。因为启用定位是一个耗电的工程。如果时刻定位的话，程序会变成电池杀手。所以，各种大牛建议，定位只在需要的时候定位。完成以后我们应该用停止它stopUpdatingLocation。 调用你实例的CLLocationManager startUpdatingLocation以后，会轮询- (void)locationManager:(CLLocationManager )manager didUpdateToLocation:(CLLocation )newLocation fromLocation:(CLLocation *)oldLocation方法。直到stopUpdatingLocation为止。因此可以用一个数组存储一定的newLocation。然后取平均值。本来我以为这样可能会取值准确一些。但是我实际定位估计有2-3km的距离。起初我以为是用ip来定位可能误差较大没有在意(用的iPad wifi测试).后来用其他App看到定位很准确，没有这么大的误差,就觉得做错了。然后尝试第二种方案。 第二个方案隐约记得有种叫火星座标的东西。在这里V2EX普及了一下知识以后，觉得难道是火星人搞鬼了。然后纠结于解决方法。最后忘记在哪里看到MKMapView里面有一个userLocation的属性。就应该是当前位置座标。干净尝试一下: 包含MapKit framework 创建MKMapView一个实例类 设置MKMapViewDelegate委托 实现MKMapViewDelegate委托中的- (void)mapView:(MKMapView )mapView didUpdateUserLocation:(MKUserLocation )userLocation方法 MKMapView实例调用setShowsUserLocation 这样在- (void)mapView:(MKMapView )mapView didUpdateUserLocation:(MKUserLocation )userLocation方法里面userLocation就可以取得当前用户的位置。而且很准确。 总结我不知道第一个方案为什么不准确，而第二个比较准确。跟曹哥讨论以后，曹哥告诉我说有人为了获得位置可能会建立一个不显示的MKMapView而仅仅是为了获得坐标。特此记录。","link":"/2012/05/06/learning-ios-notes-seven/"},{"title":"iOS笔记(17)","text":"#iOS读写文件 序由于iOS App的机制和限定，我们在App里面的权限就仅限于App内部。这个打包好的内部称为沙箱。沙箱有利有弊。我觉得这个世界上没有绝对的好坏。虽然沙箱的作用限制了一些功能的实现。但是也确保了iPhone的安全机制。对于普通用户来说我觉得的利大于弊的。(MAS上架的软件也接受这一约束) 第一步 路径不管是读文件还是写文件我们都要需要知道文件的位置。这个位置在iOS里面就是沙箱的Document文件夹的位置。关于沙箱里面各个文件夹的功能和作用。Apple的某文档里面写的很清楚建议Google以后详细查看（懒得去找来贴了）。获取代码如下： 12NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *documentsDirectory = [paths objectAtIndex:0]; NSDocumentDirectoryz这个参数你点过去可以找到一堆类似的定义比如常用的NSLibraryDirectory，NSApplicationDirectory。这样就可以直接获取到对应的文件夹路径。其他的你照抄就好。想知道意思就点过去看呗。其实看变量名也可以猜测一二。 1NSString *filePath = [documentsDirectory stringByAppendingString:@\"/hello.txt\"]; 然后我们加上我们文件名字构成一个完整的路径。注意文件名字前有一个/。 这样我们就获得一个文件路径了。 第二步 检查文件是否存在我们有了文件的路径以后，想读取。是可以。但是要是文件不存在，我们硬来就读取不到任何东西。所以，一般的做法是在读取之前去检查一下这个路径的文件是否存在。如果不存在我们就可以作出相应的处理动作。 1234567NSFileManager *fileManager = [NSFileManager defaultManager];//检查文件是否存在if([fileManager fileExistsAtPath:filePath]) { // 做存在的事情}else{ // 做不存在的事情} 第三步 读取文件如果文件存在我们就可以读出文件内容。常用以下几种 123456789101112131415//读取为二进制NSData *myData = [NSData dataWithContentsOfFile:filePath];if(myData) { // do something useful}//读取为StringNSString *myString = [[NSString alloc] initWithContentsOfFile:filePath encoding:NSStringEncodingConversionAllowLossy error:nil];if(myString) { // do something useful}//如果是一个Plist，可以读取为字典NSDictionary *myDictionary = [[NSMutableDictionary alloc] initWithContentsOfFile:filePath];if(myDictionary) { // do something useful} 第四步 写入文件如果我们有内容要存入文件。常用一下几种 123456//写入二进制内容[myData writeToFile:filePath atomically:YES];//写入String[myString writeToFile:filePath atomically:YES encoding:NSStringEncodingConversionAllowLossy error:nil];//写入Plist[myDictionary writeToFile:filePath atomically:YES]; 值得注意的是参数中YES的意思为如果为YES则保证文件的写入原子性,就是说会先创建一个临时文件,成功了就改名为正式的文件。如果为NO,直接写入目标文件目录里.writeToFile:atomically:的这个方法都为覆盖。如果想要是追加的效果。建议先读出原文件内容然后在后面加入新内容。最后一起写入。这样就覆盖了老的文件。 总结之前一直想写的blog想深入一些。以至于不敢动手开始写。总觉得还没有准备好。自己也懂的不够透彻。这样不知不觉欠了几十篇blog了。在todo list里面都要变成谍中谍了。最近关注了几个微信公众帐号。见到人家天天画时间去更新。比我优秀的人比我更加努力。惭愧的很。所以现在就拿着简单的内容写起来。 故不积 跬步，无以至千里；不积小流，无以成江海。","link":"/2013/03/11/learning-ios-notes-seventeen/"},{"title":"iOS笔记 (6)","text":"iOS笔记 利用ASIHTTPRequest做断点续传主要问题需要请求Http协议，下载一个zip包。包比较大，希望能后台下载。退出应用再次打开的时候能接着上一次的下载。专业名称：断点续传。 寻找方案iOS目前三大开源网络库 ASIHTTPRequest AFNetWorking MKNetworkKit 个人以Google出来的信息得出的对比： | 网络库 | 优点 | 缺点 | | ———— | ————- | ———— | | ASIHTTPRequest | 老牌、功能强大、文档丰富 | 停止更新、新特性少、厚重 | | AFNetWorking | github上比较火的项目、有稳定的两个主要负责人、能支持比较新的特性、一直有更新 | 文档数目一般、有些功能貌似要自己写 | | MKNetworkKit | 支持ARC、号称要有 ASIHTTPRequest的功能，AFNetWorking的轻便 | 文档数目最少、只有作者一个主要负责人 | 在结合我是一个新新手的缘由。如果用库的话，首选ASIHTTPRequest。候选AFNetWorking。 AFNetWorking 被Google到这样的解决方法.本来准备fork了。然后仔细看了看下面的讨论。 觉得自己实现一个？ 原理在这里 sunmmer大神给了一个不用库实现的例子 后面想了想，对于网络其实我也是新手来的。自己写，未必有成熟的库写的好。所以决定使用ASIHTTPRequest。 ASIHTTPRequest我就简单说一下ASIHTTPRequest怎么使用到自己的项目当中。 下载ASIHTTPRequest以后。我们需要用到这些文件拖入我们的项目当中(记得copy打勾) 然后我们需要导入 CFNetwork.framework SystemConfiguration.framework MobileCoreServices.framework CoreGraphics.framework libz.dylib 这些framework。至此，我们已经可以很高兴快乐的使用ASIHTTPRequest了。 断点续传官方实现官方实例 民间实现曹哥找了一个demo ryan的这个demo对于我来说存在几个问题： 关闭View controller以后无法保持下载(无法保持下载的状态) 无法跟踪多个UIProgressView 等一些细小问题。 我的实现我就在ryan这个demo的基础上改。 下载持久化解决关闭View controller以后无法保持下载(无法保持下载的状态)这个问题。 我新定义了一个类。并且把这个类定义成单例，ASINetworkQueue作为这个单例的一个property。这样一来，就不怕view controller被pop掉，被关闭的时候，ASINetworkQueue被释放掉。 定义单例的技巧，可以说是一个模板。新建一个继承NSObject的类。主要实现一个名叫shareXXXX的类方法。XXXX就是你类的名字。比如我的这个类叫TDNetworkQueue。就要实现一个 1+ (id)sharedTDNetworkQueue; 而sharexxxx方法可以参照一下模板。 123456789101112131415161718+ (id)sharedxxx{ static dispatch_once_t pred; static xxx *xx = nil; dispatch_once(&amp;pred, ^{ xx = [[self alloc] init];}); return xx;}- (id)init{ self = [super init]; if (self) { } return self;}- (void)dealloc{ [super dealloc];} 如果有属性初始化的话都放到init方法里面。share方法用到了一些GCD和block的东西。照搬就好。 保持进度条解决无法跟踪多个UIProgressView的问题。为了跟踪到UIProgressView，我在单例的类里面实现了 1234567891011121314// 增加下载的request进入队列- (void)addDownloadRequestInQueue:(NSURL *)paramURL withTempPath:(NSString *)paramTempPath withDownloadPath:(NSString *)paramDownloadPath withProgressView:(UIProgressView *)paramProgressView;// 当controller被关闭清除内存的时候，设置到delegate的view要设置为nil- (void)clearAllRequestsDelegate;// 当controller被关闭清除内存的时候，设置到delegate的view要设置为nil.只对一个有效果- (void)clearOneRequestDelegateWithURL:(NSString *)paramURL;// 恢复progressview的进度- (void)requestsDelegateSettingWithDictonary:(NSDictionary *) paramDictonary; 这些方法。值得注意的是 1234- (void)addDownloadRequestInQueue:(NSURL *)paramURL withTempPath:(NSString *)paramTempPath withDownloadPath:(NSString *)paramDownloadPath withProgressView:(UIProgressView *)paramProgressView; 这里的paramProgressView对应于你的请求下载的URL(request)。 12// 恢复progressview的进度- (void)requestsDelegateSettingWithDictonary:(NSDictionary *) paramDictonary; 这里的字典key是URL，object是UIProgressView。我在view controller中的viewDidLoad方法调用。 总结我改写的很简单，特别的地方都在上面注明了。如果不明白就留言吧。大神们也请轻拍，我在慢慢努力中。 改写的github地址： git clone git://github.com/iiiyu/TestDownload.git 最后附送两篇队列优先级的文章 [使用NSOperationQueue简化多线程开发]http://blog.colcy.com/archives/2011/217/11/25/使用nsoperationqueue简化多线程开发/ [队列的优先级]http://blog.colcy.com/archives/2011/222/11/25/队列的优先级/","link":"/2012/04/25/learning-ios-notes-six/"},{"title":"iOS笔记 (13)","text":"UIViewController的一些事儿序这篇主要是想写 Contaner View Controller。然后才好写我计划里面的下一篇讲UIStoryboardSegue的blog。 先贴一个链接 Container View Controller.他写的很好，算是中文blog里面我见过写 Container View Controller最好的一篇blog。 另外一篇中文blogUIViewController的误用 然后是apple的官方文档 UIViewController Class Reference View Controller Programming Guide for iOS 什么是UIViewController UIViewController就是MVC模型在iOS当中对应Controller的具体类型。最基础普通的情况下，每一个屏就要对应一个UIViewController的子类。也就是说你向storyboard拖入一个view controller的时候。你还必须新建一个接管你这个storyboard的UIViewController子类。然后把他们两个连接起来。\u001b\u001b\u001b\u001b这样就可以获得了一个MVC里面的VC了。然后这个UIViewController其实是管理着一组View Hierarchy。因为你的屏幕上可能有各种控件。每一个控件都是一个View。他们构成了一组View Hierarchy。 so这个UIViewController的子类控制着这组View的行为。包括View的显示，消失，改变，动画等等。这种说明有点抽象了，来点简单的。UIViewController就是View的主子。一个ViewController应该且只应该管理一个view hierarchy，而通常来说一个完整的view hierarchy指的是整整占满的一个屏幕。 之前有一篇讲过了一点View Controller生命周期的blogiOS笔记(5)。可以看看。 什么是Contaner View Controller 通常情况下，我们的App不会只有一个View Controller这么简单。会有很多个View conroller。我们不能让我们的App里面的View Controller杂乱无章。我们需要一个东西来能够管理这些View Controller。这个东西就叫Contaner View Controller。Contaner View Controller也是继承于UIViewController。这里我们可以得到两个信息: UIViewController其实可以自己管理自己。我们就可能自己写Contaner View Controller。 加上上图的描述。Contaner View Conroller（Navigation Controller）其实是一直存在的。 常见的Contaner View Controller其实常见的Contaner View Controller也就两个UINavigationController和UITabbarController。他们肯定都有一些特征：(摘抄第一篇blog) 提供对Child View Controller进行管理的接口,比如添加Child View Controller,切换Child View Controller的显示,移除Child View Controller 等 容器“拥有”所有的Child View Controller 容器需要负责 Child View Controller的appearance callback的调用(viewWillAppear,viewDidAppear,viewWillDisaapper,viewDidDisappear),以及旋转事件的传递 保证view hierarchy 和 view controller hierarchy 层级关系一致,通过parent view controller将child view controller和容器进行关联 其实如果我们进行一般的iPhone App快速开发。这两个Contaner View Controller已经足够用了。 UINavigationController简单的UINavigationController如系统的Setting。 很简单。就是一个满屏一个满屏的推进，然后回退。学过程序的你看到那些描述也很亲切。可以简单理解为数据结构中的栈的图形方式。Push为进栈，Pop出栈。你还可以Pop全部已经压入的数据。 当然UINavigationController肯定要比一个栈复杂的多。下图是UINavigationController的层次结构 肯定的，我们在相应的场景里面可以选择把Navigation bar或者 Naviagtion toolbar设置为显示或者不显示。这完全取决于你的设计。 UITabbarController和UINavigationController不同，UITabbarController使用的场景更可能是不太相关连的View Controller组合到一起。而UINaviagtionController强调的是层层递进的关系。 所以，UITabbarController管理下的View Controller所做的操作是切换，而不是Push。 UITabbarController的层次结构 后记当然UINavigationController和UITabbarController是可以放到一起使用的。UINavigationController代表的纵向的View Controller推进方向。UITabbarController代表着横向的View Controller切换方向。 喜欢这些碎碎叨对你有用。欢迎批评指正错误。thx。","link":"/2012/10/21/learning-ios-notes-thirteen/"},{"title":"iOS笔记(35) 格志周年系列之夏令时(三) 临时花絮","text":"本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 开篇扯淡说曹操，曹操到。嘛当，还说总结一下时间的问题。这不blog这个系列没有写完。又爆了出一个时间相关的Bug。我只能说编程路茫茫，吾将上下求索。这次就着热乎着，来说是一个遇到了什么问题。 遇到的问题有日本用户反馈，新版本更新以后，他日历上的时间全部乱了。而且无法写入日记。经过与用户沟通（感谢喵神onevcat的日文人肉翻译）分析得到用户使用和历（日本日历）。然后debug进去果然日期全部乱了。跟进去debug了一番，发现是之前解决夏令时的函数只考虑了公历！！！而iOS系统默认有三种日历。公历、和历、佛历。又一次无情的证明了我是一个天朝土包子。 iOS &amp;&amp; OS X 支持的日历这个问题的出现提醒了我，地球上不同的人们其实是使用着不同的日历。（在这之前学习到的是地球上的人们过着不同的时区，有夏令时和没夏令时的时间）。 iOS从Settings-&gt;General-&gt;International-&gt;Calendar。 可以看到是默认只是支持公历、和历、佛历。 OS X 要多一些…（好吧，大部分我都不认识） 那到底iOS &amp;&amp; OS X支持哪些日历呢。 看这里内建的有这些NSLocale Calendar Keys (PS: 经过测试农历那个之前处于半残疾状态) 用代码测试一下我遇到的问题是我获得00:00:00的方法是直接用string然后反向设置小时、分钟、秒数得来的。所以，当日历不同的时候date-&gt;string就不一样了！！！这样我只判断了公历的时候，和历和佛历就错了。 详细代码可以查考这个TestNSDateFormatterOnMac 我fork了一个霓虹大神改动的。 添加了佛历的对比。 总结做好一个App其实挺难的，做好一款全球化的App更是难上加难。特别是我这种天朝土鳖，写程序的时候脑子里面就没全球化的意识。 附上一个今天在推上看到的心酸笑话： 编历法的玛雅码农想「我做个日历做上一千年应该就够用了吧」；编UNIX的码农想「我写个OS能用到2038年应该就够用了吧」；编RFC791的码农想「我整个IP能给42.9亿人用应该就够用了吧」——都给全世界添了乱子。我们做码农的一定要引以为戒 #读日语推有感# 一些参考农历 wiki 希伯來历 wiki ISO 8601 wiki UNICODE LOCALE DATA MARKUP LANGUAGE (LDML) NSDateFormatter で、和暦の変換に固定する 在开发iOS程序时对日期处理的总结","link":"/2014/04/08/learning-ios-notes-thirty-five/"},{"title":"iOS笔记(34) 格志周年系列之夏令时(二)","text":"本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 开篇扯淡恩，两月没更新blog，hexo都出来新主题来着。其实昨天为了找个背景图找了一小时我会随便乱说。就是为了找一个配合网站标题的背景图。其实hexo默认的就蛮好了，但是为了显示那么一点点与众不同还是替换了一下。 扯淡结束，接上一篇格志周年系列之夏令时(一) 第一阶段Bug上次说过一个中国高富帅用户发Email来说，他去泰国旅游的时候，日记都不见了。 其实不是日记不见了，日记都好好的躺在sqlite文件里面。而是查询不出来了。日记的保存是用了一个函数去获得了每天的00:00:00. 然后作为唯一标识来区别和查询。 那日期出了啥问题？ 我们来快速的分析一下 调用的是 12345678- (NSDate *) dateAtStartOfDay{ NSDateComponents *components = [CURRENT_CALENDAR components:DATE_COMPONENTS fromDate:self]; components.hour = 0; components.minute = 0; components.second = 0; return [CURRENT_CALENDAR dateFromComponents:components];} 里面有两个宏 12#define DATE_COMPONENTS (NSYearCalendarUnit| NSMonthCalendarUnit | NSDayCalendarUnit | NSWeekCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit | NSWeekdayCalendarUnit | NSWeekdayOrdinalCalendarUnit)#define CURRENT_CALENDAR [NSCalendar currentCalendar] 假设你使用过Cocoa时间这些类的话能很容易的看出。dateAtStartOfDay函数就是把你持有的date以当前日历为基础，其他不改，小时，分钟，秒钟设置都为0。这样就能得到一个基于当前日历下的date这一天的00:00:00。 简单看上去没有什么问题，回到高富帅的问题。他出国玩一圈咋时间就变了呢？答案是[NSCalendar currentCalendar]改变了。NSCalendar的改变使得dateAtStartOfDay返回的时间也变了。debug到这一步才发觉靠当初为什么没有想到有时区的这个问题。 自己给自己找一个理由就是到目前为止，我只用过大天朝的+8时间。潜意识里面根本没有说换一个时区这样的概念。(后来某一天我翻了本C语言的书第一章就说了国际化时间的问题，再后来weibo上大家都纷纷表示时间是编程里面一个基础点而且做好不容易，只能说我还是太菜太年轻了。这些是后话了) 说道这里那就开始科普一下地球上时间的问题 世界时间由于人类历史的缘由，地球上以大概的地理位置画分时区。Time Zone Wiki 我认为时间是大爆炸以后产生的扩张现象，在可预见的人类的历史上肯定是不可逆转的。所以每一个时刻对于人类来说应该是唯一的。但是，在这同一个时刻里面，在地球的不同地方使用着不同的时间格式来表现着。我认为这是相当不科学的一个事情。随着人类文明的进步，我觉得最后应该会全世界时间大统一的。 回到现实中还是要解决现在因为时区而产生的问题。 iOS中的时间在Cocoa里面，获取一个当前时间是 1NSLog(@\"Now:%@\", [NSDate date]); Log出来应该是一个 xxxx-xx-xx xx:xx:xx +0000。但是聪明的你，人如果处在大天朝内马上发现这个时间比你电脑上的时间少了8小时。 恩,因为NSDate记录的是一个绝对的值。这个值代表的意思是UTC时区的绝对时间。我们就把它看作为我们写Cocoa程序的一个绝对时间，千万要记住这一点。因为接下来的一堆概念会把人弄晕的。（我就晕了好久#_#） UTC Wiki 与UTC有点关系的GMT时间，稍作了解避免搞混了。（实在分不清，你就记住UTC是一个更加精准的标准时间） GMT Wiki 那NSDate存储了一个什么值来代表时间呢？可以简单的认为他是记录了一个浮点数。这个浮点数代表什么呢？我们注意到头文件里面有个这样的方法timeIntervalSince1970。 12// secondsNSLog(@\"seconds %lf\", [[NSDate date] timeIntervalSince1970]); 在写文章的此时此刻打印出来是“1395324408.535384”。简单运算一下 1395324408.535384 / 60 / 60 / 24 / 365 ≈ 44.245446745 2014.x - 44.x ≈ 1970 看到这里，就可以很明确的认为用NSDate来存储的时间是从1970-01-01 00:00:00 到那个时刻所经历的秒数。 为什么是1970？如果你接触过一些计算机的知识或者其他编程语言或者数据库等。你都可能在时间相关的地方会发现1970很眼熟的样子。放鸭搜索了一下。找到一些比较权威的说法。 首先能找到权威解释是Unix time。简单粗暴的来说就是我们现在用的 nix 以及基于 nix的一堆东西（包括了现在使用的绝大部分东西）都是1970年极其以后出现的。那时候大家觉得就从1970-01-01 00:00:00开始算时间是个不错的主意。就这么一直延续下来了。（PS：忽略了一堆32bit or 64bit的点。需要详细解释的看url） 看NSDate头文件还 发现一个有意思的宏 1#define NSTimeIntervalSince1970 978307200.0 稍微做了一下运算。可以知道这是从1970-01-01 00:00:00 到2001-01-01 00:00:00经过的秒数。稍微思考一下应该是用来进行了优化运算的。 待续。。。 小结这么一点字又写了两天，还是要每天坚持啊。","link":"/2014/03/19/learning-ios-notes-thirty-four/"},{"title":"iOS笔记(31) CocoaPods 手把手五分钟教你制作自己的podspec文件","text":"本文仅作为个人记录使用，也欢迎在许可协议范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助，您可以使用RSS方式订阅本站，这样您将能在第一时间获取本站信息。 ##开篇扯淡圣诞渐进，各种App都在黑五一波冰点。可以遇见的是12月25号前也会有一大波来临。但是！！！今年买软件貌似已经花了很多钱了。而且，也没有几个想入的了。所以就忍忍吧。 然后，做个宣传啊。我们国际化大厂Sumi的App Grid Diary在紧锣密鼓的开发2.0. 完全iOS7设计。各种给力。到时候希望能给大家带来一个好的App吧。 ##CocoaPods CocoaPods 不必在介绍了吧。如果你是一个iOS or OSX的开发者。然后你跟我说你还没有用过CocoaPods。我肯定会觉得你不够潮(low爆了)。 其实我之前又写过两篇介绍CocoaPods的 只不过时间有点久远了。而且CocoaPods更新很快。有了很多新的特性和功能。 截至我写这篇blog。我的pod version是0.28.0。 不过还是具有参考价值 使用CocoaPods 配置自己的CocoaPods库 ##五分钟手把手 在上面的配置自己的CocoaPods库里面。当时只是初步的使用pods。在学习的过程中。很多理解都很浅显。现在终于用了一年多CocoaPods。有点小心得就来记录一下。 github现在每天必看网站。一个是工作需要，另外一个是上面神奇的东西太多太多了。学无止境啊。 使用CocoaPods管理第三方库有时候就会遇到这样的尴尬。好不容易找到了一个心仪的库,却发现CocoaPods里面搜索不到。 怎么办 怎么办 来乖。手把手交你来写hello world。 栗子： XCAsyncTestCase 首先，去把它fork到自己的项目里面去。(什么不会fork？去面壁去) 然后，把fork到自己帐号下的项目clone出来 cd进去 输入 1pod spec create https://github.com/iiiyu/XCAsyncTestCase 接着你会看到 这个很正常，很多项目都没有tag。反正在自己的下面。可以瞎搞。给项目加入一个tag。以便pod能自动识别。 1234567git tag -a 0.0.1 -m \"Tag release 0.0.1”git push —tagsrm -rf XCAsyncTestCase.podspecpod spec create https://github.com/iiiyu/XCAsyncTestCase 接着你会看到 OK。 然后用你自己喜欢的编辑器打开。 1mate XCAsyncTestCase.podspec 接着其实不用怎么改里面的内容 我把注释删掉 作者改成原来的作者。然后需要的源码位置改成正确的 大概就是这样 当然 最重要的是s.source_files这个。你要把你要包含的文件路径找对了。 然后用通配符匹配好了。就OK了。 当然其他项，你看看注释啥的 选择性的填一些。在这里是一个五分钟的hello world。不深入讨论 接着 把修改好的文件push到github上去 12345git add XCAsyncTestCase.podspecgit commit -am \"add XCAsyncTestCase.podspec file”git push 最后，在你项目的Podfile里面加入这个第三方库的地址。 1pod 'XCAsyncTestCase', :git =&gt; 'https://github.com/iiiyu/XCAsyncTestCase.git' 就可以畅快的使用pod install了 五分钟打完收工有木有。很简单直白有木有。 当然这里只是一个hello world。 如果库中有一些高端设置比如要包含资源文件啊。 加入库依赖啊。 配置一些xcconfig。更多内容 请查看越来越好看的官方网站 ##CocoaPods福利时间 以下是我平时使用经常用到的Podfile会用到的一些写法。 福利一首先是有一些库编译时候会有警告。但是作为一个有洁癖的人呢不想看见这些 可以在platform :ios, ‘x.0’的后面加入这句 1inhibit_all_warnings! 这样编译这些第三方库的时候就没有那些烦人的小警告了。 福利二使用福利一是不是很爽呢。但是有一个神库ReactiveCocoa。当你关闭所有警告的时候。它就编译不过了。可急坏了。其实很简单对他单独设置打开编译警告就好了 1pod 'ReactiveCocoa', '~&gt; 2.1.8', :inhibit_warnings =&gt; true 福利三如果你有多个Targets需要pod的库怎么办也很简单。Podfile的头部加入 1link_with ['AAAAA', 'BBBBB'] AAAAA和BBBBB都是你target的名字，这样不同的target都会有pod库了。我主要是用来解决Unit Test需要pod install一些库的问题。当初也是找了老半天才找到。 ##总结CocoaPods很好用。而且一直在进化。我发现我怎么写介绍都只停留在很浅显的基础上。更多更深入的内容需要自己使用了。然后慢慢积累的。总之。不用CocoaPods的Cocoa开发太不潮了。","link":"/2013/12/19/learning-ios-notes-thirty-one/"},{"title":"iOS笔记(33) 格志周年系列之夏令时(一)","text":"本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 开篇扯淡两月没写blog，没羞没皮了。以后作息规律一些，blog更新还是频繁一些。格志在2014年2月11日就整整上线一周年了。2013一年做格志，由于自己的技术实在比较菜。导致从上线的第一天起，整个团队跟着一直打补丁。小的坑就不说了，大的坑有两，一个iCloud + Core Data世界性难题。一个是全球时间问题。这篇blog就用来专门记下时间的坑。中间还有个插曲——格志在三月上线了2.0的全新专门为iOS 7设计的版本。时间问题在去年10月份改完以为对了就没有改过。结果3月9号是3月的第二个周日，美国地区进入夏令时。格志中又再次发生了时间问题，导致日记显示不全。之前开会说过放错不可怕，可怕的是放同样的错误。再次放错以后我都呆住了。那可是我写过测试用例的啊。结果当时一run测试就挂掉了。瞬间脑子蒙掉。然后上周通宵了一天，基本每天到3点把世界时间问题给彻底搞定。（希望是彻底）所以趁着我现在还有印象，记录一下。 国际化我们所以会遇到世界时间的问题主要有几个原因： 格志的定位是一个全球市场的产品 我们团队(真实情况是我是一个土鳖)并没有很国际化的背景 格志是一个颗粒度为天的日记应用（Day One等另外几个比较出名的App其实是一个moment为颗粒度） 格志在设计数据存储的时候用了时间作为日记的唯一标识符号 所以，最初的版本。我是用了一天的00:00:00分来作为日记的时间。 用了这个库 1234https://github.com/erica/NSDate-Extensions// podpod 'NSDate-Extensions', '~&gt; 0.0.1' 里面的这个方法(先贴出来) 12345678- (NSDate *) dateAtStartOfDay{ NSDateComponents *components = [CURRENT_CALENDAR components:DATE_COMPONENTS fromDate:self]; components.hour = 0; components.minute = 0; components.second = 0; return [CURRENT_CALENDAR dateFromComponents:components];} 来获取每天开始的时间。 然后第一个版本我们就这样欢乐开心的上线了。然后iCloud爆大坑。开始填了2个月的iCloud坑和数据修复。在某个时间，一个中国高富帅用户发Email来说，他去泰国旅游的时候，日记都不见了。我才隐约发觉日记的时间有问题！！ 日期出了啥问题？ 待续 小结上周作息实在不规律，现在需要调整一下。本来应该一次性写完发的，但是怕自己懒惰（比如上次的开了头就没有继续，所以我决定每天都写一点就算少一点还是把他发掉）","link":"/2014/03/18/learning-ios-notes-thirty-three/"},{"title":"iOS 学习笔记 (36)  ReactiveCocoa 用 RACSignal 替代 Delegate","text":"本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 开篇扯淡最近又在看 ReactiveCocoa 了（下面用 RAC 来替代 ReactiveCocoa）。虽然依然是 hello world 级别。但是 hello world 也是可以分级别的。这次自我感觉是一个偏向中级的 hello world。 我们先来张图： 在 RAC 的文档和一些介绍 RAC 的 Keynote 资料里面我们可以看到说 RACSignal 可以来替代 Delegate、 Block Callbacks、Target Action、KVO、Notifications。 但是貌似没有一种 hello world 的方式来进行说明如何替代的。 插嘴:在中文 blog 里面见过几个写 RAC 的比较好哒。一个是limboy大大的几篇深入浅出令人叹为观止，李忠大大不但研究透彻了然后还结合自己的实战经验写成很好的文章来分享。 另一个是sunnyxx的Reactive Cocoa Tutorial系列这个系列比较偏向研究 RAC 是如何实现和工作的。 我这个人比较笨，最喜欢写 hello world。那就找时间一个一个来写呗。 写之前 Google 了一下。所以以下内容大量参考:Replacing the Objective-C “Delegate Pattern” with ReactiveCocoa。能看原文就去看看。然后忽略掉以下的 hello world 就好了。 实现功能说明本来想改成 TableView 的。改着改着感觉 TableView 的话。可能会牵扯到 MVVM 的问题。 才能架构出来一个正确的程序结构。而我只想说明简单的写清楚如何替代Delegate。所以相当于一个中文简化版本的 Replacing the Objective-C “Delegate Pattern” with ReactiveCocoa了。 那就跟他一样写搜索把。然后实现过程中发现 iOS 8 用新的 UISearchController 来替代了 UISearchDisplayController 了。 UISearchController Delegate 常规实现一般来说我们会设置protocol. 12self.searchController.searchResultsUpdater = self;self.searchController.delegate = self; 然后去委托的类里面实现相关的方法 123456789101112#pragma mark - UISearchResultsUpdating- (void)updateSearchResultsForSearchController:(UISearchController *)searchController{ if (searchController.searchBar.text.length &gt; 0) { self.searchResults = [self search:searchController.searchBar.text]; } else { self.searchResults = self.searchTexts; } [self.tableView reloadData];} 123456789101112#pragma mark - UISearchControllerDelegate- (void)willPresentSearchController:(UISearchController *)searchController{ self.searching = YES;}- (void)willDismissSearchController:(UISearchController *)searchController{ self.searching = NO; [self.tableView reloadData];} 普通情况下我们就是这样来使用 Delegate 的。 平淡无奇。下面我们来用 RACSignal 的实现方法。 UISearchController Delegate RACSignal 实现第一个要明确的是：我们要做什么。 常规模式根据常规代码来看: 我们需要在每次输入词变化的时候进行搜索。 需要在进入和退出搜索的时候知道当前状态 1对应的就是实现- (void)updateSearchResultsForSearchController:(UISearchController *)searchController 2对应的是实现- (void)willPresentSearchController:(UISearchController )searchController 和 - (void)willDismissSearchController:(UISearchController )searchController。 现在，让我们来转换为 RAC 的思维模式思考问题。 RAC 模式 UI 上需要搜索结果的 NSArray 搜索结果由搜索关键字得来。 每次修改关键字都应该更新搜索结果。 因此我们要想办法吧 UI 上需要的数据和修改关键字这个动作绑定起来。 同理可以很容易想到。我们也需要把当前 UI 是否处于搜索状态跟会改变搜索状态的动作绑定起来。 要怎么绑定呢？ 拥有刚刚 RAC 超过 Hello World 实力的我，想到，我需要构建出来两个RACSignal。 然后进行类似： 12RAC(self, searchResults) = SignalA;RAC(self, searching) = SignalB; 这样的绑定就皆大欢喜了。 主要用到了下面两个 RAC 的方法： rac_signalForSelector:fromProtocol: 这个方法主要是把 protocal 转为一个 Signal 便于使用。值得注意的是这个函数返回的是一个 RACTuple。 这个 RACTuple 包含了 Selector 方法里面所有的参数。这样需要用到的时候主要按照顺序来获取。 rac_liftSelector:withSignalsFromArray: 这个方法它的意思是当传入的 Signals 都至少sendNext过一次，接下来只要其中任意一个signal有了新的内容。就会去触发第一个 selector 参数的方法。 构造两个 Signal 的代码如下 1234567891011121314151617181920212223242526272829303132// UISearchController+RAC.m- (RACSignal *)rac_textSignal{ self.searchResultsUpdater = self; RACSignal *signal = objc_getAssociatedObject(self, _cmd); if (signal != nil) { return signal; } signal = [[self rac_signalForSelector:@selector(updateSearchResultsForSearchController:) fromProtocol:@protocol(UISearchResultsUpdating)] map:^id(RACTuple *tuple) { UISearchController *searchController = tuple.first; return searchController.searchBar.text; }]; objc_setAssociatedObject(self, _cmd, signal, OBJC_ASSOCIATION_RETAIN_NONATOMIC); return signal;}- (RACSignal *)rac_isActiveSignal{ self.delegate = self; RACSignal *signal = objc_getAssociatedObject(self, _cmd); if (signal != nil) return signal; RACSignal *willPresentSearching = [[self rac_signalForSelector:@selector(willPresentSearchController:) fromProtocol:@protocol(UISearchControllerDelegate)] mapReplace:@YES]; RACSignal *willDismissSearching = [[self rac_signalForSelector:@selector(willDismissSearchController:) fromProtocol:@protocol(UISearchControllerDelegate)] mapReplace:@NO]; signal = [RACSignal merge:@[willPresentSearching, willDismissSearching]]; objc_setAssociatedObject(self, _cmd, signal, OBJC_ASSOCIATION_RETAIN_NONATOMIC); return signal;} 最终绑定代码如下： 1234567// RACMasterViewController.m RAC(self, searchResults) = [self rac_liftSelector:@selector(search:) withSignalsFromArray:@[self.searchController.rac_textSignal]]; [self.searchController.rac_textSignal subscribeNext:^(id x) { [self.tableView reloadData]; }]; RAC(self, searching) = [self.searchController rac_isActiveSignal]; 这样我们就写完了一个用 RAC 来替代 Delegate （protocol） 的例子 总结使用 RAC 其实最重要的思维的转变。 这个转变在写代码的时候如果我没有思考的很清楚。 那我写出来就一团乱麻。还是需要多加锻炼 MVVM 的思维。 实例代码已经上传Github 下集预告 用 RACSignal 替代 Block Callbacks。有人会期待么？ 资料 limboy大大 sunnyxx的Reactive Cocoa Tutorial系列 Replacing the Objective-C “Delegate Pattern” with ReactiveCocoa ReactiveCocoa Lessons Learned","link":"/2014/12/26/learning-ios-notes-thirty-six/"},{"title":"iOS笔记(32) UbiquityStoreManager 学习笔记1","text":"本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 开篇扯淡现在都是进入互联网时代，一个互联网的App数据肯定是存在互联网上的。到处都是云，到处都是服务器。如果数据是存储在云端or服务器端。每次数据的读取和修改直接作用于服务器。这样不管你用多少设备，多少平台。数据都能保证是唯一的。但是还有些App需要一些更好的性能和效果的时候往往等不起网络的数据传来传去。这时候需要一些折中的办法来解决这些问题。iCloud就是Apple给出的解决方案。就普通用户来看，iCloud应该是在Apple系中的最优选择。但是从开发者的角度来看iCloud就是个无穷无尽的深渊。 全球有很多开发者致力开发第三方库以便让iCloud能被使用。 UbiquityStoreManager就是其中之一。 UbiquityStoreManagerUbiquityStoreManager是一个core data持久化层的控制器. UbiquityStoreManager在iOS 6时代是使用GPLv3协议。所以好像使用者不是很多。iOS 7 Core Data 关于iCloud引入了新的机制和新API以后UbiquityStoreManager迅速跟进。并且更换了协议使用了Apache v2。所以如果你有iOS 7的App想使用iCloud + Core Data这种hard模式。UbiquityStoreManager是第一个应该推荐的库. UbiquityStoreManager不同于其他解决方案。大部分都是在iCloud上面继续构建一层来保证数据同步的完整一致性。UbiquityStoreManager仅仅是解决了就只单纯使用iCloud就会遇到的问题。比如数据出错了怎么办。从本地数据迁移到iCloud数据。从修改日记来重建数据库等。 UbiquityStoreManager解决的问题 提供在iCloud和本地Store直接切换 在用户没有iCloud store 的时候自动的把local data 合并到iCloud(使用本地数据重建iCloud) 所有与iCloud有联系的事件处理 iCloud帐号删除、iCloud数据删除、本地数据导入、其他设备变换ubiquitous、恢复有错误的transaction logs 其他的一些实用功能：从transaction logs重建cloud store、 从cloud store 重建transaction logs、 删除cloud store、 Ability to nuke the entire cloud container、 把一个store里面全部的entities合并到另外一个store 在iCloud + CoreData的官方解决方案中，对于开发者来说完全的黑箱子操作。难于开发和调试bug。而且经验不足完全会被很多坑拉进泥潭里面。使得开发更本无法进行下去。所以仔细研究UbiquityStoreManager。是我建议踏入iCloud + Core Data开发的必修课。 总结只是我学习中的一点笔记和注释翻译而已。留给自己看看。如果有不对的地方，欢迎指出。","link":"/2013/12/25/learning-ios-notes-thirty-two/"},{"title":"iOS学习笔记(30) Core Data是如何保存的？","text":"本文仅作为个人记录使用，也欢迎在许可协议范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助，您可以使用RSS方式订阅本站，这样您将能在第一时间获取本站信息。 开场扯淡恩 一个月没有写一篇blog了。恩。就这样把。 学习使用Core Data也一年多了。之前以为3个月就可以登堂入室。事实是我图样图森破。到现在我也才勉强hello world而已。 比如这个问题 Core Data是如何保存的。 一直使用MagicalRecord 都被宠习惯了。 直接就调用MR_saveToPersistentStoreAndWait。反正能存进去，也没有太仔细的思考。 恩 最近对Core Data的技能点在进行增加中。所以还是多记录一些。 恰好看见了 DM大神的 blog How Does Core Data Save? 也不算翻译，就是自己写个自己的精简版本看看。 Core Data是如何保存的 当然是NSManagedObjectContext调用save方法的时候。 这时候context里面持有的那些NSManagedObject将会自己调用自己的willSave方法。 NSManagedObjectContextWillSaveNotification发出。 开始验证。这个验证可能是你在data model里面写的。也可以是在NSManagedObject里面代码写的。 验证结束以后数据就合并到NSPersistentStoreCoordinator和NSPersistentStore里面。 如果你在合并的时候更改了数据。这时候会重新验证数据。 这个时候已经把需要验证过的合并数据存到持久化介质当中。 最后NSManagedObjectContextDidSaveNotification这个通知发出。 参考资料How Does Core Data Save?","link":"/2013/12/02/learning-ios-notes-thirty/"},{"title":"iOS笔记 (3)","text":"iOS笔记番外篇开始之前的扯淡反正在等IPad3的发布，就顺手写篇blog。本来觉得这个时候写IOS笔记3还有点过早。因为好像没有太多的干货能拿出来。可是在看了老头用xcode、git来教怎么管理代码的时候，我彻底崩溃了。VS新版没见过，目前Xcode是体验最好的IDE，没有之一。Emacs系列突然觉得没有必要更新的冲动。 虽然我们居住在神奇的天朝，但是我们还是要感谢这个时代。因为科技和人类文明的进步，使得我们可以看到一流名校的课程。就算那个号称天朝最公平的考试失败以后，只要你想学，还是可以学到这个世界上一流的课程。 多媒体的表现力要远远丰富于文字。清楚直观的5分钟视频，可能换成文字描述写一个小时都写不好。所以如果这篇看不懂的话直接看视频吧。（没找到链接） Xcode and Source Code Management (October 7, 2011) - HD 人生是一场冒险。对我来说：活下去，然后活的爽一些。就够了。 补遗笔记二上次忘记写一个很有特色的东西。方法之前的+、-符号。这个其实很简单。在笔记一里面就有： 在ObjC中一个类中的方法有两种类型：实例方法，类方法。实例方法前用(-)号表明,类方法用(+) 可是我这个人对专有名词都他喵的没感觉。比较喜欢通俗易懂的解释。 +的方法，调用的时候，是[类名字 方法] -的方法，调用的时候，是[类实例 方法] 12NSString *str = [[NSString alloc] init];//这个 alloc就是+号定义的[str floatValue]; //这个floatValue就是-号定义的 Git其实，我觉得Git完全有必要单独出来写一篇。因为它太重要太强大了。用了Git以后再也没有想过用其他的版本管理。原因是用的太爽，如果有一天出现了比Git用起来还爽的。我也肯定会用。可是现在only git。 对于Git的中文心得，教程等等。我都自认怎么写都写的不可能有阳志平大哥写的好。所以这里只是告诉你Git是IOS开发必须的技能。你可以通过下面链接来学习 git - 简易指南 Pro Git Git与Github入门资料 如何高效利用GitHub GotGitHub 资料很多，但是如果你不使用的话。看再多的游泳的书，你也学不会游泳。 Xcode编辑魔法首先说一个编辑的小魔法，当你想修改源码中相同一个地方，而不想点xcode的Refactor的话。你可以完全通过键盘来实现 Command + c #copy你想替换成的文本 #选择你要替换的文本 Command + e Command + v #替换了第一个地方 Command + g #到了下一个替换的地方 #重复 Command + v和 Command + g #完成替换 其实这个小技巧你可以再Mac的任意编辑文本处使用。 一些界面说明 看见右边有的文件后面是M有的是A。至今我没有看见哪里说明过这个是什么。其实很简单，通过Git管理你的项目以后，xcode自然能追踪你的文件情况。M是modified的缩写。A自然是add的缩写。（其实在没有用Git的时候xcode也能追逐，估计是跟关闭之前的保存的那一次对比吧） 这几个按钮很有用，具体看视频里面老头的操作。 Editor第一个是单独一个文本编辑，第二个是两个文本不同文本编辑，第三个是同一个文本不同时期对比编辑（这个用Git，然后很牛的） View第一个显示右边的导航，就是文件结构那个。第二个是调试台。第三个是可以拖控件的 Organizer这个功能比较多。暂时就说点过去了可以在里面管理Git的分支各种。 在IOS项目下建立Git管理 老头视频里面是自己建立的，刚刚我看我的所有项目都有git了，暂时不知道是我设置了什么还是默认的。直播开始了。先看直播。","link":"/2012/03/08/learning-ios-notes-three/"},{"title":"iOS笔记(24) 关于使用xCode的Tab来提高开发效率","text":"前言通过Google分析来看blog的访问统计。发现评价阅读时间也就一分钟不到。但是之前都习惯性写长篇大论。这次换一种方式来写blog。尽量写短一些的小一些的题目。使得更新数量上去。 这次我来说说怎么设置Tab来提高在xCode的工作效率。 我是如何使用Tab来提高效率的xCode的Tab是什么诺，就是这一个东西。 使用过各种浏览器的你一定不会陌生。对在xCode里面我们也可以开出多个页面。而且每一个页面的状态是单独保存的。 如何提高效率因为在实际的代码编写过程中，我们可能需要来回的查找和阅读代码。会很自然的在多个文件中跳转编辑。这时候单个编辑页面明显拖累了速度。所以我们需要多个页面来回切换就会很爽。 如上图所示。我习惯性长开着这几个Tab。 UI 如图所示，我们可以在圈起来的地方设置关键词过滤显示的文件这样我的名为UI的Tab就只会显示storyboard。这样改UI点击起来会很方便 Data同理可得这个表情用来显示data model的。 VC显示ViewController的 DebugDebug这个Tab有些特殊。并不是我手动创建的。而且我配置了编译行为出来的。这样每次Run的时候都会跳到这个名为Debug的Tab里面。这样做的原因是，我改了一个地方的代码。运行以后可能在其他地方挂掉了（或者在其他地方打了断点）。然后跟着进去看了看。然后想回到之前改代码的地方就会很麻烦。 这样设置了以后，就没有上述烦恼了。 顺便说一句希望这些对你有所帮助。 顺便说一句：Tab直接的切换可以使用快捷键 Command + Shift + ([, ]) 其实这个快捷键适用于绝大部分有Tab的App。 都可以完成切换功能 再顺便说一句： xCode本身内存消耗很大，开Tab。感觉很是消耗内存。如果内存吃紧的话。应该去升级内存了。不然开多个Tab只会降低工作效率并不会提高。","link":"/2013/06/03/learning-ios-notes-twenty-fort/"},{"title":"iOS学习笔记(25) iCloud(一) 概览","text":"什么是iCloudiCloud是苹果公司提供的云服务的总称。每一个拥有Apple ID的用户都拥有5G大小的空间使用权。用户可以使用iCloud的空间来进行数据的备份，联系人备份，照片备份，应用备份等。好处就是当你有多台设备或者是换新的设备的时候。可以有无差别的体验。 对于开发者来说，iCloud相当于提供了一种官方形式的云端存储形式。帮助你的App实现所谓理想的状态。不论用户在什么设备打开App。 里面的数据，设置，形状，大小。都跟他上次打开的一模一样。这样你的App会给你的用户非一般的体验。 开发慎用iCloud上一段说了iCloud的优点，其实是接近意淫中的理想状态。我以近一年的血泪史告诫，初级开发者，应该避免使用iCloud。中高级开发者视项目规划内容酌情使用。如果能有其他方案替代iCloud，建议优先使用其他方案。 初级开发者: iCloud的三种存储方式 Key-Value， Documents， Core Data都是在之前已有的框架上进行扩展的高级接口。换言之，你应该先具备了这三种技术的基本知识再开始考虑学习iCloud。 iCloud + Key-Value对应的基础是NSUserDefaults。 iCloud + Documents对应的基础是使用文档进行数据存储(NSFileManager,NSFileCoordinator,NSFileWrapper,NSCoding等一系列持久化数据存储到文件的问题). iCloud + Core Data的对应基础就是Core Data。本来是强烈建议如果没有这些基础的人不要直接来学习iCloud的。但是谁都是一步一步走过来的，如果要用到iCloud的某一种方式。建议先把基础的持久化方式原理弄懂了，在看iCloud的部分。不然学习门槛的过高，会使得进度无法按时推进。 中高级开发者：如果是已经用过Key-Value，Documents，Core Data的。应该会很快能明白iCloud的原理。 而进行开发。但是值得注意的是，iCloud的使用和调试会非常的消耗时间和精力。并且和你的当前网络状态息息相关。然后会出现各种诡异的情况。这个时候你都需要淡定很超级的耐心。去找到这些坑，然后慢慢的积累经验去绕过这些坑。（在这里先挖坑，后面在慢慢写我的一些使用经验） 为什么要用iCloud既然iCloud这么多坑。为什么还要使用iCloud进行开发呢？这个问题最近半年的每周的某些时候我都会这样的问自己。 个人觉得最重要的是: 在需要数据统一的服务里面，几乎所有的第三方服务和自己搭建服务器为了识别唯一的用户。都需要进行一次注册流程。这是不可避免的。但是把注册用户的流程接入App里面。对我来说不能第一次打开就畅快的使用App是难以忍受的。iCloud由于是基于Apple ID的，相当于一个正常的用户来说是必备的。所以，使用iCloud技术可以避免注册用户流程。和App登入功能。即开即用的体验会大大提高。 (注意，在这里我说的是几乎所有的第三方服务不包括Dropbox。Dropbox新的Datastore API和本身Dropbox的普及率感觉会比注册要好一些。继续挖坑以后填) 其他的原因我觉得不是很重要但是还是列出来： iCloud是Apple的服务。好歹是市值4000亿刀的公司。理论上来说比小公司靠谱一些把。 iCloud是Apple自家的服务。App里面如果使用到了iCloud服务。理论上来说会被官方推荐的机率大了一些 如果以后做Apple全平台(iOS,Mac)自然对接起来应该方便一些。(感觉这个是YY) 除了iCloud还能用啥Dropbox第一个顺位的自然是Dropbox. Dropbox不仅仅是一个无处不在的U盘。它还可以变成你App的数据存储端。而且新的Datastore API也显示着Dropbox会大力的发展成为App的数据端的决心。 ParseParse的顺位也相当高。 原因在于，Parse的服务不仅仅有Data。还具备推送、社交分享等一系列高端大气上档次的功能。而且它的SDK覆盖了所有主流平台(iOS OSX Android JS WP8 W8 .NET)。更加重要的是，它在一定数据和请求量上是免费的。如果你的用户做到超过它的免费额度。我觉得这个时候你也就能轻松负担起它的付费版了。顺便说一句Parse应该是被Facebook收了。所以，应该对他们充满信心。 avoscloud推荐avoscloud的理由很简单。这是好基友Summer参与开发的。 作为好基友肯定要鼎力推荐一下。 AVOS看起来是国际高端大气上档次的大厂。但是这个cloud，应该是完全由在天朝的团队开发的(个人猜想). 为什么要推荐？起码人家的文档是中文的，阅读起来没障碍。 有问题了，还可以直接去weibo吐槽也不当心人家看不懂好吧。 helios当然如果你喜欢自己搞定一切。那你还是可以自己搭建自己的服务器的。如果你需要一个类似的参考Mattt大神的helios你不应该错过。如果你写iOS or Mac OS X开发超过三月，还不知道Mattt大神。那你应该恶补一下圈子里面的知识了。Mattt大神就是主导AFNetworking的那个啊。 不说围绕着AFNetworking衍生出来的庞大类库。 当一个NSHipster就造福一方啊。 总结 &amp;&amp; 瞎扯蛋好久好久没有更新Blog。鄙视一下自己懒的不成样子了。其实好几次想写点扯淡的东西。但是总觉得技术Blog就应该有个技术Blog的样子。不要总是在扯淡。扯着扯着就变成IT评论家的感觉。今天黑这个，明天黑那个的。不好，应该自己踏踏实实的静心学习。最近就是因为心太乱了，导致各种问题。不过期待能把这个iCloud的系列坑给填好。也能算给自己学习了一年iCloud的使用做出一个总结不至于白弄了一年。 最后嫌弃我写的太慢的同学。那就给一个入口地址：从这里加油把","link":"/2013/08/19/learning-ios-notes-twenty-five/"},{"title":"iOS学习笔记(29) 爱不释手的ReactiveCocoa之UIButton","text":"开场扯淡ReactiveCocoa的迭代速度相当快，一群富有才华和激情的人们在不断的进化ReactiveCocoa。欣欣向荣的景象啊。我这种hello world级别的也就只能使用他们的劳动成果了。上篇blog的时候我还在用1.9.x的版本 现在我已经全面转向2.x了。值得注意的是霓虹友人提交的cocoapods上ReactiveCocoa 2.1 版本我无法编译通过。目前我使用的还是2.0的版本。 介于一个月没有更新blog的速度，这次来写少一点的内容。 传统的UIButton Target Action 方式之前我们使用UIButton的点击方法一般有两种。一种是直接从xib里面拖一个IBAction出来在里面写代码。 另外一种是代码创建的 比如这样 12UIButton *myButton = [[UIButton alloc] init...];[myButton addTarget:something action:@selector(myAction) forControlEvents:UIControlEventTouchUpInside]; 然后在下面写一个myAction的方法来进行操作。 这样对我来说存在两个问题： button对应的方法分开了。在阅读代码的时候，当我想知道这个button对应的方法或者反过来action方法对应的button。通常需要跳转一次以上才能知道。(也许是我的阅读代码习惯比较原始) 我在action方法里面如果需要引用一个变量的时候，无法使用局部变量。通常就需要把这个资源设计为一个property。尽管这个资源或者变量只是在action里面调用一次。(这个也许是我写代码的问题) 这两个可能在我遇见ReactiveCocoa都不能叫问题。但是在ReactiveCocoa里面我发现了更加优美的解决方法。好开心。 ReactiveCocoa方式的UIButton由于ReactiveCocoa高深的知识点，我也弄不太清楚。下面我只是说明怎么用的hello world级别。更多内容请阅读github上的项目主页。 如果使用xib。只需拖一个IBOutlet的property出来。比如这样 1@property (weak, nonatomic) IBOutlet UIButton *xibButton; 12345NSString *helloWorld = @\"hello world!!!\";self.xibButton.rac_command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) { NSLog(@\"%@\", helloWorld); return [RACSignal empty];}]; 如果是代码创建一切照旧 123456789NSString *helloWorld = @\"hello world!!!\";UIButton *myButton = [UIButton buttonWithType:UIButtonTypeSystem];myButton.frame = CGRectMake(0, 0, 100, 50);[myButton setTitle:@\"Say\" forState:UIControlStateNormal];[self.view addSubview:myButton];myButton.rac_command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) { NSLog(@\"%@\", helloWorld); return [RACSignal empty];}]; 这些代码我一般写在viewDidLoad方法里面。当然你可以在正确的地方使用他们。运行试试。哇。魔法一般。完全解决我在传统的UIButton遇到的两个问题。 总结嗯嗯，这种小主题的blog写起来轻松愉快。大概40分钟就可以完成。以后要多多写小主题。这样跟写程序一样，化繁为简。这次就少扯淡了。期待我的下篇blog。啊哈哈","link":"/2013/10/15/learning-ios-notes-twenty-nine/"},{"title":"iOS学习笔记(26) iCloud(二) 准备工作","text":"开发支持iCloud的上半部分前期准备 需要申请一个开发者的帐号。理论上iOS和Mac OSX的都OK。考虑到我只有iOS的情况下，我的文章里面的例子默认只是iOS的。 你需要一台iOS设备，并且iOS版本必须大于等于5.最好大于等于6. 最最好大于等于7。 Xcode不用说至少是MAS里面最新的 然后去建立App Bundle ID的页面去把iCloud支持打开。 bundle id需要生成带你测试设备的证书 (PS:截图太累了 换成文章描述) 这样才能算iCloud的前期工作做完了一半。 以下涉及到NDA内容请自行屏蔽 据说Xcode5里面支持直接开启iCloud支持，推送服务支持等。不用去登录网页了。 据说Xcode5支持iCloud调试了不需要真机了。可是特么只是支持iCloud Key-Value。Document和Core Data还是需要你一台强力的真机。 (详细和剩下的大家自行脑补) 开发支持iCloud的下半部分前期准备 建立一个跟上部分bundle id一样的工程项目 然后在工程里面把entitlements勾上以后。 支持key-value stroe把勾选上 支持Document和Core Data要添加ubiquity containers 到这里，总算是把准备工作弄好了。每一个支持iCloud的App。都必须经过上面的步骤。不可跳过直接去写代码。切记切记。 开发iCloud基本思维 iCloud是网络远端的数据存储服务。最终目的是确保所有设备上的所有数据一致性。 使用iCloud的机制不是纯网络服务。简单的说就是在没有网络的情况下。你的App应该是可以畅通无阻的运行，并且没有缺失功能。iCloud存储的是数据的源头，App里面应该会有对应的缓存确保这样的机制。所以有多少台设备，就有多少份缓存的数据。 缓存数据的份数多了，为了保持数据的一致性。需要同步机制来保持更新，这时候不可避免的会产生数据冲突。就需要解决冲突。 所以，只要是使用了iCloud。不论那种形式。我们都必须面对下面的几种情况并且需要对这些情况进行响应的处理： 何时开启iCloud同步服务 在App内部关闭了iCloud以后，App的应对措施。 在App外部关闭了iCloud以后，App的应对措施。 开启iCloud以后，iCloud数据和本地数据之间的处理。 开启iCloud以后，正在同步数据时，UI的应对措施。 使用iCloud以后，当数据完成更新的时候。UI的应对措施。 iCloud数据冲突时候App的处理。 以上是临时能回忆起来的一些需要处理的情况。真实情况可能要复杂的多。","link":"/2013/08/26/learning-ios-notes-twenty-six/"},{"title":"iOS学习笔记(27) iCloud(三) key-Value Stroe","text":"什么是NSUserDefaultsNSUserDefaults的持久化本体是一个plist.内存单例是一个操作类似NSDictionary的类。 而NSUserDefaults的出现我想是因为在每一个程序当中。我们都会设定一些选项。比如桌面壁纸、声音大小、提醒日期等，我们希望就算App关闭以后。我们再次打开的时候还在的东西。但是它并不适合存储App中关键的内容和用户自己产生的大量数据。 大量数据应该用更加合理的方式去做持久化(Document or Core Data). NSUserDefaults简单代码讲解使用NSUserDefaults其实巨简单。 大概步骤如下: 首先通过一个单例获得持久化plist的内存映射。 然后就可以用这个单例的实例类进行读写操作。 读当然没啥问题，但是写了的话这时候只是操作了在内存里面的这个单例实例。需要做持久化的动作。为什么这个动作要自己来做呢。我想是持久化都是进行IO操作。而IO操作其实很多时候就是性能的瓶颈所在。我们可能很短的时间内一次性操作很多次NSUserDefaults。这样就只用在结束的时候保存一次。IO操作就很少。反之如果每次写NSUserDefaults的时候都去做持久化。那刚刚的情况就会在很短的时间内操作多次IO。这是应该避免的。 1234567891011121314151617// 首先把数据从plist里面读到内存里面的单例来NSUserDefaults *standardDefaults = [NSUserDefaults standardUserDefaults];// 进行增加or修改操作[standardDefaults setObject:@\"a123456789\" forKey:@\"userID\"];[standardDefaults setInteger:24 forKey:@\"age\"];[standardDefaults setBool:YES forKey:@\"isLogin\"];// 删除操作[standardDefaults removeObjectForKey:@\"debts\"];// 从内存里面写入plist进行持久化[standardDefaults synchronize];// 读取操作NSString *userID = [standardDefaults stringForKey:@\"userID\"];BOOL isLogin = [standardDefaults boolForKey:@\"isLogin\"]; 当然还有现代一点的写法。下面两种都是一个效果 1234567891011// 常见方法NSUserDefaults *standardDefaults = [NSUserDefaults standardUserDefaults];if ([standardDefaults stringForKey:@\"favoriteColor\"] == nil) {[standardDefaults setObject:@\"Green\" forKey:@\"favoriteColor\"];[standardDefaults synchronize];}// 现代高端上档次方法NSUserDefaults *standardDefaults = [NSUserDefaults standardUserDefaults];[standardDefaults registerDefaults:@{@\"favoriteColor\": @\"Green\"}];[standardDefaults synchronize]; iCloud的Key-Value简单的，可以把iCloud的key-value当作一个在云端的NSUserDefaults。 我的用法是，App的Setting最终设置决定的还是NSUserDefaults。iCloud的Key-Value作为数据源来对NSUserDefaults进行修改。这样的优点在于，就算iCloud关闭或者iCloud的数据没有同步回来。你的App依然可以正常的工作和运行。 1NSUserDefaults *standardDefaults = [NSUserDefaults standardUserDefaults]; 对应 1NSUbiquitousKeyValueStore* store = [NSUbiquitousKeyValueStore defaultStore]; 其他操作跟NSUserDefaults一样一样的。 只有一个值得注意的是NSUbiquitousKeyValueStore需要去监听NSUbiquitousKeyValueStoreDidChangeExternallyNotification事件。就可以知道NSUbiquitousKeyValueStore是否已经同步更新完成。 123456NSUbiquitousKeyValueStore* store = [NSUbiquitousKeyValueStore defaultStore];[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(updateKVStoreItems:) name:NSUbiquitousKeyValueStoreDidChangeExternallyNotification object:store];[store synchronize]; 然后实现updateKVStoreItems:方法 12345678910111213141516171819202122232425262728- (void)updateKVStoreItems:(NSNotification*)notification { // Get the list of keys that changed. NSDictionary* userInfo = [notification userInfo]; NSNumber* reasonForChange = [userInfo objectForKey:NSUbiquitousKeyValueStoreChangeReasonKey]; NSInteger reason = -1; // If a reason could not be determined, do not update anything. if (!reasonForChange) return; // Update only for changes from the server. reason = [reasonForChange integerValue]; if ((reason == NSUbiquitousKeyValueStoreServerChange) || (reason == NSUbiquitousKeyValueStoreInitialSyncChange)) { // If something is changing externally, get the changes // and update the corresponding keys locally. NSArray* changedKeys = [userInfo objectForKey:NSUbiquitousKeyValueStoreChangedKeysKey]; NSUbiquitousKeyValueStore* store = [NSUbiquitousKeyValueStore defaultStore]; NSUserDefaults* userDefaults = [NSUserDefaults standardUserDefaults]; // This loop assumes you are using the same key names in both // the user defaults database and the iCloud key-value store for (NSString* key in changedKeys) { id value = [store objectForKey:key]; [userDefaults setObject:value forKey:key]; } }} 超级简单吧。 第三方库推荐当然有大神写的第三方库。并且实现了NSUserDefaults白名单功能。因为可能你存在NSUserDefaults里面的东西不想要也不需要全部同步到NSUbiquitousKeyValueStore上去把。 对了忘记说一点NSUbiquitousKeyValueStore可是有大小和条目限制的。你不要把他当作无穷无尽的东西来用。具体限制是最大空间1 MB。 最多1024个key。记住不要拿来当作主要数据存储哦。 MK大神应该还是如雷贯耳的把。 不知道么。 MKNetworkKit是他写的。还不知道么。iOS 6 Programming Pushing the Limits: Advanced Application Development for Apple iPhone, iPad and iPod Touch 可是他写的哦。我和我的小伙伴都从MK大神的书里面学到很多不错的东西 MKiCloudSync DDiCloudSync FTiCloudSync 总结参考资料： Preferences and Settings Programming Guide NSUserDefaults (plist) 筆記 Back to Basics: Forgotten NSUserDefaults Synchronizing iPhone iOS 5 Key-Value Data using iCloud Sync Preference Data With iCloud Beginning iCloud in iOS 5 Tutorial Part 1","link":"/2013/09/02/learning-ios-notes-twenty-seven/"},{"title":"iOS笔记(22) CoreData (四) 监听NSFetchedResultsController","text":"CoreData (四)监听NSFetchedResultsController之前说过, NSFetchedResultsController是有两个重要的功能。 第一:NSFetchedResultsController是作用在Core Data上的,通过NSFetchRequest来查询Core Data里面的数据.可以返回按照组分好的数据.这样便于UITableView来显示. 第二:但Model改变的时候NSFetchedResultsController能及时的发出通知.准确的说,应该是当NSManagedObjectContext发生改变的时候,NSFetchedResultsController能知道这些变化,然后发出通知出来.以便UITableview能及时的更新. 上一篇写了第一点. 现在写第二点. 背景如果在数据改变了的时候,我们用UITableView reload. 整个UITableView的数据确实能保持最新的情况. 但是问题是这样做的效率很低. 更希望的情况是,我哪一条数据增加,修改,删除. 就对应着UITableView里面的那一条数据在UI上增加,修改,删除.这样效率会有很大的提升. 直接操作首先是用Delegate来进行UITableView的改变. 第一个方法,告诉UITableView数据要开始更新了,你UITableView赶紧准备好更新. 1234- (void)controllerWillChangeContent:(NSFetchedResultsController *)controller{ [[self tableView] beginUpdates];} 当然有开始就有结束,下面的方法就是告诉UITableView结束更新. 1234- (void)controllerDidChangeContent:(NSFetchedResultsController *)controller{ [[self tableView] endUpdates];} 这两个方法一看命名规则就能看出来是一个Delegate.在NSFetchedResultsController将要变换的时候,我们开启UITableView的编辑,然后在NSFetchedResultsController已经改变结束的时候结束UITableView的编辑.思维上自然而然,有始有终. 接下来我们要在begin和end之间对tableview做出改变. 改变section的方法. 12345678910111213141516171819202122- (void)controller:(NSFetchedResultsController *)controller didChangeSection:(id &lt;NSFetchedResultsSectionInfo&gt;)sectionInfo atIndex:(NSUInteger)sectionIndex forChangeType:(NSFetchedResultsChangeType)type{ NSIndexSet *indexSet = [NSIndexSet indexSetWithIndex:sectionIndex]; switch(type) { case NSFetchedResultsChangeInsert: { [[self tableView] insertSections:indexSet withRowAnimation:UITableViewRowAnimationFade]; break; } case NSFetchedResultsChangeDelete: { [[self tableView] deleteSections:indexSet withRowAnimation:UITableViewRowAnimationFade]; break; } }} 这个方法是在section改变的时候调用.改变类型支持两种NSFetchedResultsChangeInsert和NSFetchedResultsChangeDelete..这样我们能操作UITableView里面section变化了. 接下来的方法是改变cell内容的. 1234567891011121314151617181920212223242526272829- (void)controller:(NSFetchedResultsController *)controller didChangeObject:(id)anObject atIndexPath:(NSIndexPath *)indexPath forChangeType:(NSFetchedResultsChangeType)type newIndexPath:(NSIndexPath *)newIndexPath{ NSArray *newArray = [NSArray arrayWithObject:newIndexPath]; NSArray *oldArray = [NSArray arrayWithObject:indexPath]; switch(type) { case NSFetchedResultsChangeInsert: [[self tableView] insertRowsAtIndexPaths:newArray withRowAnimation:UITableViewRowAnimationFade]; break; case NSFetchedResultsChangeDelete: [[self tableView] deleteRowsAtIndexPaths:oldArray withRowAnimation:UITableViewRowAnimationFade]; break; case NSFetchedResultsChangeUpdate: { UITableViewCell *cell = nil; NSManagedObject *object = nil; cell = [[self tableView] cellForRowAtIndexPath:indexPath]; object = [[self fetchedResultsController] objectAtIndexPath:indexPath]; [[cell textLabel] setText:[object valueForKey:@\"name\"]]; break; } case NSFetchedResultsChangeMove: [[self tableView] deleteRowsAtIndexPaths:oldArray withRowAnimation:UITableViewRowAnimationFade]; [[self tableView] insertRowsAtIndexPaths:newArray withRowAnimation:UITableViewRowAnimationFade]; break; }} 在这个方法里面我们可以增删改Cell的.并且可以有动画. NSFetchedResultsController的原理上面我们已经可以无痛的使用NSFetchedResultsController了。而且各种数据都可以自动更新，但是它是一个什么原理呢？ NSFetchedResultsController的核心其实是作为一个观察者去监听NSManagedObjectContext的通知。当NSManagedObjectContext发生改变的时候NSFetchedResultsController就知道了变化。所以，我们初始化一个NSFetchedResultsController的时候，也就监听了对应的NSManagedObjectContext的通知。具体的是三个通知。 NSManagedObjectContextObjectsDidChangeNotification NSManagedObjectContextWillSaveNotification NSManagedObjectContextDidSaveNotification 其实看名字都可以猜测一些他们的具体发出通知的时机。 NSManagedObjectContextObjectsDidChangeNotification当任何一个Object中的任何属性有改变的时候，会发出此通知。然后NSFetchedResultsController会去用设置好的NSFetchRequest查处结果进行参数传递。当这些改变发送的时候，我们就只用在 -controller: didChangeObject: atIndexPath: forChangeType: newIndexPath:判断改变类型是 NSFetchedResultsChangeUpdate或者 NSFetchedResultsChangeMove就可以做相应的数据到UI的变更操作了。 ####NSManagedObjectContextWillSaveNotification 这个通知是在删除Object的情况下。 这时候可能删除的是section。用-controller: didChangeSection: atIndex: forChangeType:。 如果只是一个Object的删除。就用-controller: didChangeObject: atIndexPath: forChangeType: newIndexPath:。 类型都是NSFetchedResultsChangeDelete. NSManagedObjectContextDidSaveNotification这个通知对应的delegate方法就是-controller: didChangeSection: atIndex: forChangeType: 和 -controller: didChangeObject: atIndexPath: forChangeType: newIndexPath:。 了解了NSFetchedResultsController的原理。事实上自己就可以写NSFetchedResultsController了。 事实上，这篇blog写的确实很糟糕。 而且看日期已经写了20多天了。这样的拖沓让我很不开心。 所以我决定快速的结束这篇blog。 以后就算写的糟糕也不应该拖沓的。","link":"/2013/04/29/learning-ios-notes-twenty-two/"},{"title":"新的开始","text":"序离上一次更新Blog已经过去了17天。这17天里面发生了很多事情。简单说来就是我离开了东莞来到了厦门。然后自己对自己偷懒，没有写blog。 离职一年前的这个时候，我满怀梦想。准备了足足一年。只想去一个公司，做一件事情。推掉了其他所有的offer。只为自己的梦想。现在回想起来跟六年前报考学校的时候一样。一开始只填了一个大学，一个专业。也骗自己说为自己的梦想。现实是残酷的，天朝的现实更是如此。把当初的梦想摔的稀烂，在时间的流逝下。做事情渐渐变的没有激情。我企图改变一些什么，可就像当初那样。改变的力量永远握在了别人的手里。所以，我要让自己变强。能保护关心我的人。改变自己，变的更强。 当有了这个想法之后，每天上班恍惚无神，觉得在浪费生命。这时候，家里传来了一些变动的消息，使我决定马上辞职。 3月30日我提出辞职报告。4月1日我便办完了所有的交接正式离职。 北上离职是我突然的决定，只是知道自己要转iOS。但是iOS只有一个月业余学习基础。所以，当时决定去北京找老闷，自己先闭关一个月。做出一个上架的App，然后再去找工作。所以那几天一直联系老闷房子的问题。定下了去北京的时间，买好了去帝都的机票。然后在东莞办理公积金。（因为遇到了清明放假~~囧） 厦门在清明的时候，我突然收到一条留言，说厦门怎么样。要不来试试。我点开一看。居然是在v2ex上看见过的。当初就觉得不错。只是一是觉得自己很菜，无法到达要求。二来已经决定去北京。所以觉得可能行不大。所以就也只是看看而已。然后我给kevin(我现任boss)回了一封邮件，同时也附带了简历。然后加了QQ聊了一会。kevin就跟我说，要不来趟厦门当面谈谈，双方都有底才好决定。我又很纠结了，我去帝都的票都买了。各种为难的时候，kevin说要不就当来旅游了。他报销路费和住宿。都这么爽快了，立马退了帝都的票。去厦门。 sumi到了厦门先去看了工作室。是那种三层老房子改造的。楼下卖古董。二楼就是工作室，虽然不大，看上去蛮整洁。然后kevin说了sumi现阶段做的东西和以后要做的东西。谈了一下互联网。回宾馆以后我很挣扎啊，sumi的状态就是我理想中我想加入的公司99%的再现。除了一点，远离帝都。而且kevin的身上有太多值得我去学习的东西。然后，我问了萌小萌，萌小萌她说支持我。然后我们苦逼的继续异地3年半。我就决定再博一次——光荣的成为了sumi工作室的试用员工。我留在了厦门。 sumi人现在很少，地方也不大。而且在建设期。每当有一件新器械来到工作室的时候，我们都自己动手去摆放它的位置。调整整个工作室的布局。这样有一种家的味道。结合厦门整个城市的节奏。我感觉我在厦门很多年了。 总结这篇又算是一次吐槽吧。清明时候弄blog，不知怎么弄丢了一些评论，对于弄丢的评论，我深表歉意。然后，我有点不敢继续写iOS的笔记。因为我学的越多，看到的越多。就觉得自己的境界远远不够。怕写出来丢人。(说出来又觉得是自己的借口。)","link":"/2012/04/20/new-beginning/"},{"title":"iOS笔记 (2)","text":"此笔记是观看斯坦福的IOS开发课程和自己思考以后的产物，如果有所偏差，还望指导更正。 iOS的MVC初级代码说明上次说到MVC模式。那些都是理论。真正离写代码终究还是很大差距。特别是Xcode4 IOS5以后，变化很大，中文资料几乎全部过时。经过反复看了斯坦福老头的课程。终于有所顿悟。记录下来。 斯坦福老头的课程前面12课都没有说道model。全部是view和controller。我也只是看到12课而已。所以现在只讨论IOS5开发中的view和controller。 IOS5中，我们可以看到一个叫storyboard的文件。这个文件就是view。或者说是view的载体。UIKit上所有的控件都可以往上面拖。这里我简单的把storyboard以及带UI前缀的类都统一看成view。view就是再ios设备上你能看见的整个屏幕。 在最简单的例子里面，我们可以看到一对叫XXXViewController.h XXXViewController.m的文件。他们就是一个Controller类。 现在回忆一下view和controller的关系 controller一直叫唤狗腿子view，叫view干啥view就干啥。某天，view出事情了，这时候view想在出事情的时候通知一下controller主子。controller主子也不是没有人性，在controller设置一个target。这时候要是出现了什么事情view这个狗腿子要发一个action给主子controller就好了。有时候view狗腿子要和主子controller步调保持一致。这个时候要怎么做呢。在controller里面设置view狗腿的delegate（代表）这个delegate就通过一个protocol来设置 在老头的视频教学里面我们可以看到。比如一个UILabel拖到storyboard上面的时候，这个UILabel仅仅是一个view，它和controller还没有产生任何关系。此时我们的主子controller要知道他有了一个狗腿UILabel这个view要怎么办呢。我们就按着Ctrl点击UILabel拖入XXXViewController.h文件里面，形成一个outlet。 1@property (weak, nonatomic) IBOutlet UILabel *display; 这里我理解为狗腿子跟主子报告了一声，说hi 我在这里。 这时候狗腿子说，hi 主子。我出了个事情要跟你汇报。就是视频里面按住Ctrl然后点UI控件会出来一个框里面有很多事件。然后点点击事件不放向XXXViewController.m文件里面拖，就会形成一个Action。 1234- (IBAction)digitPressed:(UIButton *)sender { ...} 这就是狗腿出什么样的事情通知主子的地方。 一些小细节上的感悟ARC和strong、weak新的IOS5引入了ARC（Automatic Referencing Counting）机制。当然，你可以在创建项目的时候不选择，或者再项目创建以后关闭它来手动释放内存。 可惜我直接是从IOS5开始学习，而且不喜欢旧的东西。所以坚决使用ARC和storyboard。而且再内存管理上，我觉得编译器比人靠谱多了。当然我也是初学IOS。理解上可能有错误，欢迎指导。 窃以为使用ARC，一开始接触到的是： strong weak 在我的记录中老头是这样定义的： Strong and weak are descriptions or attributes parentheses.Strong keep it in the heap. Keep it in heap until i stop pointing to it.Weak keep this as long as someone else point to it strongly. 值得注意的是 Strong and weak. This is not garbage collection.This is refernce counting done automatically for you. 大概就是strong声明的东西是放到内存堆里面,它在我停止指向它之前都一直会在内存堆里面，引用记数也不会为0（猜测）。weak呢，则是只要没有指向它的东西时候，引用记数就为0了。然后呢，他们都只管理引用记数这个一亩三分田。至于垃圾回收这种工作，是不该他们管理的。 声明初始化类一句话: alloc后面永远跟着init 123[[CalculatorBrain alloc] init];[[NSMutableArray alloc] init]... 面向对象的封装小时候还在用过几天java写web的时候，很纳闷为什么每一个属性都要写get、set方法。直到现在才慢慢明白这是封装。封装的好处。 在IOS5编程里面。通常是用@property来声明属性，然后使用@synthesize来默认使用get、set方法。当然，再objective-c里面可以重写get、set方法。而且我觉得@property和@synthesize应该像alloc和init一样配套使用。 1234@property (nonatomic, strong) NSMutableArray *operandStack;@synthesize operandStack = _operandStack; 编译器的强大不管是ARC还是后面的get、set方法。都是再编译的时候编辑器加上去的。（猜测）然后各种听说Apple为了让App再IOS跑的更好更流畅。一直再不停的优化llvm。这也是搭载Android的设备硬件远超过IOS设备的情况下还是没有IOS用着爽的底层原因之一吧。 所以，我觉得应该百分百相信编译器。如果出错了。肯定是程序写的有问题。","link":"/2012/03/05/learning-ios-notes-two/"},{"title":"Mac笔记 (1)","text":"ssh远程登录Mac OS X序近一年抱了Apple大腿之后，各种表弟、师兄、朋友陆续也开始抱Apple大腿。难免遇到各种问题，这个时候在QQ交流效率低下，简直不可忍受。也不知大腾讯啥时候支持一下QQ for Mac的远程协助。这样有时候也可以帮助一下在家的老爸老妈解决一些PC上的问题。大神们绕道无鄙视。OS X乃纯Unix血统。教科书上都写了*nix系统可以ssh登录过去搞定一切。就想着可以用ssh来解决问题。无奈网络基础确实是挂课的水平曾经尝试过一次没有成功。这次又再次遇到远程协助的问题就好好Google了一次。研究了好一会儿终于搞定，在此记录。 参考资料How To Enable SSH on Your Mac 开始打怪环境 一台低端D-Link的无线路由用PPoE上网方式 一台低端Macbook pro安装OS X 10.8.3 设置你的Mac在局域网的IP为固定IP这一步参考资料上是有的。应该也是必须的。有两种设置方法，一种是参考资料上写的那种在OS X里面设置 我的是直接在路由里面设置的。不同路由不一样，请自行处理 在路由里面设置转发端口和规则在参考资料里面用的是Airport。给我找了一晚上设置界面没有找到。网络知识匮乏的后果阿。后来仔细阅读了一下觉得应该在自己的路由里面设置的。尝试了一下果然如此。 原图 我设置的真相 注意的一点是IP地址填写的是你刚刚设置自己的固定IP地址。端口两个都是22，因为ssh用的是22端口。 OS X上打开SSH Share其实很简单 打完收工测试， 我连上我的vps 然后在vps上连接我的mac 总结基础差害死人阿，通过这些小事情。证明了我还有很多需要学习的地方。 厦门，晚安。睡觉，又过12点了。","link":"/2013/03/19/learning-mac-notes-one/"},{"title":"读书笔记 「疯传」","text":"本文仅作为个人学习记录使用，也欢迎在许可协议范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助，您可以使用RSS方式订阅本站，这样您将能在第一时间获取本站信息。 开篇扯淡连续三年了，我都只有1月有写过读书笔记。今年又是如此。我只能为自己找个台阶下。懒癌末期患者，请这个世界多给一点点宽容。 记不得上次看完一本书是什么时候了，最近一年来如果一本书看了超过24小时。那我是绝对的看不完。 能看完的都是花了一个通宵就看了。 对了，元旦在动车上重新看了一下修摩托车。 那本书看了2年了，断断续续的。就没有看完过。 疯传病毒式传播开头和结尾都说了一个事情。就是近年来出现了一些爆炸性的传播事件和产品。他们的传播方式都是类似病毒的传播方式。 来来来科普一下病毒。病毒营销 而整本书就是在说，要构建一次病毒营销需要怎么做。并且有一些实验结果和真实世界的案例来支撑他要表达的理论。 六条原则 SETPPS疯传的主体主要围绕着下面六条原则在进行表述。 社交货币我们会共享那些让我们显得更优秀的事情。 诱因顶尖的记忆，风口浪尖的提醒。 情绪当我们关心时，我们回去共享。 公共性构建可视的、正面的事物。 实用价值如果有用，人们会情不自禁的共享。 故事以闲聊为幌子的信息传播 以上大概就是这本30块。240页的精华终结内容。 自己的思考（下面是吐槽时间）人其实吧，我觉得。除了一些探索宇宙奥秘或者探索其他普通人感觉没啥用的科学领域。这个世界的绝大部分人类。都是在研究人。 我开个馆子吧。 要研究人喜欢吃啥。我卖个衣服吧。要研究人喜欢穿啥。我想当个总统吧。要研究把其他人的选票搞过来。我想当升个官吧。要研究领导的喜好。我想做个 App 吧。要研究最近的人缺啥东西。我想拍个电视剧吧。要研究这人体的胸要怎么才能不在摄像范围内。 「疯传」通篇读下来。无非就是人性二字。 我思考的六条原则社交货币人是社交动物。社交是人的一部分。人并不能在这个世界上单独存在。所以，病毒营销的基石就是说。人终归要交流的。但你在交流的时候，你需要一些素材。这些素材用来满足你的虚荣心，荣誉感。让你在社交中显得与众不同。显的更加优秀。 这个道理对于从小喜欢看动物世界的我来说非常容易理解。这是天性。是一种繁殖的本能。把自己突出于周围的同类。可以获得更加优秀的交配对象。从而产下优良的后代。这种天性我估摸着是写到 DNA 里面的。所以你可以看到都是晒美食、晒豪车、晒出国旅游。 在我看来都是基因里面在说：“hi，我是个强壮又富有魅力的异性哦。来一起啪啪啪吧” 扯远了。拉回来，作者提出了社交货币（Social Currency）这种概念是什么意思呢。其实还是很好理解的。货币用来干嘛？交换嘛。那社交货币也是用来交换使用的。货币还具备了流通性。所以作者的这个提法我认为是恰到好处的。 所以这条原则其实就是说。要传播的基石。首先这个事件或者产品要能体现出知道你这个事情的人的优越性。说人话就是：知道这个事情的人就可以升职、加薪、当上 CEO 、迎娶白富美。走向人生巅峰了。至少感觉如此。 诱因这个世界上没有平白无故的爱、也没有莫名其妙的恨。你要传播一个事件或者产品。你肯定需要一个理由。爱一个人需要理由吗？需要吗？需要吗！诱因相当于这个事件的前置铺垫。看这个章节的时候，我脑海里面总会出现美剧里面的一些画面。大概就是看上去无关紧要的地方。恰好是关键的点。 就像蝴蝶效应一样。诱因的在于，它导致的结果会放大很多个数量级。卷起海啸。 情绪还是在说人。人这种复杂的物种在开心和难过的时候都会做出一些强烈的举动。所以，可以利用这一点，来进行传播。书中也很明确的说了。开心和难过都具备很高的传播性质。 举个开心的例子：国足2连胜举个悲伤的例子：姚贝娜病逝 公共性这个感觉没啥好说的，如果是大熊猫要明天要灭绝了。肯定全世界都陷入悲痛。但是如果是 Sumi 肠粉要挂了。 明天就我悲伤了。 实用价值举个例子：先不管到底实用不实用的问题。你看 QQ 空间 or WeChat 里面爹妈辈转发那些惨不忍睹的“使用 xx 小技巧”“xx 健康饮食大法”。 你就可以知道如果具备实用价值 or 看上去具备实用价值的东西是容易传播的。 故事能说的一手好故事太 tm 重要了。你都不用说的多长。能在140字以内吧故事说好了。你都是日入几十万的人了呢。（原谅我的夸张）我们称为段子手。能吧传播的东西埋藏在故事里面的。 我们叫软文。这个很好找例子，最近有关注 天才小熊猫。 微博上写软文目测不说第一，前三应该有的。你去看看他的转发量就知道一个好故事是多么具备传播力量。 总结 书中提到 「引爆点」这本书多次。 下本书应该就是它了。 都什么年代了，生病了能不能相信科学，相信现代医学。那可是你自己的命呐。 好多想吐槽的，写着写着就忘记了 over","link":"/2015/01/16/read-contagious/"},{"title":"读 Jony Ive The Genius Behind Apple's Greatest Products 笔记","text":"本文仅作为个人记录使用，也欢迎在许可协议范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助，您可以使用RSS方式订阅本站，这样您将能在第一时间获取本站信息。 开篇扯淡发现之前的读书笔记写的好少啊。 都是每年的一月份写一次，然后一整年都没有写。其实并不是没有看书而已，只是看了没写而已。2013除了专业的书籍还是看了一些乱七八糟的书籍。比如开始看王小波，看冯唐。对了ooyor大神同学去台湾做出国毕业旅行游的时候还给我带来了一本冯唐实体的小黄书《不二》。还有就是2013年初看完柴静的《看见》和李承鹏《全世界人民都知道》,而且还去不在书店签了4本。亲笔签名哦！其他的看了也就没有印象了。 其实读大学以来，每年的书籍开销都是一笔不小的数目。这就造成了一个严重的问题！每次不管是短途迁移还是长途迁移都搬书搬的欲仙欲死。所以，2013我都是可以买电子书坚决不买实体书。如果没有电子书，我就等电子书出来。如果没有电子书，不是很想看的就不买了。电子书多好迁移啊，一个iPad就带走千万本。不过也有些郁闷，我KK的全套在字节社里面结果现在字节社快挂的样子，多看上买了目前最多的书，但是被小米收掉以后不喜欢它的作风。现在我已经全面的转向了豆瓣读书。图灵社区也买了些然后丢多看里面看。（多看在我这里已经沦为Good Reader的替代品）。 恩，2014希望我想看的书都出电子版吧！让电子化来的更加猛烈一些。 Jony Ive这次的书总有种是为了敛财而来，作为一个Apple的脑残粉。其实Apple这40年来的各种事件和经历。已经在无数的书籍、文章、电影里面一次一次的重复了很多很多次。每看一次就对Apple的印象丰满一些。到现在Apple在我心中已经是一种具体的形状。这次的Jony Ive传记对我来说，也只是对于Apple印象的一个补充而已。 年少成名大英帝国的子民，而大英帝国好歹是工业革命的发起地。虽然美帝现在势不可挡。但是200年来的现代化进程底蕴是天朝这种年轻的2b国度无法比拟的。而且Jony Ive人家老爸人家16-7岁的时候就已经各种拿奖了。 PS这篇blog的创建时间是1月8号。现在时刻是3月18号。所以我还是把他发掉把。只开了头而已。现在记不住了。 一月到三月瞟过的书有： 「从你的全世界路过」 （看错作者买错书了） 三本Objective C的 GEB瞟了几页。 豆瓣上冲了150.忘记买了些啥了记得有几本挺贵。反正是不在多看上买书了。","link":"/2014/01/08/read-jony-ive/"},{"title":"读书笔记 「引爆点」","text":"本文仅作为个人学习记录使用，也欢迎在许可协议范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助，您可以使用RSS方式订阅本站，这样您将能在第一时间获取本站信息。 开篇扯淡嗯，在一月的最后一天的最后一个小时开始写这篇读书笔记。也就算做这个月输出了3篇 blog。如果对比2014年这种令人发指的输出量来说。对于自己不得不说是一个巨大的进步。 这本「引爆点」是在去上海开年会的来回路程上扫完的。顺便说一句，Sumi 除了Kevin Cao。其它全部在上海喝了残血回程的。 我还内伤了回来在医院躺了2天。 这是后话了。可见战斗力下降的厉害。 最近我看书，一边看、一边会去联系一堆事物进行思考。因此现在的读书笔记也是想到什么写什么。并不是上学时候那种读书笔记顺序条例整齐的。算做观后随笔之类的吧。 最后的一句扯淡，我不应该怎么晚才看到这本书。 关于本书由于我断网了，所以我无法查询到「引爆点」的成书时间。不过根据书里面的各种信息透露。我推断「引爆点」成书应该在2000年之前，1996年以后。说这个的原因是说，现在的和过去不久的一些流行过的概念。应该都出自此书。比如影响里面最深刻的破窗效应。比如罗永浩说过的搞定最前面的一拨人就能引发流行的理论。（插一句2014年的老罗单口相声还没看呢） 所以，很多人应该很早前就看过本书。并且从书里面学到了很多智慧来运用在日常的生活当中。而且就拿出里面的片段出来都可以变成单独的流行文章。所以，我不应该怎么晚才看到这本书。暴露出自己最近10年来的阅读量远远小于自己设定的的阅读量。 如果还没有看过「引爆点」，强烈推荐。 依旧是在研究人啊前两天才说过，貌似除了自然学科。其他的都是在研究人。对人和人性的探究，从 DNA 到思想。 我觉得「引爆点」的作者马尔科姆·格拉德威尔应该是试图从科学的角度系统的说明为何一个东西会在某个标准性的时间或者事件以后成为流行的原因。 马尔科姆·格拉德威尔选择的所有例子都是围绕着社会问题来进行选择的。美国独立战争的开端、普通大众流行的鞋子、及其成功学前儿童所看的电视节目、吸烟吸毒、整顿地铁降低犯罪率、小岛上的自杀等等。方向并不单一。而且我经常在国外的书里面看到，在大学里面进行的志愿者实验来佐证自己的观点。我从来没有听说过我的大学有进行过类似为了科学研究一个事情用这样的随机普通样本进行的试验。仅从这点上来看，天朝的大学离现代正在的大学差距不是一星半点。当然可能我读的大学和能接触到的大学都比较low。有以偏概全的嫌疑。不过我还是坚持这种天朝所有大学离真正的科学、民主、自由的现代大学有十万八千里的距离的观点。 继续扯远一些，其实现代文明社会和天朝都有在研究人。但是给我的感觉是孑然不同的。我的感觉现代文明社会研究人，把每个人都当作一个独立的个体来研究。不管怎么样，是伟大、普通平凡、还是十恶不赦。在当作科学来研究的时候。都是平等的。但是天朝不是，天朝是啥。就自己感受吧。 「引爆点」和 「厚黑学」两个毫不相关的书，在我心里却有一些联系。 「引爆点」看完以后我发现其实它根本没有直接跟互联网跟移动互联网有半毛钱的关系。但是它确实是在这个圈子里倍受推崇。看封面和封腰都有一堆大佬什么联袂推荐，很是反感。为什么呢，因为如果理解了流行的趋势，做出了倍受欢迎的互联网产品这都是金灿灿的钱钱啊，能不倍受推崇么。可是在我心里就有这么觉得变扭呢。我觉得马尔科姆·格拉德威尔写这本书，更加想解决的是能不能降低未成年人吸烟吸毒的人数。能不能提高儿童学习的效率。能不能降低城市的犯罪概率等等。简单来说就是如何运用这些原理来拯救世界。但是却被安利来做赚钱的东西。简单说来就是杀鸡用牛刀、高射炮打蚊子。说不出的别扭。 同样的情况发生在我看完「厚黑学」以后。在看之前我对「厚黑学」的想象是这是一本教人如何黑心假面的书。如何教人变成一个油腔滑调的人的书。在我的幼稚的心智里面觉得是一本贬义的书，一本黑暗的书。但是我某天无聊买回来看完以后觉得我靠真的可以算一本奇书。书里提到的方法和写下的当时的环境。作者提出的厚黑之术居然是为了拯救当时千疮百孔、摇摇欲坠的中国。而且按照我认知里面推算，应该是可行的方案。也就是说，「厚黑学」我觉得能算做国术，是有大智慧的。一个具有大智慧的治国之术在天朝大地流行的原因跟无数人挤破脑袋要去考公务员的原因是一样的时候，心中泛起当下所在的天朝是多么的荒诞无稽。 所以这两本书都给我一种作者是心怀天下交出了绝世武功本想要世人拯救世界，却被世人天天拿来打野鸡烤了吃。 总结貌似我的记忆方法一直有问题，所以我有些事情会相当的记不住。人名就算一个。特别是国外翻译的人名。我脑子里面几乎就没几个。挤破脑袋只能想起K·K叫凯文·凯利。现在，我应该郑重的多记忆几次马尔科姆·格拉德威尔。今年应该会把他的几本书都扫一遍。 最后 ，「引爆点」5星推荐。并不是因为它可以让你一下就能做出个淘宝爆款出来。而是书里用科学的态度来说明了我们世界里面一些真实运作的原理。","link":"/2015/01/31/read-the-tipping-point/"},{"title":"比弱冠多一点点, 离而立还有一截","text":"24我一直觉得在中国，12是蛮重要一个关于时间的数字。一天有12个时辰。一年有12个月。一个生肖轮回是12年。我已经在这个世界呼吸了24年了。12年一轮。我在今天解锁了两次本命年的成就。 当第一次轮回时候，肯定幻想过第二次轮回的样子。回想过去，其实第一个轮回的记忆已经不是那么的清晰。而第二个轮回确实造就了现在的我。 迷失我在12-24这段时间里面。迷失过很多次、很多次。通俗一点的叫法是成长的烦恼吧。科学一点的说法是我在形成人生价值观。在不断的肯定自我到否定自我到放弃自我到重新找到自我。类似凤凰涅槃，类似一个12年的轮回。一次一次，仿佛捶打精铁。人生真的要经历重重才能获得历练。人间荣华富贵、疾苦哀愁。何苦来。最后迷失这么久，开始坚定着自己的信念，跟随着自己的心。心在哪里，就去哪里。 风在不大的时候，心底有种很强烈的感觉，觉得我不属于那个偏远的小城。也不会属于繁华的都市。幻想着仗剑游走世界。像风一样，漂泊、居无定所。啊哈，大学以后果然开始验证，大学四年，我居然每年都住了不同的地方。工作两年，迁移了3个城市。厦门是最后的目的地了么？随着年纪的增长，我想毕竟风最后也会停留在一个港湾吧。 爱情对于爱情，我一直以来的观点是这样的。每一个人生下来都是一个半个圆圈，有大有小，有各种形状、颜色。然后我们一直滚啊滚的向前生活着，在茫茫人海中选择另外一半圆圈。如果我们遇到了合适的半个圆圈，相互组合起来，能在生活的大道上肯定越滚越爽、越滚越快、越滚越开心。可是如果没有组合在一起滚过一段时间，怎么可能知道滚起来爽呢。但是大部分时候，我们不可能一开始就找到适合的圆圈。这时候就会产生变化，有的人，把不圆的地方削圆只是为了更好的配合起来滚。而有的人不愿意改变自己，就次分开，这个半圆不合适，要有勇气去寻找下一个半圆。还有的就半圆的滚一生。 不管怎样，我们都是时间转盘上的沙粒。能在沙漠里相遇。就要彼此珍惜。 小时候我应该算一个早熟的孩子。在小学就知道我喜欢谁谁谁产生过要在一起一辈子的感觉。so虽然没有经历过多少跌宕起伏的爱情故事。所算在早恋的年纪还是经历过。没有给年少留下什么巨大的遗憾。这样我总结失败经验的时间就比其他人多了一些。经历才会造就现在的我——真的知道这样才能好好的爱一个人。也相信现在的我对于爱情是可以拿得起，放的下。虽然之前一段事情有一个兄弟反问过，如果真的能放下的感情，还叫感情么？当时我确实被问住了，现在我要说，放手其实是另外更加深层次的一种爱。不能给出的幸福，那就远远的看着她祝福她。这也是爱。 兄弟24年了，回头看看，竟然一事无成。回头看看父母，貌似也没有怎么孝敬。最后，只能说我还算交上了一帮应该能出生入死的兄弟。说出生入死其实是自己YY了，不过我就是这样觉得的。24岁这年，结婚的已经结婚了，有小孩的都可以打酱油了。确实已经不是一个那会逃课打魔兽，无聊时候在街上乱晃荡看美女，喝多了就在KTV乱吼，无所顾忌的年代了。我们长大了，成熟了。变成了12岁那年想变成的那个没有父母老师约束的人。而自己又给自己加上了责任和义务。我们是计划生育的一代，我很庆幸在我年少的时候能认识你们，然后我们一起长大。一日是兄弟，一辈子是兄弟。 36我是花费了好大的力气才让自己承认和接受我在20几岁之前是不可能有一个巨大的成功的。为此还难受了好久。总认为自己跟别人不一样，到最后确实跟别人不一样，但是还是普通人一个。那就1万小时原则呗。慢慢做坚持做自己想做的事情。","link":"/2012/11/06/second-life-this-animal-year/"},{"title":"简单配置PonyDebugger","text":"前言iOS的Debug 系统在github上还是有不少。 PonyDebugger是看上去比较牛气的一个。尝试一下 PonyDebugger 可以监控网络 还可以查看Core Data对象 view的层级查看 这种好东西。 让我们快速开始吧。 快速开始服务器端 1. 安装 Xcode’s Command Line Tools 2. 在shell里面执行下面命令 12curl -sk https://cloud.github.com/downloads/square/PonyDebugger/bootstrap-ponyd.py | \\ python - --ponyd-symlink=/usr/local/bin/ponyd ~/Library/PonyDebugger 3. 安装成功以后，在shell里面执行 1ponyd serve --listen-interface=127.0.0.1 4. 打开你的浏览器 输入地址 http://localhost:9000 如果看见的是这样说明服务器端已经安装好了。 iOS端 1. 把PonyDebugger作为你自己的项目的一个git submodule添加到你自己的项目里面 1234cd /path/to/YourApplicationmkdir Frameworksgit submodule add git://github.com/square/PonyDebugger.git Frameworks/PonyDebuggergit submodule update --init --recursive PonyDebugger依赖于SocketRocket所以当你update的时候也会把SocketRocket一起clone下来。 2. 然后把PonyDebugger/PonyDebugger.xcodeproj 增加到你的项目里面去。 3. 在你的Project Settings里面的Build Phases标签里面把PonyDebugger作为Target Dependency的一个添加进去 4. 链接libPonyDebugger.a和libSocketRocket.a 5. 添加link参数-Objc 6. 最后 检查一下你项目的Framework有没有以下Framework如果没有添加一下（包括libPonyDebugger.a和libSocketRocket.a） libicucore.dylib CFNetwork.framework CoreData.framework Security.framework Foundation.framework 到这里环境就配置好了，下面就来用把。 使用基本用法PDDebugger是一个单例 这样获得. 1PDDebugger *debugger = [PDDebugger defaultInstance]; 自己连接网络 1[debugger autoConnect]; 或者亲自指定服务器端 比如 ws://localhost:9000/device 1[debugger connectToURL:[NSURL URLWithString:@\"ws://localhost:9000/device\"]]; 关闭连接 1[debugger disconnect]; 更多用法 参考主页 这篇blog相当于简化翻译 囧。","link":"/2013/01/14/simple-configuration-ponydebugger/"},{"title":"2012 末日计划","text":"修改来源于之前的淫淫网日志 记得每年这个时候，我都会留下一篇类似的文章。然后热血两天，接着剩下的300多天里面每天都混着过，然后又到了这个时候，又出来感慨一下人生，计划一下接下来的300多天。计划始终是计划24年没有一次变成执行。结果人生的每一天都像copy出来一样，吃饭、睡觉、发呆。按照这样的活法，其实已经能看到10年、20年后自己的模样。一个字贱~ 基本上中国人的陋习都可以在我身上有所体现，有些是显现的，有些伪装的很好。。。。跑题了。 还是拉回来说2011的总结。其实之前23年都可以用一句话就搞定。狗屎一样的人生。前18年没有按照自己的想法活过，后面4年有机会按照自己的想法活，却又白白浪费掉。看。。。贱——不珍惜。 本来可能我这生就这样过了。可是好不好出了一个2012。乔帮主又在2011仙去（又追星了不是。。。贱）。翻看他在斯坦福的演讲，每一天当做生命里的最后一天来活。我境界没那么高。就只把2012当做最后一年来活。 2012，不管你信不信，反正我是相信了。 为了这最后的一年活的开开心心、快快乐乐。 我对我自己做出以下要求 和萌小萌开开心心的过好剩下的每一天不吵架。 至多每月只能上一次G+ 一次脸谱 一次推。三次时间加起来不能超过半个小时，如果违反一次，跑步一小时。 每月看完一二本书（世界末日只限技术类书籍，暂时不考虑怎么拯救地球）。每月十五月圆之夜看不完一本，就出去跑步2小时。然后最近的周末通宵也要翻完。。 一月《什么是数学》 以后每星期只可去踢球一次。只踢到9点。去到那里人太多，就跑步一圈回。 每周要写一篇blog。（这是我2012第一篇blog） 7月之前要上架一个app。 2月之前要再github上有项目，然后开始迭代。 7. 每周只能开一次人人（更新一下blog，说不定人气高了，我还要回复回复什么的。） 注销新浪weibo。 ~~9. 不用QQ（gtalk：yunsn0303@gmail.com 你懂得 ~~ 可选： 学习web技术 学习html css js等高端技术。 学习web架站。 学习ror 用以上学到的高端技术搭建自己的blog。。。。。。。。","link":"/2012/02/26/the-end-of-2012-plans/"},{"title":"深夜吐槽多看","text":"深夜吐槽多看好吧，作为一个喜欢看书的人和觉得多看做的确实好的普通用户。我把我个人的想法完整的表达一下。 前提首先，在国内阅读App上对我来说。多看目前已经遥遥领先。其实记得当初在iOS上引爆中文阅读的是唐茶从&lt;失控&gt;到&lt;史蒂夫·乔布斯传&gt;。让人觉得电子中文阅读还可以这么美。而多看是从Kindle起来，所以说做阅读的时间不比唐茶短。真正的混战是在字节社、多看(更新了一个版本)、豆瓣阅读上。三个App我都在对比，都在用。KK的全部书籍我都是在字节社买的。当时字节社的书更新较快。多看出于一个跟随者的角色当中。一般是字节社上了多看才上。两个都想做成中文电子书的最大平台，那时候机会看起来势均力敌甚至字节社还要有一些优势。其实那时候我喜欢的豆瓣阅读的风格。豆瓣阅读的设计平淡如茶。不像字节社的大红和多看的大黄。可惜豆瓣貌似没有想往阅读方向上大力发展。至于现在，半年都不更新一次的豆瓣阅读已经很少打开了。简单点说后来是字节社被下架很长时间。书目的种类和网上书店被多看给超越。多看也在一直努力。App做的越来越好,UI交互的重新设计，PDF的重排达到逆天的级别(我想这跟Kindle的技术积累密不可分)。至于我现在想买书的首选是多看。这段主要是表达我确实是喜欢多看阅读的。 其次，说一下我不喜欢的。 我不喜欢小米。跟我不喜欢隔壁大胸的妹子理由一样。 不喜欢就不喜欢呗，跟她胸大不大没关系。虽然现在多看和小米是好基友。看意图也是多看要成为小米整个体系重要的一部分。问题是我特么的不喜欢小米，没有小米手机。我就是一个普普通通的多看用户。我想用多看，而不是想用小米的一部分。然后这里就能说到帐号迁移了。我根本不想迁移去变成小米帐号。为此我还特意去多看的官网上面去看了Q&amp;A.得到的结论就是迁移是必需的。必需就是没有选择的余地。我真心觉得这个迁移很恶心，至少恶心到我觉得如果我能找到一个替代的App。我宁愿去用其他的App。结果目前还真没有能替代多看的。悲从心中来啊。虽然说迁移给了5米币啥的。但是感觉上就是把人领出去卖了，然后在卖的路上买了颗糖给吃的感觉。 发现Bug相当相当的不爽。但是这些恶心的事情，都没有能阻止我想用多看看书的欲望。当我发现多看居然在搞活动。100以下卖多少送多少。想想每月买书支出应该也有个两三百。所以相当于5折了。心想还不错。暂时不想迁移这个事情来恶心自己了。结果特么在开始前的半小时我发现，特么只能是Android用户才有优惠顿时崩溃了。感觉不会在爱了，赶紧在微波上@多看的运营妹子问怎么办。然后回复我叫我借一台Android在上面购买。我方圆几百公里就特么认识一台Android。赶紧过去献媚的叫人家借我用用。 当我小心翼翼的捧这高端大气上档次的米1笨手笨脚的登录多看的时候。觉得能剩点钱还是值得的。当我点开多看准备把冯唐的书全部收掉的时候。发现都是下载。没有购买。赶紧问问手机的高富帅。人家说刚刚买了这几本！！！！多看你是闹那样。登出了这种私人用户信息都不清空。思考了一下。征求了高富帅的意见，我把多看App删除了。然后用高富帅的3G网络畅快的重新下载了一个多看App。然后又小心翼翼的捧这高端大气上档次的米1笨手笨脚的登录多看。结果特么结果还是一样的啊。人家购买过的。我没有购买的登录进去是下载，不是购买。简单点说就是大Bug啊。用户信息都特么乱穿掉了。这时候我只能手里握着100块。以45度仰望天空。默默的在微波上留言吐槽一下。 回应反馈接下来是回应一下 happia 这位应该是多看员工。 happia的回复我整理一下大概内容如下： 我：为什么只有Android做活动？ happia：这次之所以指定了平台，是米币中心出于安全考虑，只允许在手机上进行。其实iOS平台和Kindle平台都不支持用米币买书，这个限制只是不允许在网页上参与。 我：为什么会有用户信息在登出的情况下还会混乱的bug？ happia：1、因为这次是米币第一次做公开的优惠活动，所以会谨慎很多，涉及到大规模交易的事情都要很小心，弄不好最后银行结算会出大问题。现在还在积累电子支付经验的阶段。2、这本书如果已经下载了，那就不会再显示购买按钮，而是显示阅读。你在书架上看看有没有这本书？ 对于绝大多数情况，这样是最好的选择 简单的说，一个手机上在多看阅读上上用多个账户的情况很少，而且既然书架上已经有了，又要去换个账号买一次的情况更少。既然书架上已经有了，一般人都会直接打开，而不会再去买一次。这个情况已经属于特例中的特例了。 下面是回复吐槽： 至今没有搞懂你们策划为什么不允许在网页上参与。解释为支付安全考虑。毫无说服力，就算说策划的只想做Android就不做其他我都能接受。因为根本无法理解Android上支付能比网页支付安全。更何况可以是在你Android上购买了然后跳转到支付宝去网页上支付。还是说只要对普通用户解释为安全问题比较好解释？ 米币。呵呵都往虚拟货币搞。 想的倒是很美好。这也是为什么我不想迁移的原因。 然后是bug的解释。我在微波上回复了一句：神逻辑。现在来解释一下什么意思.我工作以后渐渐的受到影响还是蛮尊重版权。现在电脑上可以自豪的说是全正版。反正买不起的就不用了呗。因为既然我喜欢的软件我希望作者在把他做的更好。对于书也是一样，我喜爱的文字，喜欢的思想。我都愿意付出一点。让作者能够收获一些。继续写出好看的文字，重要的智慧。让他知道自己的付出是有收获的。扯远了。 拉回来。 所以，当我用我的帐号去登录多看的时候。这时候的信息应该是我的。就算之前的帐号有下载过书籍作为缓存。但是我的帐号里面没有这本书，这本书是不应该显示在书架上的。然后我也可以购买啥的。这个对于我来说才是正常逻辑。也符合目前看起来的版权问题。 关于电子书的版权的情况现在我自己也很纠结。实体书，我买了。我可以随便借给任何人看。没有任何问题。但是电子书呢？公然的丢到网络上必然是不行的。但是我周围的人呢。可以借给他们看么。我也不知道答案。所以，现在我周围都是一本书说好看。然后大家就一起买。一个是电子书总体来说还是相对较便宜。一个是大家版权意思都在逐渐提高了。 最后扯回来这个bug。大可有一个帐号买了所有的书。然后进行分享。然后大家也只是偶然登录了一下这个有所有书的帐号。然后下载了全部的书。然后登录回来了自己的帐号。那这个时候，我看的书是正版？盗版？ 总结吐槽哎。没忍住。一下吐槽这么多。 最后的吐槽： 进来多看上的书是越来越多了。但是质量下降的厉害。比如那本&lt;改变未来的九大算法&gt; 翻译如同丢到google翻译 然后就拿出来卖。很是失望，希望能有退款通道。对这种没有节操的书进行退款处理 还有就是为啥自己导入的PDF观看的时间没有进入阅历中啊！！！！！","link":"/2013/08/22/tu-cao-duo-kan/"},{"title":"思考","text":"序本来blog更新应该更加勤快一些的。这篇积压过后。很多东西，却不知从何说起。连续两周都很晚才睡，却也没有做什么事情。就是乱点。今天突然发现可能是我太过于忧国忧民了。大厦将倾，何去何从，如何是好。 某游戏沙龙神仙道之前参加了某个沙龙，说游戏的。得到的数据让人很震撼.神仙道一个页游一年收入超过了10个亿，每月8000w。说真心话，真心不知道页游可以这么赚钱。神仙道也下了，试玩了一下。真心不是我的菜啊。可是人家以60人的团队。20w-30w的活跃用户搞定了这么多。真心nb啊。佩服佩服。虽然游戏不是我的菜。但是这次的光环CEO叶斌的做事方式确实是很踏实。虽然他一直自称很不靠谱，但是凭借他分享的经验来看成功并不是偶然。最后，依然验证了一次团队靠谱才真的靠谱。项目什么的跟机会一样。只要团队靠谱第一次抓不住还有下一次机会。 小插曲，叶斌其实提到「海贼王」的次数不是一般多。我是不是找时间看一遍。 Amazing Alex 神奇的阿力应用汇进行的天朝地区渠道发行。Android的发行商。一开始没有搞懂为啥还要发行商。直接丢iTunes Store里面不就好了。后来才听出来貌似是发Android版才是弄发行商。大概扯了很多发行方面的东西，不太懂。听的昏昏欲睡。 91助手&amp;同步推在听完前面两个以后，接下来传说中的熊俊兼场内主持来介绍了。知道他是看过蔡文胜投他的故事，被很多媒体进行过转载。大概都是介绍蔡文胜怎么投项目的风格，说见第一面吃了饭聊了聊。就各回各家了。第二天一大早，熊俊接到短信说：钱已经打到卡上了。故事嘛听听就好了。不过我才知道熊俊这么一个人。后来一查才知道91助手的创始人&amp;同步推的现任CEO。之前觉得91助手就是一个2b应用，同步推也不咋滴。现在开始发现我错了，错在太想当然，太飘忽。首先，有大量用户的产品就是一个成功的产品。它必然又打动人的地方。不要被一些主观的想法而忽略掉这种产品的优点。这些产品在我看来都是一样的比如QQ，360，百度。之前不屑一顾，现在我会认真的思考他们为什么能成功。在熊俊的介绍下来看。91助手成功是必然的。91助手当初有几个竞争对手。都被91给搞死了。因为熊俊做了几个事情： 快速的迭代，让用户感觉产品一直是新的。感觉被重视 潜伏在了竞争对手的qq群里面，如果人家要做一个新功能，赶到对手前面发布。如果功能完美是100分，对手要作80分。而为了赶在前面出现91只做了60的产品。可是这样的效果就是竞争对手全部被搞死了。用户只认91的。 深入用户群体中去市场调查，去手机柜台看，卖手机的怎么用91。希望用什么功能。 大概我记忆中就是这三点。一个能这样去做产品的人。我想91把剩下的竞争对手全部干掉是理所应当的。然后出来做同步推。其实我也不能理解，他自己也说要做了超过91很难了，为什么还要做同步推。 这就引出下一个话题。 做卖水的也能赚钱19世纪中，美国加州传来发现金矿的消息。许多人认为这是一个千载难逢的发财机会，于是纷纷奔赴加州。17岁的小农夫亚默尔也加入到这支宠大的淘金者队伍，他同大家一样，历尽万苦，赶到了加州。 越来越多的人蜂拥而至，一时间加州遍地都是淘金者，而金子自然越来越难淘。不但金子难淘，而且生活越来越难苦。当地气候干燥，水源奇缺，许多不幸的淘金者不但没有圆致富梦，反而葬身此地。 小亚默尔经过一段时间的努力，和大多数人一样，没有发现黄金，反而被饥渴折磨得半死。一天望着水袋中一点点舍不得喝的水，听着周围人对缺水的抱怨，亚默尔突发奇想：淘金的希望太渺小了，还不如卖水呢。 于是亚默尔毅然放弃对金矿的努力，将手中挖金矿的工具变成挖水渠的工具，从远方将河水引入水池，用细沙过滤，成为清凉可口的饮用水。然后将水装进桶里，提到山谷一壶一壶地卖给找金矿的人。 当时有人嘲笑亚默尔，说他胸无大志：“这么幸苦地到加州来，不挖金子发大财，却干起这种蝇头小利的买卖，这种生意哪儿不能干，何必跑到这儿来？” 亚默尔毫不在意，不为所动，继续卖他的水。把几乎无成本的水卖出去，哪里有这样好的买卖，哪里有这样好的市场？ 结果，淘金者都空手而回，而亚默尔却在很短的时间里卖水赚了几千美元，这在当时是一笔非常可观的财富。 黄金珍贵，因为黄金稀有，也正因为稀有，蜂拥而至的淘金者注定难圆发财暴富的美梦，只能无奈空手而回。 饮用水平凡，平凡到遍布河山，但亚默尔开动脑筋，不怕非议，独辟蹊径，抓住了大好机遇，净赚几千美元。 移动互联网就是这金山。蜂拥而至的开发者就是这淘金的人儿。这就是卖水也是一个不错的选择。大家都不傻，卖铁锹，卖铲子，卖水。很多云服务也是准备做这样的事情。而同步推、应用汇等。都是在构造渠道。渠道为什么要有渠道，因为App太多太多了。人们无法分辨什么是好的App，是自己想要的App。加上Apple内置的App搜索确实不尽人意。所以用户可能会通过其他渠道进行App的需找。这就产生了用户的实际需求。记得老罗在2010年的演讲里面有说到：用户的消费是由追赶潮流的前面的一小波人去影响去推荐去口口相传。所以同步推就是想做那种能影响大部分消费者行为的角色。这就是我认为他们为什么要做渠道的原因。实在佩服这些人的远见，和对业界的判断。每次自己能看到这种机会的时候，已经是第一波起来开始做大做强的时候，自己的判断力一定要不断的锻炼。所以同步推肯定会赚钱因为熊俊做事很踏实，洞察力很强。就算这个不赚钱，下个项目也有很大机会(人家现在在专心做同步推，自己瞎操心) cocos2d-x之前听曹哥说过cocos2d-x是厦门的团队制作。还没有太当明白。见到了团队负责人王哲。又他介绍了一下cocos2d-x这个牛逼哄哄的东西。因为之前装伪geek喜欢linux的原因。国内开源还是知道一点。基本没开源，没太多和全世界一起做的东西。几乎没有。但是cocos2d-x居然是开源的。而且用户和开发贡献者是全世界的。能做到这点，在天朝我觉得太难能可贵了。激发出了我悠然的敬佩之情啊。如果要入手做游戏，我会选着从cocos2d入手 具体是用cocos2d-iphone 还是 cocos2d-x。这个值得待考虑，毕竟c++那种逆天的东西，从来也没有懂过。 海外市场 vs 国内市场就说一句国内市场我觉得在走好。海外市场确实有很多先天条件不具备，比如文化，价值观，成长经历。不过「Tiny Wings」独立游戏人的成功。做一些小游戏还是有机会的。目标人群不一样。游戏的出发点也就不一样。 结尾感觉这篇blog烂尾了。毕竟是拖了3周了。终比没有强。","link":"/2012/07/30/thinking/"},{"title":"在2019写给18岁的自己","text":"本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 前情回顾2012版本写给18岁的自己 2016版本写给18岁的自己 2019版本写给18岁的自己 瞎扯已经过了30岁了，怎么看都是一个废材肥宅。毫无事业上的建树。所以这个系列从一开始的觉得要给年轻人一些建议的想法。变成现在更像是自省。想象现在时间节点上的我如果能见到18岁的自己。会给自己说一些什么样的话。顺便如果有人从这些文字里面有所感悟，那这篇文字就变得有价值了那么一点点。 至于说我永远回不到过去，很多马后炮似乎没啥卵用。那种下一棵树的最好时间是10年前。第二好的时间是此时此刻。所以我们一直拥有着第二好的时机不是么。 首先接受平凡的自己小时候以为自己与众不同。但是从已经过去的人生里面来看，我确实就是一个普普通通的人。但是估计是受到了青春期看了太多乱七八糟的热血励志书。一直认为自己总有哪里是独一无二的，哪里是过于长人的。 这样的思维导致我行为做事的方法： 做重大选择的时候是逆势而为的，以为可以人定胜天。 错误的评估自己的能力，制定了自己到达不了的目标。 人家说“在风口上，猪都能飞”。而逆着历史的洪流，我这头猪分分钟就被淹没了。制定了艰难的目标，因为现实跟目标差距过大，逐渐陷入焦虑中。处于焦虑烦躁的情绪中，做事效率降低。导致恶性循环。 直观结果就是经济上无房无存款，事业上浑浑噩噩。每天人也过的不太开心。 从开始认识到我就是一个普通人。到接受我是一个普通人的设定，我大概花了3年左右的时间。 接受了普通人都设定以后： 选择都时候会顺势而为 不制定过于艰辛的目标 就算今天混过了一天，没那么多负罪感 把人生中长期目标制定的具体简单直接一点如果在18岁的时候把目标就确定成为 我一定要买房 我一定要出国 我一定要进大公司 我一定要找个非常漂亮的女朋友 等等 这样简单清晰的目标，现在的人生进程上可能不想现在这样没多少选择的可能性。 但是，小时候一直以“改变世界”。这样宏大不着边际的长期目标作为指导思想。导致现在职业上啥都不精通！ 做一个有趣的人因为自己小时候的原因。发现自己没有任何特别有意思的技能。 现在的我可以接受自己是一个普通人，甚至能接受自己可能智商、情商都低于普通人。但是我真不能接受我是一个无趣的人。 拿如何做一个有趣的人？可能接下来我需要不断的学习一下技能 提高审美 学习音乐 理解人类文明 总结以上应该就是我在31岁的时候想给18岁的自己说的话。千言万语，写下来寥寥无几。本来想继续写《IT 入门人士指南》系列。但是觉得自己技术稀烂，不适合继续更新了。 硬广时间我目前现在生活在新西兰。如果需要婴儿奶粉、保健品、程序员熬夜神器。均可通过么么爪新西兰代购购买。价格在海外直邮上有一定优势，但是淘宝上低价没法比。优势上只能用我那可能并不存在的人品担保都是正品。","link":"/2019/02/17/write-to-18-years-old-me-in-2019/"},{"title":"sizeof 深入理解","text":"sizeof 深入理解sizeof你们觉得是什么呢。函数？其实是操作符。wiki解释 In the programming languages C and C++, the unary operator ‘sizeof’ is used to calculate the sizes of datatypes, in number of bytes. sizeof can be applied to all datatypes, be they primitive types such as the integer and floating-point types defined in the language, pointers to memory addresses, or the compound datatypes (unions, structs, or C++ classes) defined by the programmer. sizeof is an operator that returns the size in bytes of the type of the variable or parenthesized type-specifier that it precedes as a size_t type value. sizeof is an operator：sizeof是一个操作符。擦 这货居然是操作符。最后一句我们可以得到的信息还有sizeof操作符的结果类型是size_t，它在头文件中typedef为unsigned int类型。该类型保证能容纳实现所建立的最大对象的字节大小。 我们先记住什么时候可能用到sizeof,因为我们毕竟是学了用的.sizeof的应用场景一般是神马呢： sizeof操作符的一个主要用途是与存储分配和I/O系统那样的例程进行通信。例如： 12void *malloc(size_t size)size_t fread(void * ptr,size_t size,size_t nmemb,FILE * stream) 用它可以看看一类型的对象在内存中所占的单元字节。 1void * memset(void * s,int c,sizeof(s)) 在动态分配一对象时,可以让系统知道要分配多少内存。 1int * pointer = malloc(sizeof(int) * 10) 便于一些类型的扩充,在windows中就有很多结构内型就有一个专用的字段是用来放该类型的字节大小。 由于操作数的字节数在实现时可能出现变化，建议在涉及到操作数字节大小时用sizeof来代替常量计算。 如果操作数是函数中的数组形参或函数类型的形参，sizeof给出其指针的大小。 知道怎么用以后我们来深入的蛋疼的讨论一下吧：那我们考虑一下它既然是操作符那是一元的呢还是一元的呢还是一元的呢。。。。。。。。。。。。。 网上有人说sizeof是一元操作符，网上还有人说sizeof更像一个特殊的宏，它是在编译阶段求值的。举个例子： 12345678#include &lt;stdio.h&gt;int main(){ int a = 0; printf(\"sizeof(a=3):%d\\n\",sizeof(a = 3)); printf(\"a:%d\\n\",a); return 0;} 输出为什么是4，0而不是期望中的4，3？？？就在于sizeof在编译阶段处理的特性。由于sizeof不能被编译成机器码，所以sizeof作用范围内，也就是()里面的内容也不能被编译，而是被替换成类型。=操作符返回左操作数的类型，所以a=3相当于int，而代码也被替换为： 1printf(\"sizeof(a=3):%d\\n\",4); 1printf(\"a:%d\\n\",a); 所以，sizeof是不可能支持链式表达式的，这也是和一元操作符不一样的地方。结论：好，记住：sizeof 在 计算变量所占空间大小时， 括号可以省略， 而计算类型(模子)大小时不能省略。 一般情况下， 咱也别偷这个懒， 乖乖的写上括号， 继续装作一个 “函数” 做一个 ， “披着函数皮的操作符” 。 做我的操作符，让人家认为是函数去吧。 不要把sizeof当成函数，也不要看作一元操作符，把他当成一个特殊的编译预处理。 其实说到这里也差不多了，最后看一下几个比较飘逸的例子： 1234567891011121314sizeof（int）*p 表示什么意思？int *p = NULL;sizeof(p)的值是多少？sizeof(*p)呢？int a[100];sizeof (a) 的值是多少？sizeof(a[100])呢？//请尤其注意本例。sizeof(&amp;a)呢？sizeof(&amp;a[0])呢？int b[100];void fun(int b[100]){sizeof(b);// sizeof (b) 的值是多少？} 时间不早了 1点多了 明天还要上班 睡了 结果自己看吧。 12345678910111213141516171819#inlcude &lt;stdio.h&gt; void fun(int b[100]){ printf(\"fun()sizeof(b):%d\\n\",sizeof(b));}int main(){ int *p = NULL; int a[100]; int b[100]; printf(\"sizeof(p):%d\\n\",sizeof(p)); printf(\"sizeof(*p):%d\\n\",sizeof(*p)); printf(\"sizeof(a):%d\\n\",sizeof(a)); printf(\"sizeof(a[100]):%d\\n\",sizeof(a[100])); printf(\"sizeof(&amp;a):%d\\n\",sizeof(&amp;a)); printf(\"sizeof(&amp;a[0]):%d\\n\",sizeof(&amp;a[0])); fun(a); return 0;}","link":"/2012/02/09/what-is-sizeof/"},{"title":"为什么要有自己的一个博客","text":"缘起 想有自己建站的blog是一直没有实现的一件事情。陆陆续续用51cto、is-programmer、renren等写过blog或者类似blog的东西。但是觉得还是缺少一些什么东西。后面慢慢的明白了，我虽然是号称学IT技术的。其实我根本就落后时代了。Web是什么我都不懂。适合学IT的人都有自己搭建的技术blog，技术人有自己的一个站好像是一个很容易的事情。可是我就是弄不起来，觉得写Web是一个洪水猛兽般的事情。一直觉得用现成的就好。可是用着又觉得自己不专业。然后就开始寻觅着是不是自己搭建一个Blog。然后先买了域名。就开始吭哧吭哧的学Web开发。Java是放弃了的，然后看Python、看Ruby。后面发现一个问题，就是我现在太苦逼了——工资刚刚能活，买不起VPS。不管是django还是rails我都搭建不起服务器来。再说我也只是知道他们的名字而已。具体怎么写一个blog居然一点头绪都没有。html，css，javascript这些高端的东西更是不会。自己建blog站，觉得离我越来越遥远了。 希望 我真的不懂web，不得不说是我致命的硬伤。突然我发现coolshell等知名blog都是用现成的blog站wordpress来搭建的。我才发现我之前有多傻。我一直是觉得技术人员的blog要自己实现才叫技术blog。2b青年都不足以形容我的存在了。然后我又打了鸡血似的想搞定wordpress这种高端的东西。我找啊找啊，然后找到了SAE这种免费的东西可以搭建SAE。搭建起来以后，要开始写文章了吧。写着还是不爽，因为我想绑定我的域名到blog上。SAE居然没有那种功能，还要备案什么，发邮件什么。然后我想换一个wordpress的主题。我也不知道怎样换。写文章我最多的代码高亮似乎也要安装插件才行。总之工作都没有做的弄了半天。我还是不懂搞。才起来的希望就破灭了。 转折 不知怎么，我居然Google到了Octopress这种神器。号称A blogging framework for hackers.装b典范啊。然后又Google到heroku居然可以在一定程度上的免费使用托管Octopress。（PS：其实github也可以免费托管Octopress的，但是heroku可以绑定域名啊）还可以绑定域名。我勒个去。这不就是我想要的东西么。立马开干。中文里面也有很多不错的资料。哇哈哈。这是春节以来我最开心的事情了。 Why其实上面的都可以算是我吐槽搭建Blog的血泪史。我这人各种不靠谱各种不给力。起码搭建了3年才有这个像样的Blog。有一个靠谱的Blog，上面有一些靠谱的技术文章，就成了一个靠谱而的简历。像我这样三流大学毕业，身无一记之长。没有天赋的人。找一个好工作确实不靠谱。看了刘未鹏的《暗时间》和“怎样花两年时间去面试一个人”。我就想好好做一份“简历”出来。拿一份靠谱的工资。不让现在苦逼的连一个VPS都买不起。","link":"/2012/02/05/why-have-a-blog/"},{"title":"为什么小米会成功","text":"为什么小米会成功正面赶上了移动互联网这一波浪潮这是「浪潮之巅」里面的说法。很显然，互联网那一波浪潮已经不可能再变得更高了。而下一波的移动互联网大浪现在来看，已经是在像最高潮发展了。而小米进入这个市场的时间要比现在早那么2年多。那时候，移动互联网这个浪头已经被Apple带起来了,天朝的移动互联网远远没有现在这么竞争激烈。小米就进入了这个大潮流中。所以，小米能取得多大的成功，依赖着这波移动互联网的浪能打多高。我觉得这波移动互联网的浪头会很高，至少要超越互联网这波浪潮两倍的高度。小米肯定不可能是浪头的最高点，不过由于进入的时间比较早，只是追随着浪头，也能达到一个很成功的高度。对于这样一个企业来说。确实就是成功了。 进行了C2C但凡在天朝成功的互联网企业很多带有C2C(Copy to China)的基因。究其缘由，第一、KK在「科技元素」里面说过。科技的发展在一段时期内是趋同发展的。何况在现在网络已经无处不在的时代。早上在硅谷出现的新鲜创意，晚上天朝可能就有人开始甩开膀子开干。第二、这里是天朝。 小米在模仿苹果。或许初期的小米并没有想要模仿，又或许小米的决策者们思考做的这些决策只是巧合的跟苹果的发神似。从强调小米是一个移动互联网公司开始，培养出一批big fans。到小米要自己做自己品牌的手机把软硬都控制到自己手里，到小米的发布会，到小米盒子，到小米商店（就是可以充值买主题那个我不太清楚是什么，只是记得看新闻看过）。每一步，其实都已经被Apple证明过实践过。我已经过了会相信巧合的年纪。我只能会说，这一切都是有人在刻意的去把小米运营成中国的苹果。大方向只要对，努力去做，去适应天朝的市场需求。小米会取得巨大的成功。会变成一个在中国最像Apple的公司。 用心的做了产品小米是一个很年轻的公司。而且MIUI能保持长时间的每周一更新这真的很难得。老罗说过他自己为什么要做手机的历程，他去小米谈过一次，虽然雷军不是很感兴趣。但是另外一个高层对老罗的想法很感兴趣。所幸，多多少少反应出来，在小米有一帮人在踏踏实实做事情。在琢磨，在研究。所以，小米一直在进步不是么。MIUI真的算我在天朝能看见定制Android目前最好的。 锤子科技这里还是忍不住插上一段讲老罗的。老罗的音频我在大概06 07年的时候就听过了。那时候高中无聊的慌，听他使劲的扯淡，很是留下了很多欢乐。然后牛博、然后老罗英语、然后西门子、然后演讲、然后手机、然后国航……。经过6-7年的种种事情，其实老罗还是那个我听音频的老罗。他看各种书，扯各种蛋。思考人生。维护自己的权利。跟随着自己的心去做事情。其实只要过了18岁，然后看过几本靠谱的书。能自己思考一下的人都知道目前天朝的所有问题的所在。可是我没有见过能改变这个问题的人或者事出现。所以我觉得老罗折中了一下。他用自己来教我们怎样做一个公民。老罗做ROM，我认为做出一个好ROM没啥大问题。可是现在的问题是ROM跳票了。我能理解要做到完美的产品才拿出来的心情。但是我不认为一个从来没有发布的产品能一出来就做的很好。我认同一句话，就是上线的第一天才是真正开始开发的第一天。只有被用户所使用，才会知道真正的需求。从浩瀚的需求中提取抽象根本问题，然后漂亮的解决这个问题。周而复始，才能渐渐迭代出一个好的产品。而一推在推的发ROM和Android被Google自己版本快速的迭代。会变成一个无期限的事情。我觉得是应该先推出ROM然后在迭代开发会更靠谱一些。 迎合了市场需求 小米的硬件卖点 小米的营销手段 小米的品牌塑造 历史总是相似的。30年前开始的的一场个人电脑战争爆发与微软+英特尔和Apple之间。由于种种因素的影响。我们现在知道那场战争的胜利者是微软+英特尔。虽然是Apple引爆了这个市场，结果还是被后来者统治了整个个人电脑时代。现在的移动互联网仿佛就是历史的重演，开拓市场的领先者依然是Apple，不过对手换成了Google Android阵营。Apple依然是那个对抗整个世界的Apple。而在Android阵营里面的小米，就是深得个人PC中微软+英特尔大败Apple的招数——性价比。小米主要买的是天朝，天朝还处于社会主义beta阶段。所以性价比在天朝乃至世界范围内都是一个很好的招数。小米做到了。 我记得我第一次知道MIUI的时候，那会只有一个论坛，很简陋的样子。虽然说是CM的改版，但是开始了本地化的改造。而且那时候已经是进入市场的小米，国内做ROM的还很少。硬件厂商又在自己开发着各自不咋样的Android版本。导致国内一批整体素质比较好的用户，都在使用。也就是后来小米喊出的口号，为发烧而生。确实，小米的初始用户户就是这些人。记得老罗第一场演讲的时候说过一个新技术产品的周期，具体数值记不得了。大概就是说。有一大部分用户的购买习惯是跟随着他们周围略懂而且愿意追随新技术的用户。他们会咨询和遵循这些略懂的人意见。小米不知是刻意还是无意。恰好赶上了这个点。最骨灰的用户在追寻最新的Android版本，CM的改版，对小米肯定嗤之以鼻。而略懂的用户，真心的觉得小米不错。这就够成了小米后来广告营销的基本条件和品牌的塑造。 小米手机，屌丝专用机。真心没有错。我不希望谁以屌丝自称。事实如此，虽然天朝大部分年轻人没有屌丝的心态，但是却是经济在屌丝状态下生活。高性价比本身就具有广阔的市场。再加上小米多多少少真的用心做了产品。小米会成功。 小米盒子其实我想写这个blog的原因是小米盒子的出现。我觉得小米公司确实就是在C2C Apple。结果文章没有写完。小米盒子就被相关部门干掉了。讽刺啊讽刺。来看看小米盒子就是一个Apple TV的翻版。然后高性价比，根据天朝国情的本地化功能。连我都觉得过年回家给家里带一个，爹妈可能会更开心的看电视剧。 侧面就举一个例子把。360这个老流氓那次打击的不是天朝内行业的最赚钱的公司。这次打小米，很显然是360嗅到了金钱的味道。就是从侧面说明小米在搞的事情很赚钱。成不成是另外一个事情。 总结思绪很多，而且还间隔了这么久的时间。我想接下来的时间里面就不写这种类似的文章了。第一是觉得自己的眼光和阅历并不在一个很高标准的角度上看问题，这样必然有一定的局限性。做不到一个很客观的角度。第二是自己的文字功底确实没有我想象的那么好。第三如果天天写这些快变成光说不练的假把式了，说是天下无敌，打是无能为力。","link":"/2012/12/16/why-the-xiaomi-will-be-successful/"},{"title":"2013年度总结","text":"本文仅作为个人记录使用，也欢迎在许可协议范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助，您可以使用RSS方式订阅本站，这样您将能在第一时间获取本站信息。 生活注定的漂泊在16岁的时候，我就会隐约觉得我会一生注定漂泊。这种感觉以我的文字水平很难用完整表达出来。不过18岁以后的每一年换一个住的地方。直接用事实验证了这个16岁的直觉。本来以为我会在厦大住够2年的，命中注定，天煞孤星。房子要拆迁只有另外找地方了。继续这一年一个地方的节奏。 极品房东我想如果不是今天发生的事情我是不会写入的。说真的我一直觉得国足，城管，整个教育，盗版，没节操，所有的敏感词。其实都是表面，去深究根本原因的人们都消失不见了。所以在这种无力的大环境前提下。面对这些事情我常常手足无措，不知道应该用什么样的态度去面对这些事情。我只能告诉自己，这是一个又一个生动又真实的移民广告。来生不做中国人。拉回来说，现在应该称为前房东。来厦门几次找房子都很仓促。都没有留下足够的时间来好好的找房子。第一次是来面试结束以后，一直住酒店。厦门的酒店价格大家懂的。然后也是找了中介就草草决定。电梯海景房，一套隔断成6套。我的是其中之一。旁边有个貌似厦大的女生。经常去夜店，凌晨2-3点回来。这个没啥，关键带一群女生回来。喝了些多不多的酒。然后开始评论男人，给男人打电话扯淡。嘛当，几个月搞的神经衰弱啊。 直接说了没有用。几次想怕起来搞个小电影开最大声音。但是觉得我都出声提醒警告无效的情况下。貌似也没用。然后就是住了半年房东要涨200，当时怕过不了试用，就直接滚蛋没干签一年。然后最后几天天天中介带人过来看，态度很嚣张。最后退房的时候，我在帝都找妹子去了。委托了蒋韩同学过去退押金。一个很能扯淡的河南汉子硬是被两中年妇女说的毫无招架之力。唉。反正被扣了钱。不过也难为他了。找啊找，然后我们投资人说有个朋友的朋友有住房子。当时遇到国庆要去帝都找妹子。找房子带搬家就一周时间。然后想着恩好像有点熟人类似的关系应该没啥问题就定下来了，没有签合同（这个为现在埋下了巨大的隐患）。厦大里面最古老的房子没有之一，每层有共用厕所（没有独立卫生间）。唯一两个电器空调和热水器。我进去的时候起码画了2000添置洗衣机，电磁炉等物品才能住的。第二次交租突然告诉我有个物业管理费，嘛当，当初就写了个收据，没啥合同。一定说是跟我说过的。恶心坏了。没窗帘，我自己挂。空调坏了，我自己修。电灯坏了我自己换。嘛当，想着也没有啥大事情就自己弄好了。不要这么娘炮。天天找房东。结果呢一年到期人家2话不说，呵呵因为物价上涨，所以房租也要涨。我从来没有拖欠过每次交租。而且他是教职工租房房子，很是便宜，然后一年到期的头7天突然跟我说下一年的房租要涨200.之前跟我没有任何联系。因为没有合同人家就是要涨就涨。但是他的房子几乎没啥成本，是厦大租给教职工做福利的。然后我想找房子，但是那个月突然有工作要忙。最后没能找到满意的。我只能说是要继续住。然后叫他过来当面说了1小时。晓之以情，动之以理。最后喉咙都感觉出血的情况下。在他带来各种不平等条约的合同上只涨100.签了1年。这不，住了没2月就要拆。收到消息到搬走也之有10天左右的时间。就在2013.12.30日我打电话跟房东说我2013.12.31日要搬走。然后晚上过来交接一下房租的事情。（这个时候我有一个月的押金，和交了3个月只住了两个月的房租）他满口答应没有问题。 2013.12.31日晚我回到老房子跟他打电话问他什么时候过来交接。第一，他矢口否认我交过一个月的押金。并且否认之后签的合同上同样写着交了押金的条目。第二，以其他理由推脱不能来交接。真的，当时我整就无语在空中。然后我叫他当面过来对质。我还有他写的收据。然后我拍照发过去给他。他又说2014年1月1日。转帐给我。基于很多很多小的细节。我在离开房子的时候拍了些照片。以防止要出什么妖蛾子。 在这个劣币驱逐良币。权利利益群体更加压迫普通群体的地方。我唯一找到的解决方案就是移民。 这段写的异常愤怒。下面写点轻松的。 完全正版化其实，全面转到Linux的时候，已经很少用盗版了，除了虚拟机里面的Windows是盗版。然后全面用Mac以后，几乎没有啥盗版。只是一开始的时候也没入啥App。但是2013年，我买正版没有三千也有两千了把。第一次买超过100rmb App的时候还是很纠结。但是买过了以后就没啥感觉了。然后买了几次以后。感觉300左右的App还是能在接受的范围内。所以，看到心仪的App一般就入了。6rmb这种几乎都是顺点的。所以，2013年对我来说是完全正版化的一年。对了，我没有虚拟机，所以我也没有用Windwos。所以，现在我可以自豪的说，我现在Mac上面全部App是正版。当然今年的正版化，我还尝试过音乐。不过iTunes里面中国区买不到。天朝的几家付费的我都冲过一两个月尝试了一下。但是都没有心仪的。不过后来Xiami For Mac。确实做的好，本来我对虾米的印象是很糟糕的。但是Xiami For Mac居然能改变我对虾米的看法。真的做的好。然后今年去电影院的次数也满多，iMax也看了不少场。对了，如果你一定要揪出来说，我只能说我承认我看的爱情动作片还是盗版。不过我也会尝试着弄成正版。 工作Sumi来厦门也快两年，其实长开智以后，只要某一刻突然停下来回头瞅瞅，都会发出时间过的好快的感觉。文人骚客说就是“人生天地之间，若白驹过隙，忽然而已”。 2013过年一来，大概迷茫过3-4个月的样子。迷茫的原因是我周围都是一堆“一条龙”能搞定的人儿。我所谓的”一条龙”就是现在流行的”full stack developer”。 我boss Kevin Cao。 泪流满面，工作室来过好多波人参观。如果是熟悉的人都会说一句“Kevin是我见过从设计到技术都能达到国际水准的一个人”。如果不熟悉的人听到啥“Grid Diary是你设计的？还是你写的？我这么多年来第一次见过又能设计又能写代码的”。可想我一个hello world级别的小菜程序员压力有多大了么。 90后”一条龙”王放放同学，泪流满面，从后端，前端，设计，iOS，Android, MacOSX App.一条龙了。居然tm的还是文科生跨界友情客串。你叫一个读了破壁坑爹4年的软件工程专业的88年大龄hello world级别程序员情何以堪。 90后“一条龙”廖逸聪小朋友， 泪流满面，又是一个从后端，前端，设计，iOS，Android, MacOSX App.一条龙了。而且华丽丽的看清楚了破壁坑爹的软件学院本质。大二休学闯荡江湖。然后见到我的时候大部分时间拉着我聊南怀瑾。然后时不时的送自己烤的小饼干给我吃。嘛当，不仅可以写的一手好代码，还能做的好一手小饼干。恩我去面壁思过去了。 当看到我司RoR高富帅写起iOS也绝不含糊。旁边的100平土豪灰用起Photoshop也是一溜一溜的时候。我就纠结了，嘛当，写个程序写hello world级别。连个PS都不会用。太丢人了。 在这样一群优秀的人儿当中，那时候我想，嘛当我也可以画图的嘛。好歹小学时候画小金鱼拿过小红花的。这样我跟小聪妹子骗来了一本「像艺术家一样思考」。然后郑重其事的去厦大小超市里面买了铅笔和纸准备学习画画。初级目标是理解美。中级目标是也能自己熟练的捣鼓点UI。终极目标是向Boss那样一条龙下来。而且是高水准的一条龙。 可是事实就是任何东西没有经过一万小时的锤炼是无法成为专家的。只有幼儿园水平却想着要弄出专家级别的东西。而弄不出来的时候我心情就会变的很压抑、烦躁。白天工作的时候思绪就会不集中，素描也没有能坚持下去。就画了大概2周左右的时间。 在学习素描的过程中，我不仅仅想学画画这样一个技能。我就是想一口吃成一个胖子。我还同时看着后端而且后端我还在Golang Ruby NodeJS中徘徊。今天这个配置环境Go写个hello world折腾一下。明天弄个Vim环境试试Ruby的写法。 大后天弄个Textmate的bundle写一下NodeJS。每个东西都浅尝辄止的学习。却想做出一个庞大的系统出来。 最后，我居然还在开始看着OSX编程。也不知道脑子咋想的。觉得自己在iOS端输出不够，就逃避的想说恩。我去先学一学OSX。到时候项目快速推进到OSX上。来弥补我在iOS端的薄弱输出。事实是OSX上面的坑更多。各种API一点都没有iOS上的好用。而且桌面端的思路跟移动端的思路完全是两个概念。双修其实是有难度有门槛的事情。 各种折腾2-3个月，我还是那个我。无法画出漂亮的UI，写不出比hello world更加复杂的后端，写不了OSX的程序，本来应该写好的iOS代码的质量也没有得到提高。时间成本在折腾中流失。 在我的各种愤怒中。萌小萌同学和Boss让我意识到。如果单项技能没有一万小时的修炼是无法达到我想要的高度的。而我不能三心二意的做事情。这样反而影响到了工作质量。 我用了一段时间艰难的让自己承认自己只是一个天资普通的人。我只有踏踏实实的一个小时一个小时单线程的努力。累计到了一万小时才是最终的王道。 代码 &amp;&amp; 技术今年早些时候，Allen Xu（又是一个全端工程师，你们够了！！！天天刺激我）的引荐。我有幸被唐巧加入他的群里。诚惶诚恐，巧哥的群有点像传说中大佬caoz的群的方式。进群的唯一标准是巧哥觉得你ok。虽然不可能像caoz的群里那种随便一个都是大佬。但是目测巧哥的群里大部分伙伴们的实力（其实就是除了我）应该能代表目前中国iOS&amp;&amp;Cocoa的顶级实力。肯定有一些潜伏的大神还没有露面出现。不过现在群列表里都是开发这百万用户，千万用户，亿级用户产品的大大们。平时有个啥问题丢进群里。几乎是立马可以得到解决方案。群里也经常分享整个业界的最新资讯。2013年能进巧哥的群，是一个非常大的惊喜。从里面收获颇多。 2013年的代码质量从被review的情况上来看，可读性依然一塌糊涂。最更本的原因是我只会一个一个的单词（还经常打错）。而无法连成一句完整的话。其实我有很努力的去改进这个问题。都变成每次写代码，起函数名字是整个写代码过程中花费时间最长的部分。但是效果不明显。 今年技术关注的重点依然集中于iCloud。由于过年前的匆忙修改，并且没有覆盖测试，导致iCloud出错。最终导致Grid Diary没能一炮而红。其实主要责任是我的。为了解决第一次发布版本的错误。我们用了整整2个月，不停的推出版本来修复错误。而因为没有写测试用例覆盖测试。往往我们修复了一个问题，结果就引出了其他问题。关于Gird Diary这一年遇到的坑。我觉得可以重新写一篇blog了。 然后为了解决iCloud + Core Data同步的问题。又去尝试设计过iCloud + Document的方法去同步。然后在建立索引。但是由于demo完成度太低。和老用户升级带来的麻烦。此方案最终抛弃。所以现在依然是iCloud + Core Data的同步方式。 今年另外一个重点关注的东西是ReactiveCocoa。虽然我还是hello world级别。不过在github上watch一个这样活跃的项目收获还是巨大的。可以看到什么是开发的热情和执行的高效。看到他们为了一个名字而讨论怎么样才合适。所以ReactiveCocoa对我来说不仅仅带来了一种新的设计思想和代码编写方式。它还为我展示了一个国际化开源项目的活力。 感情父母其实在16-7岁的时候跟父母的关系其实蛮紧张的。因为年少吧，现在能多为其他人考虑问题以后。那就多体谅父母。只是亲尚在，不远游。自己在外面漂泊着如果父母有个什么事情也帮助不了的时候觉得自己挺自私的。不过爸妈还是很尊重我的意思，我也很感谢他们并没有强迫我去做我不喜欢做的事情。 萌小萌和萌小萌有时候也会斗斗小脾气，拌拌小嘴。经过无数次的商量。异地恋的弊端应该都全部解决了。然后今年准备去给未来丈母娘看看，希望能是一个好的结果。 兄弟今年好兄弟应该说还是比较圆满了。老闷和飞哥多年后的今天终于找到了各自的真爱，可喜可贺。wwl荣升当爹不说，多年的盘终于出去取得突破性进展。回去抱大腿的日子指日可待。六的结婚日程应该已经提上日程，大豪宅已经住上，差不多也是当爹的节奏了。鑫哥？鑫哥号称只剩下钱了。随时可以回去抱大腿了。 计划说好听点我并不是一个循规蹈矩的人。说实际情况就是自制力极其差，拖延症状严重。每次制定的新年计划都是像是个安慰剂。安慰一下拖沓了一年的自己。给自己心里暗示说恩下一年会做的好一点。其实25年来每次都这样的说法，而每次只有等到12月31日的时候来悔恨自己。 所以此时此刻我很矛盾。 不知道是否应该把2014年的计划下来。 2014年，我希望我能好好的学习一下洋文。 2014年，我希望萌小萌能快乐过每一天。 2014年，我希望长辈身体健康。 2014年，我希望我能和Sumi继续走在改变世界的路上。 最后最后，这就是我2013年的一些碎碎念。从2013一直写到了2014. 就给我的伙伴们当个乐呵乐呵的东西看看呗。","link":"/2013/12/31/2013-annual-summary/"},{"title":"2014年 Oh My Star 总结","text":"本文仅作为个人学习记录使用，也欢迎在许可协议范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助，您可以使用RSS方式订阅本站，这样您将能在第一时间获取本站信息。 开篇扯淡最近啊一堆一堆的人们在晒自己的 App 收入。其实吧，2014年。我也参与弄了个工作以外的 App 出来。不过一直觉得这点收入太低实在不好意思说出来。不过看着大家都晒的好欢乐的样子也忍不住说说。（其实是看见有人垫底儿，哈我就不告诉你是谁） Oh My Star 缘起软件想法这个想法其实挺早就由各种混沌的想法构成了。最开始的时候是大概 2013 年初左右，现在坐在我旁边的 linjunpop 高富帅他在 Github 上的 Star Repo 已经直逼2000+。王放放童鞋的也快1000+ 的 Star 数量。然后大家就在说做一个 App 来管理啊来管理。不过说归说。对于一群懒癌末期的人来说。说完我们就去联机打游戏去了。 不过我的 Star 数量也开始变得多起来。得益于我的渣记忆力和 Github 对已经 Star 过的项目的渣搜索能力。经常找一些记得 Star 过的项目，但是它已经淹没在茫茫 Repo 海了。 一直到大概2013年8月份的时候。我感觉吧，我特别需要一个管理 Github Star 的工具。没有怎么办，自己做呗。 鉴于我的渣编程能力和懒癌末期，我决定拖一个人来一起弄。所以，我把我师兄 Noark9 忽悠下水了。 名字名字其实我挺早前就想好的，追述到我第一次使用 Oh My Zsh 的时候。惊为天人。感觉这个 shell 真她妈的叼。又再次鉴于我渣一般的洋文能力。我那会暗暗下定决心。我以后的项目都要叫 Oh My XXX。 简单又好记。还是向 Oh My Zsh 的致敬。（这个想法在微博上被萌妹子 Gril iOS 一语道破。这是后话。然后出现了也喜欢用 Oh My XXX 来命名自己项目的16岁少年 NSTongG，这更是后后话了 ） 所以，霸气的确定 这个管理 Github Star 的 App。名字叫做 Oh My Star。 前期调研要钱没钱，要啥没啥。就有个想法，做个东西。还要忽悠其他人来做。这个不靠谱啊不靠谱，所以我装模作样的做了一下号称是前期调研的东西去忽悠我师兄。 我大概查看了一下 Github 的 ALEXA 排名。然后用 IP 数量加上预估拥有 Mac 的人的数量再乘了一个极小的百分比。得到最终 Oh My Star 的用户在1万用户到2万用户之间。 按照1万用户，9.9刀的定价计算 10000 x 9.9 x 6.1 x 0.7 = 422730 rmb 五五分以后，一人有20万耶。 马上就可以迎娶白富美，当上 CEO。走向人生巅峰了哦。 Noark9 被成功忽悠。 Get it. 纠结的推进开发在幻想了人生巅峰以后。我们两个开始着手开发来着。那会我 iOS 都没有玩溜，Noark9 刚刚购买了 Macbook Air 的两个 OS X 初哥就开始吭哧吭哧写代码了。 我算懂一点点 Cocoa Touch。但是点开 Cocoa 的类。各种傻眼。还是她妈的很不一样啊。随便调用一下跟预期不符合啊。我熟悉的 ViewCotnroller 呢。 怎么拖出来怪怪的。怎么随便拖个 TextField 会多个东西嵌套着。然后，格志爆 iCloud bug 了。恩我跟师兄说了声去去就回，然后就留下我师兄一个人吭哧吭哧的弄了。去的时候喵了一眼恩，我师兄还在装 Ruby 呢。(我这么黑他不会被砍死哈) 过程就是各种腥风血雨啊。无数次想要放弃都是师兄抗过来了啊。（我就主要弄了下 Core Data 和 iCloud 部分） 所以 iOS 和 OS X 其实很不一样。从使用方式到产品设计再到代码编写。我倾向于认为他们是两套系统。只是恰好都使用了 Objective - C 而已（那会没有 发布 Swift好吧）当然目前两者开始大规模融合。不过我认为因为使用场景的不同，再设计产品的时候依然需要认为是两套系统。 设计程序员写程序最怕啥。 做出来丑的像坨翔。师兄说这个样子看着不行啊。这么丑谁会花9.9刀买呢。 没人买，怎么去取自己的白富美啊。被师兄这么一说我也是鸭梨很大啊。所以我暗暗下定决心，不能让 Oh My Star 看起来太丑。 UI当时我们大 Sumi 还是有全职设计师的哦。还是妹子哦。于是我花了两顿 KFC 的代价。忽悠了我们张玲玲同学来画 Oh My Star 的 UI。期间又不定期花费若干干锅田鸡、KFC 等资源。 图标现在的图标是第二个版本。 第一个版本是我先用了一天学习了一下 Sketch。然后花了 2-3 天鲁了一个图标出来。像这样的 我会告诉你这个五角星的角度我算了几页草稿纸 后面上线以后有人说跟 QQ 空间一样一样的。然后师兄就开始用幽怨的眼神看我。意思是说操谁会花9.9刀买个 QQ 空间啊。这样我的白富美是娶不上了。我又再次暗暗下定决心，不能让 Oh My Star 的 icon 看起来太丑。 可是我画的师兄不满意啊。愁死我了。最后没办法我就在微博上找设计师啊。一个一个厚颜无耻的发私信过去说我是小鲜肉啊。赶紧点我点我啊。人家一看这是神经病吧，一开始没人理我。睡了一天晚上起来，后来有个设计师回复我了。是平潇大大。然后我就画了一个极其华丽的草图过去给他。 解释一下我的意图： 我们是一个 Github 周边应用。如果可以，我很想把章鱼猫给搞进去。但是我们仔细看了 Github 版权和授权。是不可以出现章鱼猫的。 那不能出现我就想着，出现一部分是可以的吧。所以有个触手。暗喻章鱼猫。 这个触手在搞毛呢， 在整理星星啊。暗喻我们是一个管理 Github Star 的应用。 嗯那，这就是我华丽的草图。 平潇大大就依靠我已经够详细的草图把 Oh My Star 的现在版本的 icon 画好了。(其实吧，现在有一个第三版本的图标哦。这是后话了) 官网官网的介绍是我写了中文，师兄以及贺锦同学帮忙翻译的。官网是我找了我高中同学夔大做的。官网之所以这么丑，是因为我真的找不到人来设计了。555。师兄我尽力了。 视频由于官网太丑。洋文介绍也不知道介绍清楚没有。我决定，弄个视频出来。然后我花了一天晚上写了个剧本。花了一下午录制了一下。花了几天学习了一下 iMovie 然后做出来了现在官网上的那个视频。 推广当上线以后，我以为。我就可以坐收绿油油的美刀了。可惜我错了。根本没有人购买！我做了个这么叼的诶噗噗出来。居然没有人知道。才意识到推广的作用。 推广做了以下几种 论坛 V2EX Ruby-China Weibo 的几个大 V：池院长 巧哥 大别 onevcat 等 邮件 论坛就自己去发的帖子，然后弄了抽奖。送了一些兑换码。也有一些朋友支持。 然后厚着已经没有的脸皮去找池院长，巧哥。他们在微信公众号里面和微博推了。继续厚着脸皮找大别、onevcat。然后他们再微博上推了一下。同时配合着做了一周的半价。 说两个事情，一个是大家都很好，虽然平时感觉他们都是高冷的状态。但是一听说是独立开发者做的。大家都还是很 nice 的帮着宣传。二是，冰点这一周销售了到目前为止的80%以上的销量。所以很是感谢帮忙。 邮件是怎么一会事情呢。当时冰点一周过后，立马没有人买了。很是着急。然后我想了个办法，我在 Github 人肉找了一些 Star 数量超过500的人。然后发邮件去推销 Oh My Star。这样我一天发30封左右的邮件。可能会卖出1-2份。但是带来了巨大的副作用。有2个人直接回复骂娘。然后说 Oh My Star 是垃圾应用。其中一个还去推上@Github 说我滥用邮箱。叫把 Oh My Star 从 Github 里面除名。骂我可以，骂 Oh My Star 就怎么都忍不了。本来准备叫师兄批量爬邮箱然后发送推广邮件的。我反思了一下，觉得这个行为确实很不妥。然后就停止了发送邮件的这个行为。 目前收益排名被推广的第二天我一上线。喵神就说我发达了。 我一头雾水。然后他说已经在Developer Tools 中国区付费榜上排第一了。我一看我操，还真是。心里还是有点小激动搭。赶紧打开iTC去看卖了多少。结果才10几份。我这个落差的心情啊。连开发者的本都没有回来。不过由于各种时差的关系其实比这个多一些。只是报表还没出来。后来居然出现在了中国区付费总榜前10了。其实那会也就50几份。后来一直冲到总版第三。虽然只是短短的几个小时，但是对我来说这个意义还是非常大的。说出去也是可以装逼了的。 收益目前用户是 414.购买用户是 265.其中80%是冰点购入目前上线一年总收益是1300刀。（没有算2年的 Mac 开发者。一堆其他投入： KFC 啥的）然后五五分。（我感觉我需要躲着我师兄了） 多说两句：其实吧，感觉没有赚钱相反用的更多了。因为一旦我看见卖出一个，我就会说，恩今天可以加个肉。 卖出2个我就会,恩今天这个贵的 App 可以入了。这样不知不觉其实钱都还没有拿到手。就花费出去了，结果第二天一看，人家退款了。欲哭无泪啊都。 总结感谢首先感谢购买和使用 Oh My Star 的用户。然后再次感谢这篇文章里面出现过的所有人。哦对了有两个没有提到 一个是 ianva 他提供了现在 readme 的样式文件。一个是 Ruby-China 上为 Oh My Star 写了一个 alfred workflow 的用户。同样很感谢。 Remote我和师兄以及全部参与 Oh My Star 项目的人。全部都是在线上沟通以及协作。使用到了一下工具： Github QQ Trello Heroku Gmail 这一年学习到了什么 以后我做的软件将会永远不降价。因为根据我自己的体验来说。本来我很开心的买了 App 使用着。就算隔了半年之久看见他降价了我还是会很伤心。同样我的用户也会有这样的感受。所以以后我做的软件将会永远不降价。 因为 MAS 的机制和一些市场上的考虑。不管是 iOS 还是 OS X 的 App 。都应该是 免费 + IAP 模式。这样一定是主流的配置。 问 &amp; 答问：Oh My Star 以后会降价么 答：不会 问：Oh My Star 以后会涨价么 答：看心情 问：怎么购买 Oh My Star 答：猛击连接 问 ：OMS 很久没有更新了，还会维护更新么。 答 ：会。16岁很厉害的小哥 NSTongG 已经答应帮 OMS 修复 bug 了。 问 ： OMS 的未来有什么打算 答 ： 有一个大大的计划 问 ： 那这个大大的计划会去实现么 答 ： 会 问 ： 什么时候呢 答 ： 遥遥无期（遁走）","link":"/2015/01/20/2014-oh-my-star-app-annual-summary/"},{"title":"2016年移动互联网职业入门规划指南","text":"本文仅作为个人学习记录使用，也欢迎在许可协议范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助，您可以使用RSS方式订阅本站，这样您将能在第一时间获取本站信息。 碎碎念2016年才开始，再次感慨时光如逝。2015一年面基了好多人，其中认识了好多小朋友。有的小朋友真的很厉害，而有的小朋友也有我在当时年纪的迷茫。觉得在28岁这样“长者”的年纪，自己也算做一个有故事的男同学。写下这一篇文章，也算写给18岁的自己。至少证明我来过这个世界。 在2012年，我以当时的能看见的未来写过一篇IT人士入门指南。 几年后的今天来看，有一些内容和想法是过时的、片面的、不完善的。所以一直想去更新一下。无奈觉得自己好像也没做出什么能拿出手的成绩，觉得写出来会不会误人子弟。 但是后面我发现，我的某些想法虽然在很多人里面看起来很“傻逼”。但是如果能分享给更多的人可能会让这个世界变得美好这么一点点。加上自己近一年时间的伪创业＋伪独立开发，思考问题的方式可能带来一些不一样的见解。这还是值得去做的一件事情。分享是种美德。 本文目标读者：在12岁～22岁喜欢互联网或者想从事互联网工作的小朋友们。 做人首先谈谈人的本身。做事先做人，一个老生长谈的问题。接下来的讨论情况基于更加普遍的情况(特殊情况不再讨论范围)。 根据我的观察，一个能在IT行业做到顶尖的人，如果换一个行业或者职业，加以时间很大程度上也能做到新行业的顶尖。因为他们身上都有一些共同的特质——专注、勤奋、渴望。也就是那句著名的“Stay hungry. Stay foolish.” 为什么名校的人们更容易做到顶尖？我认为跟他们读不读名校其实关系不大，而在于他们考进名校的时候就已经让自己成为了那种做事能 专注、勤奋、渴望的人。而12-18岁这样的年纪大家做的事情也只有一个就是去高考，所以他们把这个事情能做好进入了名校。自然以后不管从事什么职业和行当，他们只要继续的专注、勤奋、渴望，都不得不成为行业的精英。多说一句在当下这样学识、教育获取更加扁平的情况下(世界顶级大学都有公开课)，国内大学教育在我看来并重要。所以在人生的不断旅程中，如果想要成为行业的Top级别，需要自己先问问自己是否能保持周围学霸的那种专注、勤奋和渴望。 专注、勤奋是都能找到具体的实践办法。而渴望就是内心深处的一种感觉，要有这种感觉最简单的就是喜欢。所以才说要从事自己喜欢的职业。 这部分适合各种情况，所以也不展开说了。以免写多了像鸡汤。 大学专业我前面已经说过，在当下这个时间点(2016年)。在国内的大学99%都是骗钱的，高校是以企业化的方式来运转。尤其以贵国示范性软件学院为首。当然也不是说去上大学就是一无是处，上大学是你第一次扩张你人脉的关键时间点。你读越是好的国内院校，你周围的人也会越优秀。物以类聚，人以群分。周围优秀的人越多，你被优秀化的概率也越高。 关于学校选择我认为的指标 海外名校&gt;985&gt;211&gt;其他 沿海的&gt;内陆的 发达地区的&gt;落后地区的 每年学费少的&gt;每年学费贵的 好逃课的&gt;严格的考勤的(这个纯属我的主观感受，因为做事的动力应该是源于你的内心的认同感，而不是一些外部的力量) 在这个信息被平铺的时代，你将来从事的职业跟你读的专业可以一毛钱关系都没有。而你的职业生涯出不出彩，在于你在这个方向投入了多少时间。能达到一个什么样的程度。工作这么几年，我见过读数学的，读经管的，读英语的，读医科的，都变成了优秀的IT从业人员。所以如果有论调说你不是科班出身的，什么什么没有基础。那我觉得只是你投入的不够专注，和渴望做成这个事情。 互联网时代或者说移动互联网时代，那些大佬天天说的拼的是人才。我想也就是这样拥有专注、勤奋、渴望的人吧。 作为一个当下时代的人必备技能英语说来惭愧，我的英语并不好。差到难于想象的地步，差到了令人发指的地步。但是我却见了太多太多对英文不屑一顾的做技术的小朋友。当他们问出问题的时候，我甚至会吧 stackoverflow 的答案丢给他。结果换来的是一句看不懂。这时候我只是心里默默的说了“滚你麻痹，不要做IT了吧”。 英语的重要性是最最最重要的。 套用别人的一句话来说“是投入最少，产出最多的投资”。 能自由的访问全球互联网在贵国这样恶劣的生存环境下，至少至少一年100元的付费投入是觉得必须的。不要每天折腾那些免费的方案，时间比钱重要的多。 使用而且只使用 Google在你是真正的互联网以后，请把你浏览器的搜索引擎设置为 Google。养成只使用 Google 的情况。如果你连Google都不会用，那可以在IT人士入门指南中找到一些如何使用 Google 的方法。 学会如何提问提问的智慧 终身的学习和独立思考学会提高自己的智慧去独立思考还是当下这样信息成灾难的时代，每天接受的信息实在太多太多了。如果缺乏足够的智慧去独立思考，那将是一个巨大的悲剧。就真的变成了人云亦云的傻逼。当新的一波浪潮过来，就是被冲到沙滩的牺牲体。 学会接受意见相左理性观点无脑喷的除外。如果是有人提出了相左理性观点，要学会理解上下文。这样会为自己的观点完善和提高自己的思辨能力。 学会接受新的事物不要用惯用的思维去理解和接受新的事物，这样容易带有偏见。 盗版用盗版是臭傻比这个事情，无数人说了无数。我就只说一点就算万不得已了，使用了盗版的人。你要明白这个是一种偷窃的行为，你应该为此感到羞愧。你要产生一种我将来有钱了的时候一定要换成正版的想法。而不是到处的宣传盗版的分发处和一股我就用盗版我光荣的姿态。 因为这几乎是一个人最基本的诚信问题啊。 中医为了你的生命健康，请远离中医。 PS: 更新一下，好多人说我无脑喷。我就贴一个视频吧。 多的不说了 你怎么还信中医 移动互联网职业规划当下的世界是一个快速发展的世界，由于科技的进步世界中在不断的加速中。这就导致一个什么问题，就是如果说大学教育是为了获得就业能力的话，大学里面的课程和专业分类已经远远落后于这个时代。所以我觉得现在你读的专业和毕业以后想要找工作其实可以没有任何关系。 下面的职业都没有什么高低之分，他们对于一个公司来说在不同方面上给予价值的体现。任何职业的顶尖人才对于公司来说都是可遇不可求的。当然工资是一个市场作用和多方面因素的结果，我的建议是不用寻着当下看上去最高的工资，而应该去找最适合自己的职业。因为长远一些来看，你做到高级程度的收益要远远大于初级程度的收益。如果选择了一个不适合的，你很难从内心产生源动力去把自己的水平推向高级甚至顶级。 我把这几年看到的职位大概简单说明一下： 技术路线一般来说计算机科学学院和软件学院对应出口的都是做技术路线。也就是俗称的程序员。但是我见过的课程里面，都是想要把学生教育成为一个服务端程序员。其他的方向从课程体系到老师态度都是脱离时代的。 其中一些基本工参考IT人士入门指南而且往往都是你深入了解某个方向，但是其他方向也是需要有基本的常识。因为总的来说计算机技术的出现都是为了解决问题的，他们之间并不是孤立的。大道至简、重剑无锋。了解更多的知识有助于你向高级进阶。 服务端简单来说写程序的逻辑和数据处理。主流使用语言及其框架有且不限制于 PHP: Laravel Python: Django Ruby: Rails NodeJS: Express.js Java: 貌似自己写 Go: 貌似也是自己写 Erlang: 应该也是自己写 C++: 还是自己写 简单说服务端的挑战是随着公司业务增长的时候出现的需求: 高稳定性 高安全性 高扩展性 高并发性 高自动化 快速迭代 语言和框架都是解决问题的工具，当遇到问题的时候。肯定是拿起你认为最顺手、最合适的工具来解决眼前的问题。所以在此再次说明：技术是不应该带有偏见的。如果有，请拿出代码打我的脸。 如果你对写出更快、更强、更高效的代码感到兴奋和心情愉悦的话。服务端的方向可能是你好的选择。 前端目前来说前端可以包含了Web前端和手机前端。没错，iOS 和 Android 其实也能算前端。 Web前端博大精深:刚刚入门的你应该从 HTML5 和 CSS3 开始学起。 然后就是进阶到 JavaScript 的欢乐海洋里面。 iOS：Swift 的入门比 Objective－C 要高的多 Android：其实 Material Design 也挺好看不是 如果你对做出来的东西想要酷炫的动画和交互感兴趣，前端不妨考虑一下。 安全当电子科技无孔不入的时候，安全成为首要重要的事情。我认为未来肯定会有专门做安全的独角兽出现。而不是不要底线的流氓公司。 当然，如果你对当下的权威表示不满，你也可以黑了他们。安全历来都是矛与盾的相争。都是黑帽子和白帽子的江湖。 如果你对数学的有孜孜不倦的好奇之心，安全领域一定会满足你。 当你横空出世、崭露头角。巨头们都必须得花重金抢你。 其他在存技术领域里面，还有一些可能比较边缘的职位，可能是需要足够大的公司才能专门独立出来。 测试白盒黑盒，能抓住Bug的都是好盒子。 运维运维掌握着整个公司的服务器资源，公司的所有程序都得跑在运维搭建好的环境里面。公司网站挂了，服务挂了。可能第一个背锅的人。 产品最重要的事情说三遍： 并不是人人都能成为合格的产品经理！产品经理的入门门槛很高！并不是人人都能成为合格的产品经理！产品经理的入门门槛很高！并不是人人都能成为合格的产品经理！产品经理的入门门槛很高！ 路漫漫其修远兮，吾将上下而求索。 我也说不好，毕竟才刚刚入门而已。 产品经理大到整个世界的发展趋势，小到一次屏幕上的点击都需要去思考。把用户需求放到首位确实不能只嘴上说说，而是需要用心去想，在想想，然后才做到产品里面去的。 所以，什么样的产品是以钱为第一位，什么样的产品是以用户为第一位的，其实一眼就能看出来。 设计设计的地位在进几年不断的提升。一个好的设计是产品的一个强有力的质量保证。 当然在互联网公司，设计师的工作主要是Web网页设计，各种宣传图设计，App UI设计，各种动画效果设计，有能力者还可能是各种视频的制作者。 如果你对美好的事物天生的喜爱，而且强迫的追求各种对称和归纳，再有绘画的功底。那你天生就是干设计的命啊。 运营你天生逗比么？你天生段子手么？你天生比其他人能写么？你天生就能找到好玩有趣的内容么？ 你天生的话痨么？你喜欢跟其他人叨逼叨么？你喜欢多管闲事么？ 如果你有上列描述的情况，恭喜你，你有成为一个天才运营的潜力。 市场渠道在国内估计就是那些七七八八的渠道你要明白，你手里拿着钱要能去买量来进行推广。 曾经的SEO，现在的ASO等 游戏其实吧，做游戏才是真的赚钱，你看各大电视台的广告都换成手游了不是，他们大概又有一下职位： 游戏客户端 游戏服务器端 游戏策划 希望你就在下一个月流水过亿的团队里吗，年终的时候发宝马哦。 其他还有最佳火热的 GrowthHacker 啊等等，由于我都没有足够深入的经验也就按下不表，随便提一下吧。 创业如果你选择进行小团队创业或者做一个独立开发者，恭喜你。以上提到的技能，你都会点一遍。 人生归根结底，还是你自己决定要成为一个什么样的人。就前几天有个朋友跟我喝酒喝多了说了一句：“你啊，就是太清高。所以才赚不到钱。” 我无言以对，因为我也会有对金钱的渴望，却又要想着站着堂堂正正，对我来说太难太难了。回望过去，只能说我不忘初心。所以到目前为止，人生最重要的是过的痛快，心里想啥就好好的干啥，跟着自己的心走。 总结从99.99999%的角度上来说，我说说的都是错的。 只剩下内心一点点的自己在肯定而已。 其实我也只是泛泛的谈了谈，具体每个职业需要做到高级都需要一万小时去积累。 又是一篇拖了20天才断断续续写完的文章，质量上自己都不是很满意。 希望能帮助到即将进入互联网行业的你。 硬广时间我目前现在生活在新西兰。如果需要婴儿奶粉、保健品、程序员熬夜神器。均可通过么么爪新西兰代购购买。价格在海外直邮上有一定优势，但是淘宝上低价没法比。优势上只能用我那可能并不存在的人品担保都是正品。","link":"/2016/01/12/2016-IT-professionals-Getting-Started/"},{"title":"2016年中国社交产品分析个人报告","text":"背景分析这是最好的时代，也是最坏的时代2016年，号称直播元年。 因为手机的普及率更加广阔了，手机的性能上来了，网络速度更快了。 所以大趋势是产品 这是大技术环境决定产品的走向。所以，一定存在社交产品的机会在里面。 以下的产品分析主要从移动端的视角出发。 两大巨头——微信和微博微信是连接人与人 微博是连接人与资讯 所以他们的社交形态也是迥异的。 直接说结论吧： 微信和微博是不同形态的产品。相互不可替代，而且微博最近一两年发展巨好。微博的股票就能说明这个问题。 如果想要通过相同产品思路想要做大，就算利用运营切入一个细分领域，我认为都没戏。更不要说是要干掉他们。那种东西没想象空间，没活路。 现有产品分析直播直播的社交模式我认为比较奇特，呈现出一对多的形式。主播对多个观众，多个观众对少量主播。观众都大部分时间是希望跟主播互动。而观众和观众之间的互动并不频繁。所以直播方式跟我理想中人人都是平等的社交方式是违背的。多说一句，也只有微信在用户端做到了人人平等（PS:对开发者特别是独立开发者，微信还是很严的。虽然能理解，但是作为一个有想法的小个体还是忍不住吐槽一下） 我预测直播经济在1年之内依然会是一个高速增长的市场，但是增速会放慢。并且政策入场和巨头布局会清洗一波产品。如果没有特别特别好的理由和资源，这个时候在切入当前模式下的直播社交是不明智的。 总结：我觉得我做不了直播类型的社交产品 陌生人社交我个人认为社交产品一定一定是绕不开性的。不但如此，我还认为陌生人社交的基石一定是基于人体内基因隐含的交配欲望和渴望获得多巴胺分泌的本能行为。 虽然陌陌很想摆脱约炮神器的限定范围。我认为能在上面约到炮，算是一个陌生人社交的及格线。 前两天也看了探探新 CTO 的一篇 Blog，对里面的一些观点惺惺相惜之感。因为男性用下半身思考和女性比较含蓄和谨慎的特点。所以我认为所有的陌生人社交都应该是站在一个普通女性用户的角度去设计。这样才能带来最大的平台化利益。这个懂得也都懂。就不展开说了。 总结：如果我要做一款陌生人社交的产品，我会做一个婚恋 App。马佳佳曾经做个一个叫极简的产品。类似一个新时代的个人简历，我认为很适合改吧改吧就成一个婚恋社交产品。其中有个功能我印象很深刻，就是选几个问题，自己拍一段小视频来回答。以便他人更好的了解你。这不就是非诚勿扰的 VCR 环节嘛。我认为会是如果能做一定是一个很好的婚恋 App 兴趣社交这里比如有游戏、有二次元、有追星。如果说是细分领域，这三个领域都足够大，市场量足够撑起一家独角兽规模的公司（个人认为）。 但是同时也是一个特别特别拼资源、拼运营的产品方向。在当下，我认为很难凭单借一个好的产品形态和创意去切入。 总结：如果真的要做一个类似的产品，一定是建立在有强大资源和给力运营的基础上。要不很难 校园社交我一直觉得校园社交是一个不太好的方向。 我认为 Facebook 不是校园社交起来，而只是从校园里面运营起来的。当年校内网改名人人网，我一直觉得是一个很棒的决定。 为什么校园社交不是一个很好的方向。最重要的理由就是目前能看到的校园社交产品都是专门为校园场景打造的。会造成以下影响： 用户数量确定，因为当4年后大家毕业进入社会。失去了校园场景，校园社交产品也就失去了使用的价值。也就是说每年都固定的失去用户数量。 无法获取校园场景以外的新用户，还是场景限定的结果。 所以，我认为目前能看见到的一些主打校园社交的产品都没能很好的解决上面这个问题。 总结：如果我要做一个校园社交类的应用，我会从按照高中用户开始做起一直做到大学，以学校为最小颗粒度，然后是区，市，省来划分运营。运营发力在每年的校花，校草评选。日常运营着重于学校八卦。可能相对的贴吧是最大的竞争对手之一。看过美剧Gossip Girl吧。 专门说学校八卦的用户粘性肯定好 LGBT社交其实可以归为陌生人社交一类。但是由于群体的特点和日渐开放的民智。最近几年也是冒出不错的产品出来。属于一个细分领域，也会出一、两家领域龙头最后通吃。 总结：估计我很难做这类的产品，因为确实缺乏相关经验 Snapchat的中国制造Snapchat 从火了到现在。我听过好多小朋友说我们应该有一个这样的东西。 如果说微信是中国 Facebook 的话。 那我们也应该有一个中国的 Snapchat。 目前我能看到想做中国 Snapchat 的并且我觉得比较不错的有 FaceU、闪聊、Remark。 FaceU 不多说了， 闪聊的启动视频我觉得传递的信息好棒是我今年以来看过最棒的 App 产品视频。Remark 是我来深圳以后结识的一群很年轻的朋友做的，他们目前的 Slogan 我觉得很棒叫“分享比留下更重要”。 这三个目前我觉得闪聊做的比较有趣一点、接地气一点但是逼格就显得不那么高。 职场社交Linkined、脉脉和会会等应该能算职场社交吧。我的感觉是脉脉上正经的消息没啥亮点。但是经常在 QQ 群上能看见匿名爆料企业和同事的种种秘闻截图分享。所以我觉得还是人类深处的偷窥八卦欲望才是这类产品日活的关键所在啊。 IM如果社交产品算上 IM。我还想说一下 Telegram 、Slack 和 iMessage。 Telegram 我最直观的感受就是快，那种消息在相互之间传递的快能被作为用户的我在使用过程中感受出来，我认为这就是最核心的竞争力。当然安全之类的其他因素也是基石。但是用 Telegram 我会觉得聊天时一件轻松简单的事情。 Slack 作为一个团队提高协作效率的 IM 来说。目前我无可挑剔，能集成第三方的插件，让所有的协作工作都可以由 Slack 发起完成以后又回到 Slack 的体验真的是棒极了。如果硬要说缺点的话就是在中国的速度和高级版本是按照人头收月费的。 iOS 10 的 iMessage 在消息发送上增加了很多有趣的效果，开放了贴纸商店。使得本来一个低配版本的微信提高到了一个中高配版本。也许 iMessage 的消息效果并没有多大的技术难度。但是为什么 Apple 要怎么做。我觉得是为了让用手机聊天的过程充满乐N趣。这点是我认为最重要的事情，也是我觉得这一步虽然不是红利期，但是 Apple 还是没有放弃 IM 这个战场。 其他想说的Same 机缘巧合去拜会过总部，拿过一堆他们的贴纸好喜欢。 也好喜欢创始人说的把关系做轻，让用户没有负担。里面的妹子质量也特别特别高。拿到了很多钱钱，但是目前用户体量也是没有更加进一步的扩展。期待后续的动作。 快手在五道口默默替换掉网易 Logo 的公司。第一次看见的时候却是心里觉得里面内容有点 Low。但是最近半年在看到快手，就是满满的敬佩之情。他们触及了中国互联网之前难以触及的用户人群。但这一点我就觉得快手是一个非常非常成功的产品。 我会尝试的方向说了这么多有的没得，如果让我选择在当下中国一个社交新产品。 我会做一个主要用户人群是二、三、四线城市的 95 后，，基于图片、短视频处理后在聊天方式上很有趣的社交产品。 具体是什么样子，要真的开始做了，才会知道吧。毕竟空想的 idea 不值一钱。 以上是这两天以来的胡思乱想，谢谢您的观看。如有异议，欢迎讨（si）论（bi）。","link":"/2016/09/27/2016-Social-Product-Analysis/"},{"title":"CoreData VS Realm （2016-02-23更新）","text":"本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. 碎碎念OhMyStar 2 也进行了一段时日，我把持久化的方式从CoreData 换到了 Realm。有些感悟，顺手就记录一下吧。以下评论都是自己很主观的感受，无实际测试数据支持。 论 iOS 的持久化iOS 持久化其实也没多少选择， 高端一点CoreData、Realm、FMDB、KV类(LevelDB等)。低端一些直接一个 NSArray 就写成 Plist 也能持久化下来。 在网络环境越来越快的当下和大部分应用数据都可能是网络应用，如果业务逻辑并不复杂，其实极端一点就只用写到 JSON 转 Object 就好了。而且一堆这样好用的封装，远有Mantle 近有YYModel。 所以需要持久化的时候，我觉的可以慎重的评估一下需求。想明白了，后面可以节省很多事情。 本文章主要对比 Realm 和 CoreData，其他的就不涉及了。 Realm优点入门门槛低Realm文档就算一个字一个字扣着读完，一个下午就足够了。而且还有中文版本，不要太友好哦，有点不习惯诶。 文档覆盖了80%的使用情况，甚至有些太简陋的嫌疑。但不管怎么样，这种入门条件比起 CoreData 写了三个月都没搞清楚 Context 要好的多。 在库的工具链上，安装一个 Realm Browser 以后就不需要其他辅助了。还是简单。 几乎做到了上手即用的程度。五星好评。 PS：我用了一个通宵把 OhMyStar 2 的持久化从 CoreData 换到了 Realm ，优化调整了大概5天左右达到勉强可以用的情况 。在这之前并没有任何 Realm 的经验。 据说性能好一些Realm官方介绍Fast一段中 Counts Queries Inserts 在写这里的时候我顺手Google了一下 发现一篇Core Data, FMDB, Realm 性能测试。我就多说几句 总觉得大家对 CoreData 误会蛮深，代码 Fork 看了一下， 总觉得不应该这样写来比性能的，但是一时半会也不知道怎么改。我只能说我在优化 CoreData 的时候根据 WWDC 上教的还是提升很高，另外一个事情是 CoreData 一般都用 Sqlite 做后端。所以如果你的查询是经过优化的，确认打出来的SQL语句科学以后，Sqlite(CoreData) 跟 Sqlite(FMDB)我觉得性能就算有差距，这差距没有能大到选择方案的决定性因素。如果使用 CoreData 遇到性能瓶颈，你应该仔细的研究 WWDC 和几篇很好的文章。确保你的 CoreData 使用方式是正确科学的。 没有需要架构Context那种烦人的东西应该也算Realm简单的一个方面，Realm 只要保持自己线程里面，自己的 Realm Store 操作是正确的即可。如果是 CoreData，怎么架构一个科学的 Context Stack 就足够让我头疼一整，iOS 还好，界面是一个接着一个(VC跟VC之间的层级关系很清晰)。而 OhMyStar 2 这种 OS X 桌面应用场景VC之间很复杂，线程之间Context的关系让出现很多问题。 支持 NSPredicate从 CoreData 转过来并没有太多的不适应 很简单的使用多个存储文件举个例子，多用户登陆情况下。用户是单独的存储文件，和全部用户使用同一个存储文件。后者需要每条用户数据都要关联一次当前用户，所有查询用户数据的时候，你都必须加上当前用户的查询项。而使用每个用户单独一个数据文件的时候，整个存储结构会清爽很多。 技术支持至少实在没法的时候还可以去微博上吐槽他们，他们其实也有极大的热情来解决你遇到的问题。CoreData 这种遇到问题就只能自己默默的吞下。 细粒化通知 (更新 0.98.x 版本以后可以获得精细化通知)看最新的文档已经更新： Notifications 有了这个通知我思考的结构里，写入数据的所有线程都可以在后台了，而且更新UI的时候只用在需要的地方监听需要的类。这个进步 缺点关联关系弱的一逼简单说来就是对象跟对象之间的一对多关系和多对多关系。并不能映射，需要在双方里面都写上属性，此外还需要在设置的时候两边同时设置。查询时候也是 NSPredicate 也仅仅只支持一些一层的查询，没法做出带SUBQUERY的复杂查询出来。 强制内省容错机制导致存储文件不断变大Realm本身感觉有一个数据容错机制。但是这个机制在数据库文件有错误的情况自己修复的时候，会无限增大。具体我这里表现为，打开看只有3000条数据，但是文件大小已经有3GB。重现Bug也很容易，只要你在写数据库的时候,用Realm Browser查看一下，crash之后在打开就很容易出现。 官方文档里面有说到会造成这种情形的原因，我在尽我所能的避免问题以后。存储文件还是会有可能不那么夸张的变大一些。但是用Realm Browser查看数据是正常的。所以我觉得官方应该提供一个函数，可以删除掉那些容易的东西。保持存储文件的干净。 没有细粒化通知～～也就是说，当我在某个地方做出修改。 我其他地方只知道Realm有修改，但是没法知道我是增加、修改还是删除了数据。不知道我更新的是那一条数据。据文档说，将来会解决这个问题，就只有拭目以待。～～ 增加包体积据官方说会增加1MB左右的包大小，如果你是一个小体积应用，或者是一个几千万用户的主流应用。对包大小敏感的话慎用。 核心代码目前闭源对于在我们这样一个作恶满天飞的天朝长大的孩子来说，有些孩子对闭源这个事情还是挺在意的。不过官方说将来会开源，我还是倾向于相信 Realm 他们的人品。 CoreDataCoreData 相关资料相对多一些我就简单说 优点官方支持 &amp;&amp; 亲儿子系统自带，Apple支持 带图形化的Model编辑对于视觉化动物来说比较友好，也可以清楚的知道自己设计的 Model 之间的关系 强大的关联关系以前不觉得，用了 Realm 才发现 CoreData 的关联关系如此好用，一对多，多对多。想怎么查询就怎么查询，可以写出很复杂的查询逻辑来。 强大的查询虽然可能在设置NSFetchRequest的时候感觉很多东西要弄，但是复杂也带来了强大的功能，NSFetchRequest 可以设置很多，比如限制查询数量， 限制只返回某些属性值等等。就不展开说了。 精细化的通知可以知道具体插入了什么、更新了什么、删除了什么。这样在刷UI，比如一个tableview的时候，你就可以控制的很准确。 缺点入门门槛高CoreData 是一个博大精深的技术，不要妄想几天之内可以用的很溜。CoreData 是一个博大精深的技术，不要妄想几天之内可以用的很溜。CoreData 是一个博大精深的技术，不要妄想几天之内可以用的很溜。 如果没有足够的时间和精力去接入 CoreData。 那选型的时候应当慎重考虑。 需要一些工具才感觉好使不管是老手还是新手，使用一些第三方的封装库和工具都会大大的提高使用 CoreData 的幸福指数。 mogenerator 是必须必须要的。 MagicalRecord 无愧 CoreData 第一库，据小道消息 主要贡献者 Saul Mora 可能去了微信了。 Context其实还是 CoreData 门槛高的问题，对我来说。Context之间的关系和线程之间的处理让我感到很头痛，特别是 OS X 是一大堆VC铺到屏幕上，我水平又菜，出的问题很多。 多个持久化文件很麻烦不是说不可以，但是真的好麻烦。 有个第三方库有解决CoreData这个问题 CoreStore 但是我用着不是很顺手最后弃用. 总结其实吧用啥持久化都行，具体还是需要看你的需求和方案上来说哪一个方案更加适合。 如果简单说来，就是 Realm 更加适合一些业务逻辑不怎么复杂的场景，团队配置要求不高，有经验的人稍微看一下午就能上手。 CoreData 更加适合业务逻辑复杂的情况，团队配置要求比较高，有经验的老手也需要几周甚至更长的时间才能科学的使用CoreData。","link":"/2016/01/19/CoreData-VS-Realm/"},{"title":"OhMyStar2 产品方面的自问自答","text":"本文属于自问自答，解释一些 OhMyStar2 的产品思路。 注意 本文具有强烈的个人感情色彩,如有观看不适,请尽快关闭. 本文仅作为个人学习记录使用,也欢迎在许可协议范围内转载或使用,请尊重版权并且保留原文链接,谢谢您的理解合作. 如果您觉得本站对您能有帮助,您可以使用RSS方式订阅本站,这样您将能在第一时间获取本站信息. Q &amp; A问题1: OhMyStar2 的愿景是什么？OhMyStar 的愿景是做最好的 GitHub Star 管理工具。说句不要脸的话：从 OhMyStar1 开始，其实 OhMyStar 系列一直都是市面上能见到最好用的 Github Star 管理工具。 当然形成这个局面的并不是 OhMyStar 多么优秀。而是 OhMyStar 出现的比较早，让我有足够的时间去思考和设计整个产品。并且这是一个非常非常小众的需求，导致市面上没有太多类似的产品。以至于一些竞品的出现，都带有浓重“致敬” OhMyStar 的感觉。我并没有看见有更加优秀的方案来解决 Github Star 的管理问题。 问题2：OhMyStar1 存在哪些问题？1. 分组和 Tag 功能重叠。不够简单直观。分组和 Tag 功能合并为一个。经过思考以后认为 Tag 比分组更好。因为单同一个项目需要给多个分类定义的时候。多 Tag 给用户的感觉比多个分组要准确的多。 2. 软件功能较少，用户粘性不够好。软件功能不够，就增加一些使用频率高的功能。Trending、搜索和 Readme 阅读模式。 Trending —— 每天、每周、每月各个语言多项目热度是一个很高频的使用场景。而 GitHub 官方几次改版都越来把它隐藏的更加深。我能理解官方的意图是让你自己多写代码，少去无意义的参合热点。但是浏览 Trending 是很多人每天的习惯，所以一定加上。 搜索 —— 是我在 OhMyStar 1 上使用最频繁的功能。能让我坚持写完 OhMyStar1 的一个重要动力就是当时 GitHub 官方对自己 Star 过的项目搜索支持相当糟糕。同时 OhMyStar1 的搜索其实很弱鸡。所以这么重要的一个功能必须进化的更加强大。 Readme 阅读模式 —— 当在使用某个库需要参考 Readme 的时候。可能就会在浏览器和编辑器 or Shell 之间来回切换。Readme 阅读模式的设计是可以钉到所有窗口的最前面。让用户更加方便的去一边操作一边看 Readem。 3. 一些 GitHub 轻度用户 Star 项目较少甚至连一个项目没有。完全没有使用 OhMyStar 的必要性。解决这个问题这是在设计 OhMyStar2 中最重要的一点。为什么呢？如果用户 Star 越多的代码项目，他管理代码项目的需求就会越高。如果能解决这个问题，就可以源源不断的创造管理 Github Star 的需求。那 OhMyStar 就能源源不断的得到新用户。在意淫完 OhMyStar 要有无数用户的以后。最后的问题就呼之欲出——如何让用户不停的 Star 项目？ 这是我认为 OhMyStar2 中，我最骄傲的产品设计部分。那么 OhMyStar2 是如何解决这个问题的？ 使用 OAuth 认证，获得 Star 和 Unstar 的能力。（PS：OhMyStar1 是不用登录的，输入一个用户名就行） Trending 入口在第一个层级。只要打开了 OhMyStar 就能让你 Star 。 增加分享&amp;导入功能。这是我认为 OhMyStar 2 最厉害的设计。不但解决了增加 Star 项目的难题。还获得了互联网变现的入场券。扩展了 OhMyStar 的商业模式。具体功能就是，我在 Tag 上右键的菜单里面有一个分享选项。点击以后，会生成一个包括此 Tag 下的所有项目的网页。你可以把这个网页URL分享给任何一个人。然后，其他用户打开这个网页后，只要安装了 OhMyStar2，点击网页上的导入按钮。就一键导入了这个网页上的所有项目。从此以后，OhMyStar2 就不再是一个单机 App。 它获得了用户之间互动的功能。（PS：可惜我的运营不利造成了目前为止几乎没有人发现使用） 4. UI 丑陋、老套、过时 OhMyStar2 的 Logo 著名 UI 设计师藻堂大大友情赞助的作品。2015 年就设计完成。 OhMyStar2 的大部分 UI 是花费了大价钱请高级设计师 YuXiao Chen 的作品。2016 年中就设计完成。 OhMyStar2 里面的编程语言图标，是我花了好几天整理出来的。大部分找不到 svg 版本的 icon 都是我一笔一笔画的。 因为设计稿的完成时间和最终 OhMyStar2 上架有很长的时间间隔。所以仔细看 OhMyStar 2 的话会有一点点设计貌似不是最新的 macOS 规范的感觉。不过相比较 OhMyStar1 来说。这简直是翻天覆地的变化了。（PS：我真的尽力了） 问题3：OhMyStar2 会不会有 iOS 版本或者其他平台的版本？作为一个产品经理的时候，我当然希望 OhMyStar 有 iOS 版本，甚至全平台版本覆盖。不过鉴于真实资源的情况我只能说 iOS 是在计划内的。但是要同时保证最佳体验和数据同步的技术问题，OhMyStar 的 iOS 版本其实难度比想象中的大。不过可以保证的是，OhMyStar iOS 版本的整体产品设计比目前可以看到竞品的产品设计要好上不少。 问题4：OhMyStar2 是一个什么商业模式？ 采用免费基本功能+订阅解锁高级功能模式。这个貌似不用怎么分析了，已经是主旋律了。 还记得我设计的分享网页导入导出功能么？曾几何时，我期望所有用户都积极分享自己觉得有价值的项目。然后造成巨大流量。大家争先恐后的分享和传播。这样 OhMyStar 就真的是一个互联网产品了。 本来我还一直规划一个联盟：去他妈的老子就是永远不降价联盟。因为我认为现在 app 动不动就打折和促销其实是损害了开发商和用户双方的利益。特别是在打折之前购买的用户，心里面可憋屈了。所以具体操作方法大概就是，起草一份 LICENSE 。里面规定了只要使用这个 LICENSE 那这个软件就不能降价了。如果被发现违法协议降价了。那这个开发商就会进入“去他妈的老子就是永远不降价联盟”的黑名单里面，信用度全部丢失。然后这样一份“去他妈的老子就是永远不降价联盟”肯定具备话题传播性。在联合几个独立软件开发商。进行第一次发布。 OhMyStar2 也会获得足够的曝光。一举多得，一箭n雕。 OhMyStar2 永不降价OhMyStar2 永不降价OhMyStar2 永不降价 问题5：OhMyStar2 现在用户量多少，收入如何？曾几何时，我以为 Free 以后会有大量的用户增长，其实并没有。曾几何时，我以为 OhMyStar2 能帮我养家糊口，然而更加没有。 OhMyStar2 的日活和月活数量跟 OhMyStar1 几乎一样。 我觉得我还是算作一个比较良心的开发商。OhMyStar1 的用户都可以免费获得一年的 Pro。导致最核心的目标用户群体没有付费的理由。而且 OhMyStar2 由于我的能力问题，在运营和技术上都没有做的很好。所以尽管有不少好朋友义无反顾的订阅年费。 但现在的全部收入依然不够支付一年的服务器费用，少到我都不好意思说。所以从经济效益上来看，OhMyStar 亏损相当严重。 问题6: OhMyStar2 未来会怎么样？首先，OhMyStar2 的产品规划进度，远远超出我拥有的开发资源。而我又是一个拖延症晚期，所以迭代速度可能很慢。但是不会立马死掉。 其次，如果当我决定不在维护 OhMyStar2 的话，我可能会选择开源整个项目。这样至少能留下点什么。 最后，其实上面也能看出来，OhMyStar2 其实没那么多人用。让我觉得没有特别的成就感。所以如果您恰好看到了这篇文章，恰好有使用了 OhMyStar2，恰好又觉得 OhMyStar2 还有那么一点用。那希望您能多多推荐给周围的朋友。我在此谢谢各位客官老爷了。 OhMyStar2 下载链接 后记其实这篇问答在没有发布的时候，我就已经规划在发布应用以后立马写出来进行推广传播。可惜懒癌晚期啊。拖拖拖，拖到了大半年以后。所以很多细节想法和具体取舍决策有模糊不清的感觉。想好好说说，却又杂乱无章。 在原有的推广规划里面，接下来我应该还会再写一篇 OhMyStar 的技术问答，说一说哪些躺过的坑。希望自己能尽快写出来吧。","link":"/2017/11/08/Product-Q-A-with-OhMyStar2/"},{"title":"简单测评Bong(深度吐槽,胆小、承受能力差和心脏病人需要陪同观看。谢谢合作)","text":"本文仅作为个人记录使用，也欢迎在许可协议范围内转载或使用，请尊重版权并且保留原文链接，谢谢您的理解合作。如果您觉得本站对您能有帮助，您可以使用RSS方式订阅本站，这样您将能在第一时间获取本站信息。 ##开篇扯淡 今天为了测试Bong支持游泳的说法，我差点挂在厦大的游泳馆里面。这天太冷了，而我自己又对自己的身体素质预估不住，跑去露天的游泳池。偌大一个标准池就我一个人，随意做了几下准备运动抵不住冷风吹，深吸一口气眼睛一闭跳进去。XXX，我能说脏话么。蛋都要冻掉的节奏啊，心中顿时把年少时候在电视上看到冬天跳入结冰河水游泳的新闻编者草泥马过了千万遍。顿时想转身起来，但是一想到下去还钥匙时候丢人死了。就奋力的向前游。接下来，我体验到了在水里皮肤会有痛的经历。记忆力从来没有过的。由于水温比身体温度低很多全身的皮肤感到刺痛，寒冷刺皮肤啊。扛着想今天至少要游1km吧。游了200m的时候开始全身麻木or适应了刺痛感，好过一点。咬牙游到600m的时候还觉得可以到1000m的结果650m米的时候开始感到不适。以自己科学常识隐约觉得是体温下降太多导致。所以就在700m的时候翻身上岸。经过长途跋涉回到宿舍里面赶紧冲了一个热水澡。然后躲到被窝里面小睡了1个小时才感觉命回来了。 我并没有才入手就吐槽，而是使用了5天。打了两次羽毛球，游了一次泳。才开始吐槽的哦。 ##缘由 2013这一年没入啥大件，但是小东西弄了一堆。也蛮浪费钱的唉。智能穿戴设备去年年末火的时候就一直寻思着入一个看看，不过一直狠不下心来。而今年入夏以后主要运动几经波折固定在了游泳上，深度观察以后觉得靠谱的两家fitbit和jawbone的手环都不能支持游泳。所以一直在等待一个支持游泳的手环出来。 然后在11月的某天，看weibo的时候看到kenwone上在卖一个国产手环，听说过的另外一个国产手环(咕咚)节操早就掉没了。这个好像还不错的样子。点过去一看。靠可以检测游泳，最重要的是一个VIP特权。号称这一批用户可以永久享受每一代设备更新。我靠爱占小便宜技能开启。然后怂恿着大厨先弄了一个。然后自己也就付款了一个。小算盘打着，这么高调。至少能撑过2代吧。那就至少有两个。有两个的话，就差不多保本有赚了。啊哈哈。 所以我入Bong有三个理由 我想试试智能手环之类 支持游泳 性价比 ##Bong的整个运营 买了bong，然后关注了多关注了bong。weibo时不时瞅两眼。 说微信公共帐号。这次发现公共帐号还是蛮有必要的。 保存了每天更新 虽然在我看来每天的内容做的一般。但是起码有人味。不那么机械冷冰冰。 通过weixin好感度提高蛮多的。 然后说第一次跳票，其实都很能理解。所以第一次听说也才10几个的退款率。整个前期运营功不可没。 不过后来的整个运营就只能用惨不忍睹来形容了。 跳票以后的进度不清楚。然后承诺的15号发货。15号虽然发了大部分(猜测)。但是被发货的用户们(我)对整个顺丰订单毫无信息。已经习惯了taobao系流程的我来说很不习惯。没有安全感。就算整个订单系统来不及做。丢一个excel表格起码也能丢上去把。起码能有个地方能查到啊。很遗憾什么都没有。 我知道bong现在才8个人。按照官方说法是有1400个要发。算发一个需要5分钟。简单算术8个人需要做15个小时才能发完。按照官方说法感觉肯定发一个的时间超过5分钟。所以觉得他们在一天之类肯定发不完。 我想说的是，说是跳票到15号。不是就算到15号才拿到货开始发把。既然跳票了，应该把这个发货时间也算进去。比如说15号发，应该是13号左右开始包装填写。然后15号叫来顺丰就妥妥的一次性发出去。坐等用户反馈。都使用跳票技能，就多跳两天准备充分肯定更好。 ##开启吐槽模式 ###到手 恩，怀着激动的心情。我在17号拿到了bong。 下面是多图杀流量时间 盒子怎么说呢。之前在weixin上运营的时候玩了一手，说是第一批盒子质量不好，换了一批，当时似曾相识的感觉。不过我以为是为了追求品质。不过打开顺丰袋子的一个感觉是。艹，这个不会是第一批盒子吧。浓浓的山寨感觉。 恩knewone还多送了点东西，不过自己这张贴纸感觉不喜欢。本来想贴到电脑上的。但是上手感觉质量跟github的贴纸有一定差距加上这个小怪物不是我的菜。就没有贴了。然后是钥匙收纳盒。没想到用到哪里。自己住的地方被告知20天内搬离。又是一把辛酸泪。 恩 bong的包装盒就不多说了，几张卡片。一张有团队成员签名。一张是类似说明书。两张强调VIP的尊贵身份。 ###吐槽手环本身 首先是外形 官网上是这样 实际上是这样 首先，两头是细的这种设计。啥时候变成了水桶腰设计。 第二，我买的是黑色的把。为啥看着跟银色一个样子。这是cosplay iPhone5s的太空灰么。 我不知道这张能不能清楚的看到。灯的地方被胶糊住了。这个感觉太恶心了。是拿到手以后最恶心的地方。也可能是期望抱太高了，导致的心里落差。前期的运营以为bong是注重细节的团队。但是嘴上说说和实际做到是有差距的。这里我看见了bong的差距。 转过来，我第一次看见bong是怎么充电的。一直说的都是点触式充电。才知道 原来后面有两个孔啊。保密性做的很好啊。然后图上在两个充电孔下面也能清楚的看到，明显的由于某次没有对准而导致使劲压下去造成的刮痕。再次觉得嘴上说说和实际做到是有差距的。 手环的两侧接缝触有一层摸上去明显不平整。 正面上有一条淡淡的线。觉得应该是材质本身的线。但是出现在正面稍微仔细就能看见。 嗯，基本上硬件部分就这么多了。 ###吐槽说明书以及整个引导流程 说明书叫那个简单啊，一个卡片几句话搞定。还以为是已经设计到返璞归真的地步了手上即用。但是还是看了一遍。(此时此刻卡片没在，而且是5天前发生的事情了，凭借印象说了) 首先出现的是一句最好使用PC链接。环顾四周，方圆10米内没有发现一台PC。那OSX可以不可以，我也不知道。唉，先插上试试呗。 接下来一句话引起了我的注意。说的是插上大概五分钟就可以拿下来使用了。！！！！！ 插上大概五分钟？是多于五分钟 还是小于5分钟？如果不插会发生什么呢？插到5分钟的时候会发生什么呢？ 插久了又会发生什么呢？有没有提示啊。靠。那5分钟我需要怎么计算呢。打开手机的秒表功能么。我很难想象一个让我都手足无措的东西。去介绍给媳妇儿用。或者带给爸妈用。 然后我以为App里面应该会有详细说明的！！！！结果没有！！！连接前和连接后都没有。 ###吐槽App 自己做iOS的，难免吐狠了点。bong团队看到了不要介意。又或者你们都拿到投资了要不把App外包给我们国际大厂Sumi来做把。 第一次发短信的时候注册不上 远看想扁平化设计 近看背景还有材质 这是Moves的白天版本么 每次打开都要Loading。为啥不先打开再载入数据啊 我在第三天的时候app叫重新登录一次。然后第一天的数据没了。 为啥tableview上的排列时间是00:00在最上面。不应该是当前时间在第一个位置么 除了跑步以外，其他的都归类到运动里面去了么。分类太少了 各种统计图表有待改进 电量检测不准确 第一次使用了一小时看掉了10%多的电量。现在用了5天了。掉了7%的电量。而且最近两天都没有电量变化 ##吐槽使用中的情况 早上唤醒的时候只有一次。现在是冬天啊，不能多摇几次么 一开始我带左手，后来打羽毛球的时候想想带在了右手。导致刷牙的时候会震动一下进入类似散步模式。 不能识别多种运动 记得说过可以记步的。但是实际没有。觉得有记步的数据会更好。 ##总结 好累啊 写一晚上了就这么多把 ###优点 自动识别睡眠 防水 可游泳， 虽然我也游了200m的自由泳但是没有识别 如果发第二代的话性价比高 ###缺点今天blog内容。 ##One more thing 如果给我来运营，我会把这次bong的人数控制在200人左右。尽量做好第一批口碑。然后把第一批变成死忠粉。根据反馈来不断迭代很进化。然后在把已经行之有效的小米打法拿来打一次。 其实跳票的时候 只退了10几个人我觉得已经几乎要做到了。但是如果说能收到以后在退款。我想这个数量应该是惊人的。而且把之前前期做的所有努力付之一炬。 然后App的话我会提供很多种运动种类给用户选择。然后数据上传做数据分析和机器学习。这样以后就能识别更多的运动类型了。 恩 福利就说这么多。多的留着啊哈哈。","link":"/2013/12/21/evaluation-bong/"},{"title":"iOScon 广州之行","text":"序广州之行，是大概月初的时候偶然看到iOScon的中国年会。然后发现广州有分会场。就过来看了。这是我第三次为了技术大会跑广州。 第一次是Fedora16的发布。然后在广州大学城里面。大学名字居然我给忘记了。可是我还记得过去看那一张张洋溢着青春的脸，一想起这些脸庞，我就唏嘘不已。感觉到自己不年轻了。那次还有主席的一同前往。 第二次是36kr的创业日。那次叫上了刚读大学的表妹。去了看了传说已久的网易大厦。那次叫人山人海啊。还忒喵的热。全部看下来，就觉得只有一个公司比较nice。其他的昏昏欲睡。不过那次也看见了”姐夫”。 第三次，也就是这次了。也是一大早起来赶汽车，然后过去了找了一个类似KFC的中式快餐解决的午餐。就直接过去了。 前奏到了大门口，才发现去的是T.I.T创意园。这个类似是类似那些大都市用废弃厂房改造的还行的那种生活区。昨天才偶上人人看了小表妹的照片知道她才去过。然后遇上了某个动漫展吧。人山人海的cosplayer。哎~~~可惜不好这一口。。也没有留足观看。只是找那个贝塔咖啡确实令人困惑。绕了T.I.T一圈。也就近距离的围观了一下一些cosplayer的妹子+汉子。不得不说，这些确实不是我的菜，虽然还是有几个妹子比较正，还有些妹子穿的比较少。但是一块脸被涂的雪白雪白的。看着触目惊心啊。不是我的菜。还有穿的比较少那些妹子前面各种宅男各种怪叔叔各种影像设备的拍啊。虽然当时我很想拍下他们来。一是实在不好意思在各种高端的长枪短炮面前掏出我那弱弱的手机，一是大家都在拍妹子，我却拍一群爷们。也忒恶心了。不过，这样也给这次广州之行添色不少。 贝塔咖啡啊哈哈，终于见到传说中的贝塔咖啡了。也许是被那几个天天刷屏的贝塔老板给营销了一下。我进去以后还是失望了一把。可能是希望太高了吧。进去以后的感觉跟普通咖啡厅没什么区别。可能2楼布置成小会场和有3个wifi算是特色吧。本来这次活动已经缴费提供了茶水，可是我还鬼使神差的叫店员推荐了一杯号称点的最多的奶茶，结果拿上来看居然是立顿的。顿时感觉坑爹的不行。可能贝塔咖啡的主打不是这些吧。环境还是比较不错的。如果可能我也想有一间这样的小咖啡馆。 Summer这次最大的收获之一，就是见到summer。summer是第一个看我博客然后立马加我gtalk的人。然后我们交换了一些对软件的看法，我又请教了他一些iOS开发的内容。反正我是感觉有点相见恨晚的那种。哈哈。还有，就是发现他跟我老婆居然只是隔了一个县。跟谈大侠一个地方的。世界就是这么小。再一次在我身边发生。 活动小结Mac应用程序人机交互设计可能演讲的人，确实仓促上阵吧。觉得演讲的大神准备的不是很有干货，加上老早起来就去赶车，听得我昏昏欲睡啊。不过还是学到一些东西。但是隔了一天也就忘记了。最近再读一本说演讲的书看来自己也要练习演讲。 电子阅读的难题演讲者是南方周末新媒体的运营总监。我认为这个主题是这次最精彩的部分。keynote是所有人里面做的最好看的。演讲思路清晰。然后老总也蛮有文艺范儿。nice。老总从中文字体的结构说起，还说了衬线字体和非衬线字体。刚好前两天才看过介绍。原来用非衬线字体是因为我们的屏幕设备还没有达到那么搞的分辨率，其实用衬线字体才好看呢。但是视网膜屏的出现，使得衬线字体可以开始向往。还让我明白一个东西就是，如果猛一看视网膜屏和非视网膜屏，你会觉得说贵了1000块，看上去还不就是那样。但是如果用了一段时间的视网膜屏，你是很难在回到以前的分辨率的。由俭入奢易啊。 老总接下来也谈到了一些中文字体的问题。其实，天朝的问题，已经是出在根上。我们看到的现象才会表现出来，不管是足球还、软件还是版权。全部都只因为根出了问题。哎，多的不说了。中文字体到目前就没有人做。收费的就方正和不超过个位数的厂家在做吧。开源的文泉驿还有一个记不住的在做。少的可怜，我也只能希望，我们以后能有更多更好的字体出现吧。 老总还分享了一些做阅读app的经验，比如用core text是可以控制到像素级别的渲染，但是不支持超链接。我一开始没明白为啥要超链接，阅读就阅读呗，后来看见keynote上的一张图片我就明白来，现代app阅读，比如出现了某个著名人物的名字，我一点。就可以弹出一个“东西”来解释这个人物或者特有名词。所以，就很需要webkit的架构。但是webkit封装了很多东西，有些是在做阅读的时候不需要的。需要裁剪，但是webkit由上游的apple控制着，如果深度定制了一个webkit的版本，结果来了一次webkit的大版本更新，之前的定制就有可能白做了。这样就只能在一个很高的层面上去做出再core text和webkit的选择，老总最后说，希望能再两者之间出现一个平衡点。那电子阅读就会发展的更好。 阅读的版式也是相当的重要，但是我也没有做过。用我也就用用Kindle看电子书，但是老总一直再强调，依然是，如果要做好一件事情。每一个细节都值得注意和改进。做iOS的人，多少都会受到Jobs的影响去追求完美。 关于电子阅读，我有着更大胆的猜想。iBook2和iBooks author的出现虽然是面向教科书的代替，可是我觉得，以后文明的记载，会从文字逐渐的过度到照片、声音和视频这样的多媒体上。因为这些电子多媒体的形式在一定程度上能表示出来的信息更多更丰富。多媒体会更加的多，文字占主导地位会慢慢的削弱。所以，我觉得电子阅读的创新，并不是在超越传统的阅读文字。而是超越阅读文字这种形式本身。 iOS游戏/应用的开发、推广和变现这个是一个Google的老总来推销他们的AdMod的。哈哈。但是明显比上次那个TX的妹子在网易推销开放平台要来的亲切的多。Tx那些如果是去找不懂技术的说，可能效果很好。但是我个人觉得一跟一群技术的宅男说一些很不Cool的话题，是很无聊的一件事情。除非你长的和没有上过天天向上前度娘的那种胸襟和女神。 一开始大概说的是，移动互联网这个大蛋糕，起码会持续增长到2014年。然后，作为一个独立开发者，应该还是有机会去分一点点蛋糕的。 然后说了一些做怎么推广，怎么方便的事情。很细微，很诚恳。可是我还没有上架过app。所以没有太多深刻的体会。期间老总不断举例子，因为Google的嘛，很多例子是Android上的。可是现场清一色的iPhone iPad。老总每次说完都很郁闷的自嘲一下。哈哈，很不错的人。 后来的提问环节，有一个也是做广告平台公司的美女问了老总说，怎么才能做好一个广告平台，老总讳莫如深的说了一些比较官方的发言。其实我想说，如果你能帮开发者和广告主都赚到了钱。那就ok了。 茶歇时间这个时候上去了5个公司，发布招聘信息。除了南方周末新媒体，其他几个公司，我觉得看着人就不是很舒服。找工作很不顺利啊。哎，还是自己太菜了。然后跟summer聊了会。 构建稳健的iOS推送服务“姐夫”。上次去36kr开放日的时候就见过了，不过离得比较远。当天就忘记了。只记得说xx年前，网易还是他的老东家。这次见面，他说他是珠三角技术沙龙的组委之一。恩，这个组织在python-cn的邮件列表里面经常看见，没想到这次还让我身临其境了一把。所以，我也算见了世面的男人了。 jeff讲了推送的原理，然后开源了一下他搞推送的后端和前端中间件。都是用Python写的，看来还是需要好好的用python啊。作为一个技术出身的，然后自己创业的人。各种羡慕嫉妒恨啊。希望jeff哥越做越好吧。 iOS产品如何实现快速版本发布正点科技的正点闹钟。100天提交了10个版本。通过了7个。10天为一个迭代周期。cool。真正的敏捷。很多想法不谋而合。作为一个创业团队，重视团队的建设，起码表述出来的东西我觉得很可贵。 终演讲结束以后，因为要赶车回东莞。连summer都没有告别，就匆匆走了。结果7点到流花车站的时候，没票了。到大朗的车要9：30才开。没办法，去旁边的KFC坐着码blog。早知道就去聚餐了。在东莞这种天朝最神奇的城市果然不方便啊。","link":"/2012/03/25/ioscon-guangzhou/"},{"title":"IT人士入门指南","text":"##选择 除了IT行业，你可以选择的更多。 我知道，在经历了天朝１２年的应试教育以后。来大学第一天的感觉就是”我自由了“。这是一个最好的感觉，也是一个最坏的感觉。好是，你确实可以自己决定很多事情了，坏是，你确定你做出一些比较有利的决定么。上大学以后你确实知道你想要什么么。如果我这样问你，你能回答么。天朝的具体制度不去评论。我们以生物最基本的要求来要求自己，就是生存下去。是不是你说你都活了二十左右年了。难道不是生存么。我想说的是依靠自己的生存，有爸是双江，也蛮好的阿。是官二代，富二代。那我觉得，你的生存问题也不大。做一个好人就好了。大多数师弟师妹，你们应该好好考虑一下４年以后，你能怎么活下去. 过于明确的功利性选择向为有识之士所不齿,但是,如果当一个刚刚走出校门，面对残酷的商业竞争而举足失措的少年,或者是对于一个几乎耗尽了他的家庭生存成本终于读完了大本,却在就业市场上徒劳往返,不断奔波碰壁,甚至连最基本的生存都已难以保证的失败者，我们再义正辞严的宣讲什么 “君子谋道不谋食”,再讲什么“君子喻于义”，再讲什么“一箪食，一瓢饮，在陋巷。人不堪其忧，回也不改其乐”，这虽然省心省力，而且占据了道德的制高点，却未免有点不厚道。 做IT很辛苦。加班就是必备技能。所以，我说除了软件学院，你可以有很多的选择。也许你听说IT高工资，但是我说，高工资全部在一线大公司，一线大公司，全部在一线城市。一线城市的幸福感真的很低。你那高工资跟那房价一比，跟工作压力一比。觉得真的一般。而如果你回家，考了公务员或者银行或者垄断国企，我觉得你生活质量和幸福感会很好。所以，人各有志，最好自己客观的评价一下自己，适合做什么事情。想过什么样的生活。好有一个全局的打算。将来是可以公务员可以事业单位可以国企可以垄断行业。所以，除了IT有很多选择。 综上所述，我只想说，除了搞IT，你还有很多的选择，让自己的人生更加的美好。说了怎么多。你最后还是决定留下来从事IT这个行当的话。你可以继续接着看了。 做为一个软件开发人员，或者说做为一个IT行当的新手。我在下面三个选择中不断徘徊，不断挣扎。就为了这三个问题，耽误了很多学习的时间。所以，我有必要将我在这三个问题获得的经验分享一下。（PS：就算你不是电脑专业的也可以有些收获) 第一个选择——电脑 第一个选择和第二个选择密切相关：你需要一台什么样的电脑和你需要用什么样的操作系统。 你如果对这个问题觉得很奇怪了，或者说你要说你觉得电脑只有价钱的区分，操作系统只有windows xp 到 windows vista 到 windows 7。那我建议你多了解一下外面的世界。这情况是微软的成功，中国软件的悲哀。 扯远了，拉回来。我们为什么要选择电脑（品牌）。作为一个开发人员，我首先推荐ThinkPad。理由只有一个，专业。 作为一个企业或者一个开发人员来说，稳定是最重要的。根据我的观察和使用情况。即使Thinkpad已经被联想收购了，但是依然是最好的laptop没有之一。这个不解释。 另外一个选择，Mac。具体详细 再次不解释。 PS：不解释是因为有共鸣者不用解释，不了解者应该会自己Google一下。 彪悍的人生不需要解释。 ——老罗 所以，如果你在纠结于买一个什么样子的电脑，果断Thinkpad or macbook 。也许你说预算不够买thinkpad或者是macbook。那我就觉得，你可以入一个thinkpad二手。3000左右的，性能足够满足你所有学习上的需求。不过记住，thinkpad我只推荐T系列和X系列。其他的看都没有看过。 第二个选择——选择什么样的操作系统。Windows or Linux or Unix or MacOS。 记得我最牛x的一个老师（伯克利数学博士）跟我说过，如果你选择windows你就站在整个硅谷的对面。呵呵，我对此深信不疑。首先，我很尊重微软。他是一个伟大的公司，为我们提供了无数伟大的技术。可是，我不喜欢。我更喜欢Linux这样自由免费的系统。 具体理由详见： 呵呵，如果你能坚持看完，那你就应该知道我的推荐了：Linux or Unix or MacOS 没有Windows 第三，选择什么样的编程语言。 曾经，我苦苦纠缠于要学习什么语言，以至于什么都没有学的很精通。今天站在这个语言阵营，明天为那个语言阵营呐喊。结果三年以后的今天，我回过头去看。才发现，用什么语言都不重要，重要的是设计。不同的语言在不同的领域有不同的优点。只要能理解问题，设计出解决问题的方案。在找合适的语言来做就好了。前两天看见贺神转载的文章，上面有一句话很认同。手里如果有一把锤子，所有的问题都只有用钉钉子来解决。手里的工具是什么，就是你会什么语言。（这里大部分是转载了之前自己写的一篇blog，说这个有点早了，下面要开始说怎么学习了） ##基本存活技能 先泛泛谈一下，在今天这个知识爆炸的时代。我们不可能学会所有东西。因此，只要有活到老学到老的决心就好。学海无涯。。。。。。。（每次有这种想法，就想起高爷爷（Donald Ervin Knuth）用一辈子写一部书，而天朝很难有人做技术到１０年。浮躁的天朝） IT里面也分为很多方向，而不是仅仅学院里面开设的那四个。而且发现，其实后来找工作时候，用到的知识，都是自己学的。就是说，学院与业界还是存在一定的脱轨。这个无能为力。当初对自己的定位也很模糊，学的很杂，走了很多不必要的弯路，所以今天把我的一些糟粕去掉，说一些精华的东西。因为我信仰开源自由的精神，也才来分享自己的想法。 第一个技能提问的智慧 这个很重要，是学习的基本，是向人请教的规范。虽然只是一篇文章，但是我却说他是一项技能，值得你初期每次提问的时候，看一看。 第二个技能学会使用搜索引擎。 简单的说，就是你要学会Google，也许你觉得没什么学的。所以，现在你可以google一下google怎么用的问题。 这两个是基础，就想九九乘法表一样，应该时刻谨记。 第三个技能学会使用编辑器 选择一个文本编译器： Vim or Emacs 你现在选什么我也不知道，如果你不喜欢折腾就选Vim。如果，你觉得要变成一个手指的魔术师而且禁得住折腾的话就选择Emacs。但是必须深入的学习一个。 关于他们 Vim资料1Vim资料2 Emacs资料1Emacs资料2 能把所有连接都看完。坚持到现在，不错不错。我觉得你已经有超越我的迹象了。 在一开始，我说过，我们学IT其实不管喜欢不喜欢，最后的结果是我们能依靠它去生存下去。所以现在我们来选择我们要学习的方向，贪多不烂。深入一个方向比浅尝辄止好。（不断自省）还有一个问题就是IT这个行业每时每刻都有新的技术出来。有时候，你看见了，听说了。或许很眼红。觉得自己应该可以学学。已我的经验来看，这样做往往学不到东西。只说一个理由，就是新技术可能门槛很高。要学好它下面的基础要牢靠。也许一页字的东西。其实涉及了方方面面。你要看懂。要学习N多基础的东西。所以用2年学下面我说的东西吧。 第四个技能Git起初，我以为Git和Svn是一个货色。后来，才知道我的这种想法是多么的离谱。差点连最nb的版本管理错过。因为Git和github的出现。世界上多了多少有激情的项目。改变了现在的IT世界。 Git入门 Git进阶 github入门 ##头两年学习路线 第一，Vim or Emacs。（一辈子^_^) 第二，英语。 第三，数学: 什么是数学 具体数学 第四，C语言 C程序设计语言（3个月-4个月） Linux C编程一站式学习 （这本有电子版的，自己google。 2个月） 深入理解计算机系统（6个月） 数据结构与算法分析（3个月） 算法导论（一年） 这些书，我建议你一本一本买，然后一本看完了再进入下一本。 综上所述，我觉得起码要学两年。如果你天赋异禀。几个月就搞定了。那我觉得你应该，也知道怎么向后面学习了。跟着感觉走就好了。 初级技能 两年以后，我觉得你可以选择方向了，由于才粗学浅。很多方向我都只能给一个大概。 其实现在是一个Web的时代，我写的之前的两年学习其实都是脱离Web的。也就是说学习是脱离了这个时代。我检讨一下。因为我是这样过来的，也只能给出这样的学习路线。可是我在不断学习哦。所以我也不断的更新这个文章。 桌面应用方向不管是Windows还是Linux或者是Mac，传统意义上的编写程序其实就是编写桌面应用。什么是桌面应用，就是想QQ，WPS这样叫做应用程序的东西。这些软件存活在电脑里面。发展了很久，所以再今天看来他们有些老了。跟不上这个Web时代的步伐了。可是不代表他们不赚钱。今天有很多业务系统依旧守着桌面应用。所以，如果你没有一个相当强大的idea和实力。你很可能就去做业务系统了。小团体或个人很少做商业的桌面应用了。 在天朝内，从需求上来说windows的桌面需求是最多的。传说一本Windows核心编程看熟10k左右的工作应该没有问题。需要学C++，Windows底下的汇编。学Windows核心编程。学Windows驱动。然后，你可能要写界面。你要学MFC or WPF。 Linux桌面就比较纠结了，国内我就没有看到拿它赚钱的。Linux程序设计是必要的。然后是Gtk+ or Qt选一个图形库就ok。 Mac的桌面需求在天朝，要这个的公司。太少太少了。不过待遇都很不错10k+。 信息安全方向再今天这个Web时代，我们的在线安全越来越重要。所以做安全产品活的一般都好一些。Windows上就逆向、破解。*nux上就服务器的配置、防御什么的。 Web后台方向建站用的做多的PHP，框架也最多。不过据说存在各种各样的问题。 国内最大的java web应用是淘宝。你应该学S2SH， EJB，Maven。 豆瓣是国内最大的Python web应用。而且Python后台招聘的比PHP的一般要搞1-2k。Python的web框架也是一抓一大把。不过见过招聘最多的是django Ruby on Rails这个号称要拯救世界的ror。国外最近冒出比较有创意的web应用都用的ror。国内目前比较少。工资跟python差不多。但是学习门槛比较高。 Web前端方向工资高。福利好。工作压力小。说的就是这个阿。大概是html css javascript。然后是flash吧。现在flash做游戏的很多。2011年html5火的一塌糊涂。javascript本来被一直诟病的情况下，因为Chrome的V8引擎横空出世进而也再2011年用node.js重新要号称拯救世界。好的前端应该可以拿到同期最高的工资。目前强烈推荐做前端，门槛低，学习周期相对较短。容易高工资。 移动Web方向IOS iphone app很火。起工资也很高。如果你当初买了Macbook。强烈推荐你走这个路。能google到很多学习路线。大概就是objective-c 然后cocoa。斯坦福有个老头讲课很不错。 android 火的一踏糊涂，今年我同学去了很多oppo。大概是Java-&gt;Android。前两天看到因为效率的问题，Android支持原生C++的ndk在不断更新中。 其他meego 挂了。 用的Qt WebOS 挂了。 用的Javascript。 塞班 挂了。 用的Qt MTK 几近灭绝。 用的J2ME。 游戏方向游戏不太懂，应该是要学数学和物理。然后是一个引擎。微软有XNA。还有一些开源的引擎。 希望，这些能帮助到一些要入IT，却不知道门路的人们。 硬广时间我目前现在生活在新西兰。如果需要婴儿奶粉、保健品、程序员熬夜神器。均可通过么么爪新西兰代购购买。价格在海外直邮上有一定优势，但是淘宝上低价没法比。优势上只能用我那可能并不存在的人品担保都是正品。","link":"/2012/02/09/junior-it-people-c-study-guide/"},{"title":"iOS笔记(18)","text":"Core Data (一)序恩，用Core Data也有一段时间了。大大小小的坑也都坑过了。重来没有认真的记录一次。这次需要好好的理一理Core Data。就当一次绝好的机会记录下来。也为了自己加深认识。 为什么要用Core DataCoreData的学习是需要一定成本的。以至于我认识的人很少在用，大家要不就是用一个FMDB。或者做的App是一个已有的Web的延伸，数据直接用Web端的Api取回来就好了。 我们要用Core Data的理由有以下几点： Core Data是对底层存储的一次封装。封装了以后就变成ORM的框架。这样就变成操作对象。Core Data自己去进行数据的保存。 使用Core Data而不是FMDB，让整个程序架构更加的面向对象。 Core Data仅仅使用了Objective-C和Core Foundation，你不必去加入一些第三方的库。 Core Data是Apple的原生技术。每年的WWDC都能看到新特性的加入和讲授。 Core Data支持iCloud。而使用iCloud的App。Apple推荐的可能性增加。 有了iCloud为以后Apple的全平台数据共享打下基础 所以，没有理由拒绝使用Core Data做为你App的持久化。Core Data应该是一个跟Apple混的第一选择。 存储原理NSManagedObjectModel认识我个人是把NSManagedObjectModel看做为一个core data的schema。生成这个类的来源是xCode中的Data Model 点击之后会生成一个.xcdatamodeld的文件夹里面的数据具体是是用xml来存储的。但是你在xCode里面看这个.xcdatamodeld文件夹是认为一个文件。然后可以用xCode来进行图形化的编辑。 如这样 当然还有另外一种表格的方式来编辑Data Model 我们编辑这个的这个文件，理论上来说只是一个资源文件。相当于数据库的schema。我们的数据库长什么样子，就是你来设计的。然后在程序中通过NSURL找到这个资源文件的位置。就可以初始化成为NSManagedObjectModel。 代码加载Data Model当我们设计好我们的Data Model以后。可以用以下代码，把Data Model加载到NSManagedObjectModel里面去。 1234567- (void)initializeCoreDataStack{ NSURL *modelURL = [[NSBundle mainBundle] URLForResource:@\"PPRecipes\" withExtension:@\"momd\"]; ZAssert(modelURL, @\"Failed to find model URL\"); NSManagedObjectModel *mom = nil; mom = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL]; ZAssert(mom, @\"Failed to initialize model\");} 这样我们就从main bundle里面把data model加载到NSManagedObjectModel这个类里面去了。 NSPersistentStoreCoordinatorNSPersistentStoreCoordinator是整个Core Data的核心。因为承担着全部数据的持久化，加载数据，缓存数据的工作。可以看做Core Data的心脏。 值得我们开心的事情是，虽然NSPersistentStoreCoordinator很重要，但是我们在写程序的时候其实只用初始化和设置一些很简单的参数就可以使用了。在我们App的整个生命周期里面其实并不会很频繁的使用到它。 初始化NSPersistentStoreCoordinator初始化NSPersistentStoreCoordinator分为两个步骤 用已经初始化好的NSManagedObjectModel去初始化它 选择NSPersistentStore为存储的方式 NSPersistentStore理论上来说NSPersistentStoreCoordinator的数据不一定要存到硬盘上，它可以存到内存里，可以存到网络上。不过都肯定是对应着不同的应用场景。所以我们一般情况还是把它存储到磁盘上。 NSPersistentStore就是用来描述我们要把数据存到哪里的类。NSPersistentStore还可以指定存储数据的文件的文件类型。 目前知道的NSPersistentStore支持三种类型： SQLite 二进制 XML 我就只使用SQLite。理论上来说，NSPersistentStore不管选择什么样的存储文件。你后面进行Core Data的操作都是一样的。并不需要修改你的逻辑代码。这就是Core Data把底层封装了一次的好处。(书上说iOS上不建议使用XML) 有一点需要注意的是NSPersistentStoreCoordinator可以加入不止一个的NSPersistentStore。这个在某些特定场景还是很有用的，以后如果能写到在写把。 代码加载NSPersistentStoreCoordinator123456789101112131415161718192021dispatch_queue_t queue = NULL;queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_async(queue, ^{ NSFileManager *fileManager = [NSFileManager defaultManager]; NSArray *directoryArray = [fileManager URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask]; NSURL *storeURL = nil; storeURL = [directoryArray lastObject]; storeURL = [storeURL URLByAppendingPathComponent:@\"PPRecipes.sqlite\"]; NSError *error = nil; NSPersistentStore *store = nil; store = [psc addPersistentStoreWithType:NSSQLiteStoreType configuration :nil URL :storeURL options :nil error :&amp;error]; if (!store) { ALog(@\"Error adding persistent store to coordinator %@\\n%@\", [error localizedDescription], [error userInfo]); }}); 由于这个过程是一个比较耗费资源的过程。所以我们应该把它放到后台线程里面去做。 123NSFileManager *fileManager = [NSFileManager defaultManager]; NSArray *directoryArray = [fileManager URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask]; Apple中不管是OS X还是iOS能上架的App，都是沙箱机制。这个可以自己Goolge看相关的资料。这样的话每一个App都有自己的文件系统。这两句也比较常使用。就是可以获得自己沙箱中的Document文件夹路经。参数的信息直接查文档把。 接下来很重要的一句是 12345store = [psc addPersistentStoreWithType:NSSQLiteStoreType configuration :nil URL :storeURL options :nil error :&amp;error]; 此函数的第一个参数是指定NSPersistentStore的存储类型，我们之前说过的三种类型之一。NSSQLiteStoreType就代表这SQLite文件类型。 第二个参数比较高级。我还没有用到过。文档上写的是设置为nil的时候是把NSPersistentStoreCoordinator作为默认的配置，如果是其他参数可能是把NSPersistentStoreCoordinator设置为其他的用途。 第三个参数就是我们要存储文件的位置。刚刚我们不是获得的沙箱里面的Document文件夹路经了么。然后我们把文件名加入拼为了一个文件的完整路经传入。 第四个参数类型是一个字典，我们可以传入不同的参数来指定这个NSPersistentStore的类型。比如在本地比如在iCloud。比较高级先为nil。 最后一个参数，为error，传入一个error指针。如果NSPersistentStore初始化失败我们可以获得相应信息。 NSManagedObjectContextNSManagedObjectContext是我们很经常使用到的一个类。对于为什么要有这个类我个人理解是这样的，在我有限的数据库知识中记得，IO操作是很费时的，因此数据库一般情况是把一系列的操作缓存到了一个内存区域，等待合适的实际在去写入真实的磁盘中。这样大大的提高效率。如果你插入一条数据，然后修改数据，最后删除掉这条数据。如果是每次都执行Commit的话是操作三次IO，如果我们把这三条合并在一起commit的话。是任何事情都不必做。这样能有效的提高整个系统的效率。我认为NSManagedObjectContext的作用在于跟持久化直接做了这层缓存。我们使用Core Data。 还有一点需要注意的是NSManagedObjectContext并不是线程安全的。 关于NSManagedObjectContext的线程安全和高级解释，这里有两篇blog写的超好。 可以一看 Multi-Context CoreData Zarra on Locking 初级应用的话只用记住一个就ok了NSManagedObjectContext是有一个NSManagedObjectContextConcurrencyType的属性。如果我们是UI操作（主线程操作）我们应该把它设置为NSMainQueueConcurrencyType类型的。 代码加载NSManagedObjectContext12345NSManagedObjectContext *moc = nil;NSManagedObjectContextConcurrencyType ccType = NSMainQueueConcurrencyType;moc = [[NSManagedObjectContext alloc] initWithConcurrencyType:ccType];[moc setPersistentStoreCoordinator:psc];[self setManagedObjectContext:moc]; 总结 至此，三个Core Data的核心类就已经简单说完了一次。他们的关系在上面的图片中表示的很清楚的样子。 NSPersistentStoreCoordinator从NSManagedObjectModel得到模型然后选择NSPersistentStore作为持久化目的地。然后NSManagedObjectContext在作为NSPersistentStoreCoordinator的一个缓存区给我们操作。 当然我这篇blog和接下来准备写的Core Data的可能不会是有完整代码和具体实例的文章。可能只是我对Core Data使用上的一些感悟和梳理。","link":"/2013/03/29/learning-ios-notes-eighteen/"},{"title":"iOS笔记 (8)","text":"iOS笔记 基于MKNetworkKit的断点续传背景上次写过用ASIHTTPRequest做断点续传的例子。但是一个是写的比较搓。一个是ASIHTTPRequest库已经不在维护。最后是扩展性不是很好。所以花了很长时间改写用MKNetworkKit来写。 如果需要回顾一下ASIHTTPRequest的断点续传的在这里 MKNetworkKit下载地址是 https://github.com/MugunthKumar/MKNetworkKit 作者本人的臭屁介绍在这里 使用MKNetworkKit 首先把clone下来的MKNetworkKit文件夹拖进你的项目里面 到项目里面增加CFNetwork.Framework SystemConfiguration.framework 和 Security.framework. 把MKNetworkKit.h包含到你的pch文件里面。 如果是iOS，删除NSAlert+MKNetworkKitAdditions.h这个文件 如果是Mac，删除UIAlertView+MKNetworkKitAdditions.h这个文件 这样，再看看介绍里面的例子。应该就能看懂普通用法了。然后畅快的使用MKNetworkKit库了。 改写目标上次写的ASIHTTPRequest续传其实已经可以用了。但是为什么需要重新写呢。就是重用！！！ 一直都很少自己设计接口什么的。其实只是做了写体力的劳动，把一堆逻辑换成代码给堆了起来。觉得没有人会去重用自己的代码。很少去花心思想怎么样才能写好。 这次改写就只有一个目标，为了更好更多人能使用断点续传来下载。 功能下载持久化下载的持久化的微观含义是在push到新的view或者pop出当前view。下载应该在后台继续进行。宏观含义是按home把程序放入后台以后，下载继续进行。 保持进度条每次进入下载的view的时候progressview都应该保持一致 暂停恢复下载可以随时暂停下载和恢复下载 这次改写，这些功能都实现了，啊哈哈哈。 实现MKNetworkKit库修改最开始使用MKNetworkKit库做下载的时候，progressview的数值一直不对。经过boss的观察，应该是某个东西写错地方了。然后 修改了某两个函数才可以的。详细如下：找到MKNetworkOperation.m文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response { NSUInteger size = [self.response expectedContentLength] &lt; 0 ? 0 : [self.response expectedContentLength]; self.response = (NSHTTPURLResponse*) response; // dont' save data if the operation was created to download directly to a stream. if([self.downloadStreams count] == 0) self.mutableData = [NSMutableData dataWithCapacity:size]; else self.mutableData = nil; for(NSOutputStream *stream in self.downloadStreams) [stream open]; NSDictionary *httpHeaders = [self.response allHeaderFields]; // if you attach a stream to the operation, MKNetworkKit will not cache the response. // Streams are usually \"big data chunks\" that doesn't need caching anyways. if([self.request.HTTPMethod isEqualToString:@\"GET\"] &amp;&amp; [self.downloadStreams count] == 0) { // We have all this complicated cache handling since NSURLRequestReloadRevalidatingCacheData is not implemented // do cache processing only if the request is a \"GET\" method NSString *lastModified = [httpHeaders objectForKey:@\"Last-Modified\"]; NSString *eTag = [httpHeaders objectForKey:@\"ETag\"]; NSString *expiresOn = [httpHeaders objectForKey:@\"Expires\"]; NSString *contentType = [httpHeaders objectForKey:@\"Content-Type\"]; // if contentType is image, NSDate *expiresOnDate = nil; if([contentType rangeOfString:@\"image\"].location != NSNotFound) { // For images let's assume a expiry date of 7 days if there is no eTag or Last Modified. if(!eTag &amp;&amp; !lastModified) expiresOnDate = [[NSDate date] dateByAddingTimeInterval:kMKNetworkKitDefaultImageCacheDuration]; else expiresOnDate = [[NSDate date] dateByAddingTimeInterval:kMKNetworkKitDefaultImageHeadRequestDuration]; } NSString *cacheControl = [httpHeaders objectForKey:@\"Cache-Control\"]; // max-age, must-revalidate, no-cache NSArray *cacheControlEntities = [cacheControl componentsSeparatedByString:@\",\"]; for(NSString *substring in cacheControlEntities) { if([substring rangeOfString:@\"max-age\"].location != NSNotFound) { // do some processing to calculate expiresOn NSString *maxAge = nil; NSArray *array = [substring componentsSeparatedByString:@\"=\"]; if([array count] &gt; 1) maxAge = [array objectAtIndex:1]; expiresOnDate = [[NSDate date] dateByAddingTimeInterval:[maxAge intValue]]; } if([substring rangeOfString:@\"no-cache\"].location != NSNotFound) { // Don't cache this request expiresOnDate = [[NSDate date] dateByAddingTimeInterval:kMKNetworkKitDefaultCacheDuration]; } } // if there was a cacheControl entity, we would have a expiresOnDate that is not nil. // \"Cache-Control\" headers take precedence over \"Expires\" headers expiresOn = [expiresOnDate rfc1123String]; // now remember lastModified, eTag and expires for this request in cache if(expiresOn) [self.cacheHeaders setObject:expiresOn forKey:@\"Expires\"]; if(lastModified) [self.cacheHeaders setObject:lastModified forKey:@\"Last-Modified\"]; if(eTag) [self.cacheHeaders setObject:eTag forKey:@\"ETag\"]; } if ([self.mutableData length] == 0 || [self.downloadStreams count] &gt; 0) { // This is the first batch of data // Check for a range header and make changes as neccesary NSString *rangeString = [[self request] valueForHTTPHeaderField:@\"Range\"]; if ([rangeString hasPrefix:@\"bytes=\"] &amp;&amp; [rangeString hasSuffix:@\"-\"]) { NSString *bytesText = [rangeString substringWithRange:NSMakeRange(6, [rangeString length] - 7)]; self.startPosition = [bytesText integerValue]; self.downloadedDataSize = self.startPosition; DLog(@\"Resuming at %d bytes\", self.startPosition); } }}- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data { if([self.downloadStreams count] == 0) [self.mutableData appendData:data]; for(NSOutputStream *stream in self.downloadStreams) { if ([stream hasSpaceAvailable]) { const uint8_t *dataBuffer = [data bytes]; [stream write:&amp;dataBuffer[0] maxLength:[data length]]; } } self.downloadedDataSize += [data length]; for(MKNKProgressBlock downloadProgressBlock in self.downloadProgressChangedHandlers) { if([self.response expectedContentLength] &gt; 0) { double progress = (double)(self.downloadedDataSize) / (double)(self.startPosition + [self.response expectedContentLength]); downloadProgressBlock(progress); } }} 具体改了哪，忘记了。有心思对照源码看看。应该是属于MKNetworkKit的bug。也不知道新版改过来没有。但是你clone我的demo，这个版本是可以的。 断点下载库其实我一共就写了两个简单的类而已。 基础的是SIBreakpointsDownload。继承于MKNetworkOperation。判断了续传的位置。 一个SIDownloadManager写成单例，继承于MKNetworkEngine。用来管理多任务下载。 使用的时候就只用SIDownloadManager这个类来添加下载，暂停下载。然后想在下载的前后、出错时候、progressview改变时候对view作出改变。就实现它的delegate就好了。 demo地址 git@github.com:iiiyu/SIDownloader.git 其实已经很简单了，照着demo改改就能自己用了。 总结这次改写以后，代码结构变的很清晰。复杂性和耦合性都有所降低。可用性提高。而且，反正我是没有google到可以直接拿来用的断点下载库。这次娃哈哈就有了。然后blog也2月没有更新，鄙视自己。以后应该会慢慢更新恢复正常。最后，希望对大家有所帮助。","link":"/2012/07/07/learning-ios-notes-eight/"},{"title":"iOS笔记(16)","text":"配置自己的CocoaPods库序默认安装的cocoapods确实很好用，可是毕竟自己会写一些库和修改一些第三方库来用。所幸cocoapods确实是一个神器。他可以定义自己的库来用。如何安装Cocoapods，请参考这篇 从头来设置应用场景我的boss写了一个基于MagicalRecord的CoreData的iCloud设置的类。也许我们以后要用到的机会毕竟多。单独拿出来成为一个库。现在用cocoapods来做成一个静态库。 我们这个库基于外部的MagicalRecord和SVProgressHUD.这两个库是用git submodule的方法来管理的 第一步把代码托管到一个支持git的服务器我选择了bitbucket.因为没钱买github。 第二步删除git submodulegit submodule虽然也可以实现第三方库的管理，但是相对于cocoapods来说太麻烦了。删除就不是想cocoapods这样在Podfile里面删除配置就好的。 先删掉目录 123$git rm --cached Vendor/MagicalRecord$git rm --cached Vendor/SVProgressHUD$rm -rf Vendor 删掉.gitmodules 1$rm .gitmodules 修改.git/config 把MagicalRecord和SVProgressHUD的条目删除 最后commit一下 12$ git add .$ git commit -m \"Remove a submodule\" 第三步为原来的项目添加cocoapods支持先把项目里面引用submodule的地方删除 添加Podfile到项目目录里面 内容为 123platform :ios, '6.0'pod 'MagicalRecord', :git =&gt; 'https://github.com/iiiyu/MagicalRecord.git', :tag =&gt; 'sumiGridDiary2.1'pod 'SVProgressHUD' 解释一下：第一行后面是限制模拟器版本为6.0以上。第二行因为MagicalRecord我们改了几行代码，因此用我们自己的版本。指定git地址。和tag标签。除了tag还可以指定branch和commit。格式一样第三行用官方的最新版本 安装Pod 1$pod install 我的安装结束以后提示 123[!] The target `SIStore [Debug - Release]' overrides the `HEADER_SEARCH_PATHS' build setting defined in `Pods/Pods.xcconfig'. - Use the `$(inherited)' flag, or - Remove the build settings from the target. 按照提示修改项目的Build Settings就ok了。 进入项目中把之前是包入“”的第三方头文件地方改为&lt;&gt; 添加.gitignore .gitignore内容为 123456789*.xcodeproj/*!*.xcodeproj/project.pbxprojbuild.DS_Store._*.svn*.xcworkspacePodsPodfile.lock 打完收工。 这样就之前的库就可以跑在cocoapods的配置下了 第四步创建自己的Podspec文件初始化一个Podspec文件 1$pod spec create SIStore SIStore.podspec内容如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130## Be sure to run `pod spec lint SIStore.podspec' to ensure this is a# valid spec.## Remove all comments before submitting the spec. Optional attributes are commented.## For details see: https://github.com/CocoaPods/CocoaPods/wiki/The-podspec-format#Pod::Spec.new do |s| s.name = \"SIStore\" s.version = \"0.0.1\" s.summary = \"A short description of SIStore.\" # s.description = &lt;&lt;-DESC # An optional longer description of SIStore # # * Markdown format. # * Don't worry about the indent, we strip it! # DESC s.homepage = \"http://EXAMPLE/SIStore\" # Specify the license type. CocoaPods detects automatically the license file if it is named # `LICEN{C,S}E*.*', however if the name is different, specify it. s.license = 'MIT (example)' # s.license = { :type =&gt; 'MIT (example)', :file =&gt; 'FILE_LICENSE' } # # Only if no dedicated file is available include the full text of the license. # # s.license = { # :type =&gt; 'MIT (example)', # :text =&gt; &lt;&lt;-LICENSE # Copyright (C) &lt;year&gt; &lt;copyright holders&gt; # All rights reserved. # Redistribution and use in source and binary forms, with or without # ... # LICENSE # } # Specify the authors of the library, with email addresses. You can often find # the email addresses of the authors by using the SCM log. E.g. $ git log # s.author = { \"Xiao ChenYu\" =&gt; \"apple.iiiyu@gmail.com\" } # s.authors = { \"Xiao ChenYu\" =&gt; \"apple.iiiyu@gmail.com\", \"other author\" =&gt; \"and email address\" } # # If absolutely no email addresses are available, then you can use this form instead. # # s.author = 'Xiao ChenYu', 'other author' # Specify the location from where the source should be retrieved. # s.source = { :git =&gt; \"http://EXAMPLE/SIStore.git\", :tag =&gt; \"0.0.1\" } # s.source = { :svn =&gt; 'http://EXAMPLE/SIStore/tags/1.0.0' } # s.source = { :hg =&gt; 'http://EXAMPLE/SIStore', :revision =&gt; '1.0.0' } # If this Pod runs only on iOS or OS X, then specify the platform and # the deployment target. # # s.platform = :ios, '5.0' # s.platform = :ios # ――― MULTI-PLATFORM VALUES ――――――――――――――――――――――――――――――――――――――――――――――――― # # If this Pod runs on both platforms, then specify the deployment # targets. # # s.ios.deployment_target = '5.0' # s.osx.deployment_target = '10.7' # A list of file patterns which select the source files that should be # added to the Pods project. If the pattern is a directory then the # path will automatically have '*.{h,m,mm,c,cpp}' appended. # # Alternatively, you can use the FileList class for even more control # over the selected files. # (See http://rake.rubyforge.org/classes/Rake/FileList.html.) # s.source_files = 'Classes', 'Classes/**/*.{h,m}' # A list of file patterns which select the header files that should be # made available to the application. If the pattern is a directory then the # path will automatically have '*.h' appended. # # Also allows the use of the FileList class like `source_files' does. # # If you do not explicitly set the list of public header files, # all headers of source_files will be made public. # # s.public_header_files = 'Classes/**/*.h' # A list of resources included with the Pod. These are copied into the # target bundle with a build phase script. # # Also allows the use of the FileList class like `source_files' does. # # s.resource = \"icon.png\" # s.resources = \"Resources/*.png\" # A list of paths to preserve after installing the Pod. # CocoaPods cleans by default any file that is not used. # Please don't include documentation, example, and test files. # Also allows the use of the FileList class like `source_files' does. # # s.preserve_paths = \"FilesToSave\", \"MoreFilesToSave\" # Specify a list of frameworks that the application needs to link # against for this Pod to work. # # s.framework = 'SomeFramework' # s.frameworks = 'SomeFramework', 'AnotherFramework' # Specify a list of libraries that the application needs to link # against for this Pod to work. # # s.library = 'iconv' # s.libraries = 'iconv', 'xml2' # If this Pod uses ARC, specify it like so. # # s.requires_arc = true # If you need to specify any other build settings, add them to the # xcconfig hash. # # s.xcconfig = { 'HEADER_SEARCH_PATHS' =&gt; '$(SDKROOT)/usr/include/libxml2' } # Finally, specify any Pods that this Pod depends on. # # s.dependency 'JSONKit', '~&gt; 1.4'end 注释里面描写的很详细，建议全部看完 去掉注释版本 12345678910Pod::Spec.new do |s| s.name = \"SIStore\" s.version = \"0.0.1\" s.summary = \"A short description of SIStore.\" s.homepage = \"http://EXAMPLE/SIStore\" s.license = 'MIT (example)' s.author = { \"Xiao ChenYu\" =&gt; \"apple.iiiyu@gmail.com\" } s.source = { :git =&gt; \"http://EXAMPLE/SIStore.git\", :tag =&gt; \"0.0.1\" } s.source_files = 'Classes', 'Classes/**/*.{h,m}'end 第一行和最后一行保留下来然后不管就好了 s.name 声明库的名称 s.version 库的版本 s.summary 一个简短的说明文档 s.homepage 库的首页 s.license 库的协议 s.author 作者 s.source 原代码的地址 s.source_files 原代码的目录 我们要认真填写的有s.name、s.version、s.source、s.source_files。我们有依赖其他库所以还要写s.dependency。还有一个bundle还要写s.resourcs。 最终的结果内容如下: 1234567891011121314151617Pod::Spec.new do |s| s.name = \"SIStore\" s.version = \"0.0.2\" s.summary = \"Sumi Interactive make a new CoreData and iCloud a Third-party library on MagicalRecord.\" s.homepage = \"https://iiiyu.com\" s.license = 'MIT' s.author = { \"Xiao ChenYu\" =&gt; \"apple.iiiyu@gmail.com\" } s.source = { :git =&gt; \"https://iiiyu@bitbucket.org/iiiyu/sistore.git\", :tag =&gt; \"0.0.2\" } s.source_files = 'SIStore/*.{h,m}' s.preserve_paths = 'SIStoreDemo' s.resources = 'SIStore/SIStore.bundle' s.framework = 'CoreData' s.dependency 'MagicalRecord', :git =&gt; 'https://github.com/iiiyu/MagicalRecord.git', :tag =&gt; 'sumiGridDiary2.1' s.dependency 'SVProgressHUD' s.requires_arc = true s.platform = :iosend 坑cocoapods有缓存。 我一直测试刚刚搞好的自己的库一直不对。 改了2小时。 才反应过来我一直打的标签是同一个，然后cocoapods在本地缓存了一个。只对比了标签以至于我改的东西都没有用。哭。。。。 参考文章如何编写一个CocoaPods的spec文件 CocoaPods一个Objective-C第三方库的管理利器","link":"/2013/03/01/learning-ios-notes-sixteen/"},{"title":"iOS笔记 (10)","text":"关于回调函数——Delegate的那些事序iOS笔记也终于迈入两位数之列。在此里程碑下。明显要拿出点诚意来好好写一写。所以，我决定写一下早已改写的delegate。 什么是回调函数我们先不管delegate，我们先来说说回调函数(callback).wiki的解释在这里。 回调函数，或简称回调，是指通过函数参数传递到其它代码的，某一块可执行代码的引用。 好我来说所自己理解过后的解释: 如果不用回调函数可不可以写程序。(明显可以) 那为什么要用回调函数这种东西。(现代开发软件过程中其实一直在强调一些相同的东西:抽象、复用) 复用是为了提高生产效率。提高生产效率，才能创造更大的价值。 怎么复用——抽象。只用抽象出来的东西才有复用的价值。 从代码量各种角度来看，回调似乎是复用代码了。但是回调不仅仅如此。更大的作用是解耦。 解耦简单说来就是让程序结构更好，更容易读，更容易修改，更容易修改的其中一个基本方法。 回调怎么解耦。A做一把椅子，但是步骤很多。其中一个步骤上漆应该是B来做。因为B是专门做上漆(B有油漆，有刷子，有技术。B持有上漆这个步骤最佳实践)。正确的方法肯定不是A自己去买油漆刷子把这个步骤做了。而是叫B来把这个步骤做好。然后A继续组装椅子。直到椅子做好。 扯了这么多。其实就是wiki上解释的哪些而已。如果还不明白，再看一次wiki。再多写写代码吧。 那什么是delegate找了一个比较专业的解释这里 对于delegate不是一个具体的技术，它是一个设计模式。他是面向对象编程思想里面的一种基础方法。好如果你看了我的第一个笔记的话，还记得我描述MVC的比喻么这里为了描述方便我还是搬运一次来这里把。 controller一直叫唤狗腿子view，叫view干啥view就干啥。某天，view出事情了，这时候view想 在出事情的时候通知一下controller主子。controller主子也不是没有人性，在controller设置 一个target。这时候要是出现了什么事情view这个狗腿子要发一个action给主子controller就好了。有 时候view狗腿子要和主子controller步调保持一致（synchronize 同步）这个时候要怎么做呢。在 controller里面设置view狗腿的delegate（代表）这个delegate就通过一个protocol来设置 （协议。哈哈 objective-c的语法出现了。） view狗腿是不会拥有显示的数据，如果狗腿需要数据的时候数据会通过协议来取得。controllers几 乎都是data source（但不是model），因为controller是把model里面的信息格式化以后给view 的。 那model能直接跟controller交流么？答案是不，model必须独立于UI之外。（好一个不为五 斗米折腰）。 那model有一些忠义之言（信息更新）要进谏给controller怎么办。 model就自己想 办法弄了一个广播电台（类似broadcast mechanism广播机制。PS：学过设计模式的童鞋还hold住 么）controllers 或者其他model就可以“收听”到感兴趣的内容。view可能也有“收听”这个功能， 但是很可能收到的不是model这个台。 其实这个故事是根据老头第一课的视频加keynote自己联想出来的。来回顾一下这张经典的keynote 这个是iOS中MVC的最好诠释 上面把iOS里面的回调方式常用的都画出来了。只差一个block样式的现代接口。(理论上来说，我应该会把每一个回调都写一篇blog，尽请期待) 所以，在我理解中MVC三者都是很独立自主的。他们之间的联系就靠这些回调来进行沟通。 target action delegate &amp; data source Notification &amp; KVO 根据我这几个月以来的编写感悟而言，这张keynote真的太经典了。delegate从view回来一般是三个函数(will should did)都是在view的不同阶段进行回调都是很有用的时候。比如view将要显示的时候(带有will的delegate函数)。已经完成了的显示的(带有did的函数)。所以delegate是什么时候用。 就是view狗腿在可能主子Controller需要知道的时候设置了一种通知方式。可以想象成，从大殿之外飞奔进来一个狗腿说：”报~我准备去抢花姑娘了。圣上有何吩咐”。controller说:”带点长腿 A罩杯的回来” 。然后狗腿飞奔出去办事。过了一会狗腿又飞奔进来:”报~~抢花姑娘回来了，圣上有何吩咐”。controller说:”带到xx宫，洗干净等我”。狗腿的报告主子是可以不理会的。(这句主要是为了解释protocol里面的optional关键字)这个例子可能比较恶趣味+不怎么清楚。但是技术的东西我们还是弄娱乐点吧。 实现delegateok，说了这么多的东西。我主要想解释为什么会有delegate这种东西。它的应用场景。接下来，我会借助这些文章: 文章1 文章2 文章3 来上面的例子来解释怎么用delegate。 对于delegate不是一个具体的技术，它是一个设计模式。这是我上篇开头说的。那objective-c当中怎么实现delegate呢。用protocol。 一般会这样写 狗腿.h 1234567891011121314@protocol MyClassDelegate &lt;NSObject&gt;@optional- (void) will抢花姑娘:(MyClass*)myClass;- (void) did抢花姑娘:(MyClass *)myClass;@end@interface MyClass{ id&lt;MyClassDelegate&gt; delegate; FlowerGirl *flowerGirl;}@property (nonatomic, weak) delegate;@property (nonatomic, strong) flowerGirl;@end 这里为什么要用weak。这里有详细的分析。自备云梯 还有一个注意的地方是optional这个key，如果没有这个key，那成为这个狗腿的主子都要把这些方法实现了(比如xxx侵犯了我朝领土，请圣上发令。这种肯定要处理，不处理的话就是臭sb。不配做老大)。而有这个key的话，在这个key(上面的方法一定实现)，key下面的方法是可选的不必一定实现(比如抢来花姑娘，可以不去做任何动作)。 这样，我们就完成了狗腿的delegate声明。 狗腿.m 12345678910111213141516171819@implementation MyClass-(void) 抢花姑娘{ if ([self.delegate respondsToSelector:@selector(will抢花姑娘:)]) { [self.delegate will抢花姑娘:self]; } // do something 出去抢花姑娘 // 并且抢到了 if ([self.delegate respondsToSelector:@selector(did抢花姑娘:)]) { [self.delegate did抢花姑娘:self]; } }@end 这里要注意的是[self.delegate respondsToSelector:xxx]方法。这个方法用于检验主子有没有实现xxx方法，如果实现了，在做xxx。没有没有实现的话就不做xxx了。如代码所示. 主子.m 1234567891011121314151617181920212223242526@interface 主子()&lt;MyClassDelegate&gt;{ MyClass *myClass;}@end@implementation 主子- (void)init{ ... myClass = [MyClass new]; myClass.delegate = self; [myClass 抢花姑娘]; ...}- (void) will抢花姑娘:(MyClass*)myClass{ myClass.flowerGirl = flowerGirl(腿长，A);}- (void) did抢花姑娘:(MyClass *)myClass{ [self 送去xxx宫:myClass.flowerGirl];}@end 具体就是这样。代码是伪码一般，只是写着写着就想着对应我的恶趣味例子。鄙视一下自己。 总结我觉得我扯了这么多，包括贴出来的文章地址看完以后，你应该对delegate有一个感性的认识了把。如果你对blog内容有满意or不满意和错误的地方。欢迎指出。我一定改进。谢谢。","link":"/2012/08/13/learning-ios-notes-ten/"},{"title":"iOS笔记 (12)","text":"Block简单使用序这篇blog主要想介绍这么用block做回调。因为跟之前的是想关联的。 这图中的Controller和View我之前已经讲过Delegate和Traget-Action了。Data source和Delegate差不多。有机会再TableView里面详细说说。当然，按照计划我这次要写block的回调。 什么是block老规矩wiki http://zh.wikipedia.org/wiki/块_(C语言扩展) 来自apple的第一手资料。 所以block这种语法要在OS X 10.6 和 iOS4.0以后才支持。不过考虑到iOS的版本问题并不像Android一样屌丝。so可以默认block这种语法是都可以支持的。 block出现据说是为了GCD的实现apple大力推进的。GCD(Grand Central Dispatch)简单说来就是进行多线程并行操作的一种机制。使得iOS和Mac的多线程程序编写很容易。如果你搞过Linux的多线程再来看GCD的话，会觉得生活在幸福中。 当然block的使用不仅仅只有GCD一个地方。block是一个标准Objective-C对象。因为block是对象，所以block可以作为参数传递、作为方法或函数的返回值、赋值给变量。使用block我们编写自己的接口时候就可以写的很现代。或者在我们需要暴露一些方法给其他人调用的时候，就不仅可用delegate，还可以用block这种现代的方法。 在没有Block之前，如果我们想在之后的某个时间回调一个方法，你一般会用代理或者NSNotificationCenter。 这样也不错， 除了一点，它会让你的代码到处都是——你在一个地方开启了一个任务， 然后在另外一个地方处理它的结果。如果使用Block的话，则不用遇到这样的问题。因为它能将和一个任务相关的所有代码都放在一个地方， 你马上就会看到。这样代码就可以开起来很清晰和具有现代感。 关于block，你可以在绿皮学习到更加详细的例子。 创建一个block我以为在Objective-C里面,因为是C的超集。为了扩张出各式各样的面向对象的功能。就加入了各种特殊的符号。比如常见的@用来告知这是一个对象等等。所以，我觉得block也用了一个特殊的符号来开头的话，符合一贯作风。我们的block就使用「^」来表示一个block。so如果你在代码里面看见有「^」符号的话。肯定你看见了一个block。 声明block引用123void (^blockReturningVoidWithVoidArgument)(void);int (^blockReturningIntWithIntAndCharArguments)(int, char);void (^arrayOfTenBlocksReturningVoidWithIntArgument[10])(int); 小技巧 如果我自己定义了一个block并且想让他使用到多处的话。可以这样写 1234typedef float (^MyBlockType)(float, float); MyBlockType myFirstBlock = // ... ;MyBlockType mySecondBlock = // ... ; 实现block刚刚知道了怎么定义block，定义好了以后。我们就可以在合适的地方来实现这个block 12345int (^oneFrom)(int); oneFrom = ^(int anInt) { return anInt - 1;}; block的应用场景调用block如果是声明了一个block变量的话。可以直接调用block，如下面的两个例子。 123456789101112131415int (^oneFrom)(int) = ^(int anInt) { return anInt - 1;};printf(\"1 from 10 is %d\", oneFrom(10));// Prints \"1 from 10 is 9\"float (^distanceTraveled)(float, float, float) = ^(float startingSpeed, float acceleration, float time) { float distance = (startingSpeed * time) + (0.5 * acceleration * time * time); return distance;};float howFar = distanceTraveled(0.0, 9.8, 1.0);// howFar = 4.9 在C函数中使用block作为参数在平时使用中其实系统里面有很多函数已经是用block作为参数的了。我们不必去定义block。下面用qsort_b来作为例子(qsort_b跟qsort_r是类似的快速排序函数，只是最后一个参数用了block) 12345678910char *myCharacters[3] = { \"TomJohn\", \"George\", \"Charles Condomine\" };qsort_b(myCharacters, 3, sizeof(char *), ^(const void *l, const void *r) { char *left = *(char **)l; char *right = *(char **)r; return strncmp(left, right, 1); });// Block implementation ends at \"}\"// myCharacters is now { \"Charles Condomine\", \"George\", \"TomJohn\" } 可以明显的看出，使用block参数的优势在于调用函数的地方可以自己处理一些事情。这样同样的函数，在细节上有不通处理的时候，使用block将变的更方便直接。 当然，其实在iOS编程中，我目前使用最多的C函数带有block肯定是GCD里面的函数。使用dispatch_apply来举例子 函数原型 1void dispatch_apply(size_t iterations, dispatch_queue_t queue, void (^block)(size_t)); 例子 1234567#include &lt;dispatch/dispatch.h&gt;size_t count = 10;dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_apply(count, queue, ^(size_t i) { printf(\"%u\\n\", i); }); 上面这个例子可以应用到需要放到多线程里面的循环 在Cocoa方法中使用block作为参数当然，我们可以在cocoa方法中使用block。 下面是我学习中的例子。第一个函数是声明一个带block的方法。后面的是Action方法。展示怎么调用一个自己声明的带block参数的方法。 123456789101112- (NSString *)Calculator:(NSString * (^)(double one, double two))block{ return block([self.oneNumber.text doubleValue], [self.twoNumber.text doubleValue]);}- (IBAction)add:(id)sender{ self.lable.text = [self Calculator:^NSString * (double one, double two) { return [NSString stringWithFormat:@\"%lf\", one + two]; }];} 这个例子是我能想到最简单的例子了。需要注意的是(NSString * (^)(double one, double two))声明的时候需要多一对()括号。不然会报错。而调用时候则不用。而且调用和声明时候^的位置区别。 复杂一些的例子 12345678910111213141516171819202122NSArray *array = [NSArray arrayWithObjects:@\"A\", @\"B\", @\"C\", @\"A\", @\"B\", @\"Z\", @\"G\", @\"are\", @\"Q\", nil];NSSet *filterSet = [NSSet setWithObjects:@\"A\", @\"Z\", @\"Q\", nil];BOOL (^test)(id obj, NSUInteger idx, BOOL * stop);test = ^ (id obj, NSUInteger idx, BOOL * stop) { if(idx &lt; 5) { if([filterSet containsObject:obj]) { return YES; } } return NO;};NSIndexSet *indexes = [array indexesOfObjectsPassingTest:test];NSLog(@\"indexes: %@\", indexes);/* * Output: * indexes: &lt;NSIndexSet: 0x10236f0&gt;[number of indexes: 2 (in 2 ranges), indexes: (0 3)] */ NSSet里面自带的函数例子, 遍历Set 123456789101112__block BOOL found = NO;NSSet *aSet = [NSSet setWithObjects:@\"Alpha\", @\"Beta\", @\"Gamma\", @\"X\", nil];NSString *string = @\"gamma\";[aSet enumerateObjectsUsingBlock:^(id obj, BOOL * stop) { if([obj localizedCaseInsensitiveCompare:string] == NSOrderedSame) { *stop = YES; found = YES; } }];// At this point, found == YES 补漏貌似有一个重要的关键字忘记提了__blcok.这个让你的变量能在block修改。具体内容在第一段里面的链接里面都有。这里只是提一下。 优点 vs 缺点优点：个人觉得就是上面提到过的使用block参数的优势在于调用函数的地方可以自己处理一些事情。这样同样的函数，在细节上有不通处理的时候，使用block将变的更方便直接。而且让GCD得以足够简单的方法进行多线程的编写。GCD让多线程编程从来没有想过如此之简单易用。 缺点：学习有一定曲线。闭包概念难懂。","link":"/2012/09/29/learning-ios-notes-twelve/"},{"title":"iOS学习笔记(28) ReactiveCocoa 迎接下一个更加美好的世界（2013-10-13 update 2.0）","text":"扯淡习惯了，每次再写技术的东西的时候总要唠叨几句。本来唠叨的东西我应该会写成另外的blog。不过每次给自己下了一个底线要少少的写这些唠叨的话语。原因一是觉得我爱唠叨的话语可能会导致blog被墙。原因之二我不希望我变成一个IT评论家。 对了,我发现我还是挺爱挖坑的。目前有两坑没有填完。一个是Core Data系列。一个是iCloud系列。两个系列我都只写了一个Hello World级别并没有再深入的继续写。恩，要抓紧了。其实ReactiveCocoa这个我觉得也可以作为一个系列来写。不过想了想我这种Hello World的水平。也写不出这么多来。就暂时写一篇好了。 什么是ReactiveCocoa如果你有看Github的Trending Objective-C榜单，那你肯定是见过ReactiveCocoa了。如果你在weibo上关注唐巧、onevcat等国内一线知名开发者。那也应该听说过ReactiveCocoa了。 ReactiveCocoa更加被Mattt Thompson大神称为开启一个新Objective-C纪元。 当然也有人声称ReactiveCocoa是Cocoa的未来。ReactiveCocoa: The Future of Cocoa Programming 我自己粗犷把现在的Objective-C分为两个阶段。 第一个阶段就是我学Cocoa开发之前的阶段：就是把Objective-C做出来的那群NeXT的大神，确定面向对象思想，确定消息机制，确定各种模式最后变成了Apple的主力开发语言。到后面OS X的各种库。iOS的各种库。 第二个阶段就是我学Cocoa开发之后的阶段：开始clang发力，配合Objective-C的快速进化：ARC，block，现代Objective-C语法。使其Objective-C不断获得现代语言类如Ruby, Python的优秀特性。 现在，说的最多的就是ReactiveCocoa将会把Objective-C带到下一个里程碑中。 ReactiveCocoa是一个基于Functional Reactive Programming编程思想的Objective-C实现开源的第三方库。最初的作者是Github的大神（Josh Abernathy &amp; Justin Spahr-Summers）。应该是再开发Github For Mac时候的附属产物。当然，我们必需得明白有时候附属产物要比真主牛逼的多了去了。比如万艾可，再比如青霉素，再再比如老干妈。 等等 什么是Functional Reactive Programming Functional Reactive Programmingwiki解释 Reactive Programmingwiki 响应式编程 Functional programmingwiki Functional programming 恩 简单来说 Functional Reactive Programming = Functional programming + Reactive Programming (PS:特么太偷懒了还是解释一下) 简单以 a = b + c 为例 通常情况下在执行a = b + c的值的时候b和c当时是什么值。a就是当时的b+c。然后后来不管b和c怎么变化，a都不会改变。 但是在Execl中设置a格子=b格子+c格子的值。a的值就会随着b和c值的改变而改变。然后我还可以搞的高级一点f = a + d。 f格子的值也会随着b、c、d的值而改变。这就是使用Functional Reactive Programming以后会发生的情况。 Reactive的特性使得可以随时响应变化。Functional的特性使得他们可以串起来。 来自微软实验室的编程思想在ReactiveCocoa的readme我们看到ReactiveCocoa是基于.NET的Reactive Extensions(Rx)来的。啧啧身为一个脑残果粉不解释的我。也必须承认微软其实曾经一度集聚这世界上一大批大牛。这批大牛在闲着玩的时候做出来的玩具也指不定哪天就拯救世界了。 Rx所以我也找了点Rx的资料来看看 中文里面比较全面的是这个Reactive Extensions入门 里面有一堆链接和一个视频。c#实在看不懂，就只看了15分钟左右。不过那看上去蛮帅的哥们一开始说他在编程中遇到的问题。恰巧是我最近遇到的问题：就是我有两个在非主线程的异步操作。而我有可能需要等两个异步操作都完成的时候进行下一步操作。这种情况我一直没有找到比较优美的解决方法。直到遇见ReactiveCocoa，仿佛看见了希望。 Model-View-ViewModel洋文wiki 中文wiki FRP倾向于技术理论上的方法论。MVVM则是程序模式的方法论。就好比FRP给了一把解牛的刀。MVVM就是如何解牛的方法论。 相对来说MVVM通常跟MVC拿来比较。在我看来，没有绝对的好和坏。找个适合的就好了。再说我对两个东西的了解不够深入。 Basic MVVM with ReactiveCocoa 这篇blog应该就写的蛮清楚了。 这是github上iOS的 MVVM例子MVVM-IOS-Example 大家可以感受一下。 ReactiveCocoa的基本使用方法(终于写到正主了,泪流满面) 这里借用Limboy的blog中的一段话作为开场解释。(因为我想了好久都没有想出超过他的比喻方法) ReactiveCocoa是github去年开源的一个项目，是在iOS平台上对FRP的实现。FRP的核心是信号，信号在ReactiveCocoa(以下简称RAC)中是通过RACSignal来表示的，信号是数据流，可以被绑定和传递。 可以把信号想象成水龙头，只不过里面不是水，而是玻璃球(value)，直径跟水管的内径一样，这样就能保证玻璃球是依次排列，不会出现并排的情况(数据都是线性处理的，不会出现并发情况)。水龙头的开关默认是关的，除非有了接收方(subscriber)，才会打开。这样只要有新的玻璃球进来，就会自动传送给接收方。可以在水龙头上加一个过滤嘴(filter)，不符合的不让通过，也可以加一个改动装置，把球改变成符合自己的需求(map)。也可以把多个水龙头合并成一个新的水龙头(combineLatest:reduce:)，这样只要其中的一个水龙头有玻璃球出来，这个新合并的水龙头就会得到这个球。 替代KVO官方例子：官方的例子貌似用了比较老的函数。我改完以后看见什么是函数响应式编程(Functional Reactive Programming:FRP)他也是这么改的。说明一下。 经过后来的使用才发现特么官方例子是2.0的。 现在重新改一下。随便说一句，用cocoapods安装的2.1.编译不过。具体原因还没有看。建议使用2.0 12345@property (strong) NSString *username;[RACObserve(self, username) subscribeNext:^(NSString *newName) { NSLog(@\"%@\", newName); }]; 在这句代码以后，只要你的username有变化。都可以打印出来。实现了KVO的功能却减少了无数的代码。体现了绑定和响应。 高级一个点的官方例子 1234567[[RACObserve(self, username) filter:^(NSString *newName) { return [newName hasPrefix:@\"j\"]; }] subscribeNext:^(NSString *newName) { NSLog(@\"%@\", newName); }]; 第一个例子是简单的所有变化都会响应到。但是可能我只想响应部分情况。这时候就用filter来过滤。filter的block返回YES的情况就是需要触发的情况。其他就补返回。所以这代码以后。 username以j开头的才能打印出来。 流的实现以下是Getting Started with ReactiveCocoa的例子和图片 如何以最少的代码实现一个时钟应用 1234567RAC(self, timeLabel.text) = [[[RACSignal interval:1 onScheduler:[RACScheduler currentScheduler]] startWith:[NSDate date]] map:^id (NSDate *value) { NSLog(@\"value:%@\", value); NSDateComponents *dateComponents = [[NSCalendar currentCalendar] components:NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit fromDate:value]; return [NSString stringWithFormat:@\"%02ld:%02ld:%02ld\", (long)dateComponents.hour, (long)dateComponents.minute, (long)dateComponents.second];}]; 实现的逻辑顺序是这样的。设置一个间隔为一秒。从现在开始调用的函数。并把当前实际传入。 这个函数返回一个NSString。 然后把这个NSString和界面上的textField绑定在了一起。从而实现了我认为我见过最简单时钟程序。表现了流和绑定响应。 组合几乎每个ReactiveCocoa的Demo里面都会出现的例子。 (继续盗图图) 这个是用的leezhong的图。 应该是从这个演讲PPT里面来的，点过去还有视频哦 就是说在必需验证每个所填写的数值符合标准。Button才能点击。 12345RAC(self, submitButton.enabled) = [RACSignal combineLatest:@[self.usernameField.rac_textSignal, self.passwordField.rac_textSignal] reduce:^id (NSString *userName, NSString *password) { return @(userName.length &gt;= 6 &amp;&amp; password.length &gt;= 6);}]; 简单的解释就是把usernameField和passwordField的信号绑定在了一起做reduce处理以后。返回一个BOOL值去跟self.submitButton.enabled进行绑定。 囧。再次发现和leezhong借用的代码和图都是一样的。 异步和网络(丢个链接 等心情好了 在补。。。) when-to-use-reactivecocoa 总结其实我对ReactiveCocoa了解还是在hello world阶段。 很多东西都理解的很粗糙。上面这一大陀blog。很多地方写的肯定不好。欢迎指出。其实很多时候觉得确实中文原创的技术文章十分少。很大一部分都是翻译的。国外的技术文章也确实写的牛写的好。但是总觉得自己应该写点自己思考的东西。 对于ReactiveCocoa来说，我认为它确实是一个好东西。正如leezhong所说 RAC统一了对KVO、UI Event、Network request、Async work的处理，因为它们本质上都是值的变化(Values over time)。 其实App上90%的操作不就只有这些么。所以我会一直对ReactiveCocoa投入时间去学习和使用。顺便说一句。阿里Mac Lab出品的Xiami for Mac。是我见过国内最好的Mac App之一。他们也用了ReactiveCocoa。然后你可以想象对他们做出那些响应交互ReactiveCocoa为他们提供了强有力的输出。 参考资料FRPwiki Functional reactive programming 趣味编程：Functional Reactive Programming haskell Functional Reactive Programming wiki 响应式编程 wiki Functional programming 函数式反应型编程(FRP) —— 实时互动应用开发的新思路 什么是函数响应式编程(Functional Reactive Programming:FRP) Reactive Extensions入门 ReactiveCocoaReactiveCocoa与Functional Reactive Programming Better Code for a Better World by Josh Abernathy nshipster Reactive​Cocoa ReactiveCocoa: The Future of Cocoa Programming Getting Started with ReactiveCocoa Functional Reactive Programming on iOS with ReactiveCocoa Basic Operators Basic MVVM with ReactiveCocoaMVC - One Pattern to Rule them all How I Wrote Vinylogue for iOS With ReactiveCocoa 来自好友RoCry的推荐 ReactiveCocoa at MobiDevDay 2013 ReactiveCocoa at MobiDevDay 2013视频 Input and Output","link":"/2013/09/11/learning-ios-notes-twenty-eight/"},{"title":"iOS笔记(21) CoreData (三) NSFetchedResultsController","text":"CoreData (三)NSFetchedResultsController什么是NSFetchedResultsControllerNSFetchedResultsController是一个让人爱恨交加的一个类。如果使用得当，NSFetchedResultsController能帮组减少很多代码。如果使用不当，整个App就随时崩溃。 NSFetchedResultsController我觉得最初的设计应该是为了配合UITableView来使用的。因为UITableView在iOS的应用App中出场次数实在是太高了.而且UITableView是重要的数据展示View,所以需要频繁的向Model去请求数据,但是根据MVC来说,V不应该直接跟M联系的.这样就在Core Data下面出现了一个C–NSFetchedResultsController来把V和M协调起来. NSFetchedResultsController就是这个C. NSFetchedResultsController是有两个重要的功能。 第一:NSFetchedResultsController是作用在Core Data上的,通过NSFetchRequest来查询Core Data里面的数据.可以返回按照组分好的数据.这样便于UITableView来显示. 第二:但Modle改变的时候NSFetchedResultsController能及时的发出通知.准确的说,应该是当NSManagedObjectContext发生改变的时候,NSFetchedResultsController能知道这些变化,然后发出通知出来.以便UITableview能及时的更新. 实现一个NSFetchedResultsController作为Data source的UITableView创建一个最小带Core Data的工程 选择Master-Detail Application 整理一下显示层级和结构使其看起来顺眼一些 确立目标打开看以后 发现建立的工程是已经使用了NSFetchedResultsController我们的目标是改写这个项目支持UITableView分组显示 首先修改Data Model增加一个字段用来分组. 我们增加一个同样的Date用来记录此时的分钟数量. 初始化一个NSFetchedResultsController这里假设你看过我的Core Data笔记1,2.默认你已经做好了Core Data stack的全部工作.然后再开始NSFetchedResultsController的初始化. 12345678910111213141516171819202122232425262728293031323334353637- (NSFetchedResultsController *)fetchedResultsController{ if (_fetchedResultsController != nil) { return _fetchedResultsController; } NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init]; // Edit the entity name as appropriate. NSEntityDescription *entity = [NSEntityDescription entityForName:@\"Event\" inManagedObjectContext:self.managedObjectContext]; [fetchRequest setEntity:entity]; // Set the batch size to a suitable number. [fetchRequest setFetchBatchSize:20]; // Edit the sort key as appropriate. NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@\"timeStamp\" ascending:NO]; NSArray *sortDescriptors = @[sortDescriptor]; [fetchRequest setSortDescriptors:sortDescriptors]; // Edit the section name key path and cache name if appropriate. // nil for section name key path means \"no sections\". NSFetchedResultsController *aFetchedResultsController = [[NSFetchedResultsController alloc] initWithFetchRequest:fetchRequest managedObjectContext:self.managedObjectContext sectionNameKeyPath:@\"sectionMinute\" cacheName:@\"Master\"]; aFetchedResultsController.delegate = self; self.fetchedResultsController = aFetchedResultsController; NSError *error = nil; if (![self.fetchedResultsController performFetch:&amp;error]) { // Replace this implementation with code to handle the error appropriately. // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. NSLog(@\"Unresolved error %@, %@\", error, [error userInfo]); abort(); } return _fetchedResultsController;} 这里是工程里面的NSFetchedResultsController的set方法.可以看出,第一我们创建一个NSFetchRequest查询.然后在用这个NSFetchRequest去创建一个NSFetchedResultsController. 1NSFetchedResultsController *aFetchedResultsController = [[NSFetchedResultsController alloc] initWithFetchRequest:fetchRequest managedObjectContext:self.managedObjectContext sectionNameKeyPath:@\"sectionMinute\" cacheName:@\"Master\"]; 第一个参数就是NSFetchRequest. 第二个参数是要指定在哪个context里面进行查询 第三个参数是根据什么key来分组.sectionNameKeyPath本来是nil是不分组,我改为我们需要分组的key值”sectionMinute”. 第四个参数 官方解释是这里点到The Cache的地方. 我的理解是cache只保留很少的一部分数据在磁盘上面,如果使用了Cache,在重建UITableView的时候, 就优先查询cache里面的数据.然后要在-performFetch:执行的时候才会去刷新新的数据.这样有助于UITableView的流畅性. 然后我加入Sections的方法 1234567- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section{ NSArray *sections = [[self fetchedResultsController] sections]; id &lt;NSFetchedResultsSectionInfo&gt; sectionInfo = nil; sectionInfo = [sections objectAtIndex:section]; return [sectionInfo name];} 接着我添加 1https://github.com/erica/NSDate-Extensions.git 这个NSDate库进来.自己按照他的写法,写一个能获得当前时间秒数为0的方法.用来分组. 123456- (NSDate *) dateAtStartOfMinutes{ NSDateComponents *components = [CURRENT_CALENDAR components:DATE_COMPONENTS fromDate:self]; [components setSecond:0]; return [CURRENT_CALENDAR dateFromComponents:components];} 然后改写insert方法 1234567891011121314151617181920- (void)insertNewObject:(id)sender{ NSManagedObjectContext *context = [self.fetchedResultsController managedObjectContext]; NSEntityDescription *entity = [[self.fetchedResultsController fetchRequest] entity]; NSManagedObject *newManagedObject = [NSEntityDescription insertNewObjectForEntityForName:[entity name] inManagedObjectContext:context]; // If appropriate, configure the new managed object. // Normally you should use accessor methods, but using KVC here avoids the need to add a custom class to the template. [newManagedObject setValue:[NSDate date] forKey:@\"timeStamp\"]; [newManagedObject setValue:[[NSDate date] dateAtStartOfMinutes] forKey:@\"sectionMinute\"]; // Save the context. NSError *error = nil; if (![context save:&amp;error]) { // Replace this implementation with code to handle the error appropriately. // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. NSLog(@\"Unresolved error %@, %@\", error, [error userInfo]); abort(); }} 其实就是加入了 1[newManagedObject setValue:[[NSDate date] dateAtStartOfMinutes] forKey:@\"sectionMinute\"]; 这句. 这样,简单的使用NSFetchedResultsController来显示分组的UITableView就搞定了.当然因为建立的工程模板原因.很大一部分都是xCode搞定的. 被遗忘的地方Sections数量,决定了有多少组 1234- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView{ return [[self.fetchedResultsController sections] count];} 如果在初始化NSFetchedResultsController的时候sectionNameKeyPath为nil.这里应该会返回1.(就算没有数据也会返回1) Row数量,决定每一组分别有多少行数据. 12345- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{ id &lt;NSFetchedResultsSectionInfo&gt; sectionInfo = [self.fetchedResultsController sections][section]; return [sectionInfo numberOfObjects];} 我前面说过NSFetchedResultsController就是为了配合UITableView而设计的.所以自然有根据indexPath来取对应的NSManagedObject的方法. 123456789101112- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{ UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"Cell\" forIndexPath:indexPath]; [self configureCell:cell atIndexPath:indexPath]; return cell;}- (void)configureCell:(UITableViewCell *)cell atIndexPath:(NSIndexPath *)indexPath{ NSManagedObject *object = [self.fetchedResultsController objectAtIndexPath:indexPath]; cell.textLabel.text = [[object valueForKey:@\"timeStamp\"] description];} show 总结写Blog实在是太累了. NSFetchedResultsController努力一天也才一点点.回去继续写. 下次要写NSFetchedResultsController通知方法.","link":"/2013/04/17/learning-ios-notes-twenty-one/"},{"title":"iOS笔记(23) iOS进行单元测试OCUnit+xctool","text":"iOS进行单元测试OCUnit+xctool单元测试什么是单元测试wiki解释 简单说来就是为你的方法多专门写一个测试函数。以保证你的方法在不停的修改开发中。保持正确。如果出错，第一时间让你知道，这样从最小单位开始监控来保证软件的质量。 我为什么要单元测试其实要开始写单元测试的原因是，由于我的原因格志的存储逻辑一直有问题。 一个是代码写的比较搓，一个是修改存储的逻辑的话。影响面比较大。可能修复了一个bug而引入了未知的多个bug。为了Sumi早日达到国际化大厂的标准。决定上单元测试于格志。其实最根本的目的还是想要项目变的更加可靠。 单元测试的一般方法关于测试的书，一搜就一大把。都有高深的理论和方法来指导怎么写单元测试的方法。我觉得嘛不用搞了这么复杂。 无非就3种时候会去想写测试： 代码完成以后 开始写代码之前 修复了一个bug以后 第一种是完成了代码，恩我要测试一下我写的这些方法可靠不可靠。那这时候可以写测试。 第二种一个著名的方法论TDD。主要思想就是在写代码之前，就全部设计好借口。函数名字什么的。然后在写能通过测试的函数。 第三种就是发现了bug，我修复了这个bug。为了确保修复是成功的。那就写个测试吧。 我觉得啊，着三种都没有什么好或差。能写测试的少年都是好少年。何必这么在意什么时候去写呢。 一个完整的测试类组成像下图 在一开始可能测试方法里面需要一些上下文环境。这些可以在Setup里面去完成。然后才可是执行自己写的测试方法。 然后测试结束以后，可能产生了一些垃圾数据文件什么的。这时候你可以在TearDown方法里面把他们处理掉。 以上大部分都是我自己的粗浅理解，如果你需要更多关于单元测试请阅读更加系统专业的书籍。 OCUnitOCUnit是xCode里面自己带的单元测试框架。不必安装第三方的其他库就可以使用。最简单的就是创建项目的时候你把单元测试的那个勾点上。xCode就会自动的为你加入一个单元测试的target。快捷键Command + U。就可以运行测试。最喜欢这样方便又好用的东西了。当然运行OCUnit的测试输出的内容实在惨不忍睹。 创建一个OCUnit的Unit Test新项目使用OCUnit 选上Unit Test 会自动的建立一个Target 自动的为你添加好需要的类库 为你添加一个Unit Test的类 看一眼Scheme 只有一个。 看看Scheme里面是怎么写的。 用Command + U运行一下测试看看结果。这是没有通过的。因为自动生成的模板就是不通过的。具体一会儿分析代码。 看看终端的输出。渣一般的难看。根本无法高识别度的分清。 已经存在的项目使用OCUnit 这是一个一开始没有选择过Unit Test的项目 点击增加Target 选择Unit testing Bundle 为我们的测试bundle取一个名字 我们可以看到Scehme多出来了一个。这时候如果选择的是App的Scehme。Command + U。是没有运行测试的。要选择我们新建立的Test Scehme。再按Command + U.就运行了测试了。 如何为App的Scehme添加Test。使得不用切换Scehme，就可以运行Unit Test。 然后选择你建立的Unit Test bundle。 打完收工。 OCUnit使用的宏STAssertEqualObjects(a1, a2, description, …) STAssertEquals(a1, a2, description, …) STAssertEqualsWithAccuracy(a1, a2, accuracy,description, …) STFail(description, …) STAssertNil(a1, description, …) STAssertNotNil(a1, description, …) STAssertTrue(expr, description, …) STAssertTrueNoThrow(expr, description, …) STAssertFalse(expr, description, …) STAssertFalseNoThrow(expr, description, …) STAssertThrows(expr, description, …) STAssertThrowsSpecific(expr, specificException, description, …) STAssertThrowsSpecificNamed(expr, specificException, aName, description, …) STAssertNoThrow(expr, description, …) STAssertNoThrowSpecific(expr, specificException, description, …) STAssertNoThrowSpecificNamed(expr, specificException, aName, description, …) 比较经常使用的宏STAssertTrue(expr, description, …)STAssertFalse(expr, description, …)STAssertNil(a1, description, …)STAssertNotNil(a1, description, …)STAssertEqualObjects(a1, a2, description, …)STAssertEquals(a1, a2, description, …)STFail(description, …)STAssertThrows(expr, description, …) 写了几个测试方法的例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061- (void)testOne { NSString *string1 = @\"test\"; NSString *string2 = @\"test\"; STAssertThrows([string1 isEqualToString:string2], @\"FAILURE\");}- (void)testTwo{ int i = 0; int j = 1; STAssertTrue(i &lt; j, @\" i: %d, j: %d\", i,j);}- (void)testThree{ NSString *oneStr = @\"hello\"; NSString *twoStr = @\"world\"; STAssertFalse([oneStr isEqualToString:twoStr], @\"oneStr:%@, twoStr:%@\", oneStr, twoStr);}- (void)testFour{ NSArray *array = nil; STAssertNil(array, @\"array:%@\", array);}- (void)testFive{ NSDictionary *dict = @{@\"hello\": @\"word\"}; STAssertNotNil(dict, @\"dict:%@\", dict);}- (void)testSix{ NSNumber *oneNum = @100; NSNumber *twoNum = @200; STAssertEqualObjects(oneNum, twoNum, @\"oneNum:%@ twoNum:%@\",oneNum, twoNum);}- (void)testSeven{ NSArray *oneArray = @[@11, @22, @33]; NSArray *twoArray = [oneArray copy]; STAssertEqualObjects(oneArray, twoArray, @\"oneArray:%@, twoArray:%@\", oneArray, twoArray);}- (void)testEight{ NSUInteger uint_1 = 4; NSUInteger uint_2 = 4; STAssertEquals(uint_1, uint_2, @\"FAILURE\");} - (void)testExample{ STFail(@\"Unit tests are not implemented yet in HelloAfterAddOCUnitUnitTest\");} 一会儿用xctool跑个华丽丽的出来看。 xctoolxctool是什么xctool是Facebook开源的一个命令行工具，用来替代苹果的xcodebuild工具。 github 官方演示 你可以用它来Build你的App。跑Tests。而且它跑Test输出是华丽丽的彩色。比xCode自带的不知好看多少倍。OCUnit本来被吐槽无数，遇上了xctool以后就逆袭了啊。 世界上最最牛的SNS出品，肯定不会坑爹啊。 安装xctool最方便 最推荐的是用Homebrew。如果你的Mac里面没有安装Homebrew我觉得是你的损失。 12brew updatebrew install xctool 使用xctool来跑OCUnit测试关于如何使用xctool，你去看官方文档肯定要比我结束好的多。 我就是过来跑测试的例子给你看而已。 测试一1xctool -project HelloOCUnit.xcodeproj -scheme HelloOCUnit test 测试二123xctool -project HelloAfterAddOCUnit.xcodeproj -scheme HelloAfterAddOCUnit testxctool -project HelloAfterAddOCUnit.xcodeproj -scheme HelloAfterAddOCUnitUnitTest test 项目一下载 项目二下载 总结以上就是OCUnit的使用建议。建议OCunit+xctool。来进行你的单元测试构建。更多信息请阅读相关资料。我这里只是写了入门而已。接下来的测试之路就靠你了。","link":"/2013/05/23/learning-ios-notes-twenty-three/"},{"title":"iOS笔记(20)","text":"UITableView简单解析序UITableView是在iOS开发中，展示大量内容的首选。我个人认为的原有有一下几点： UITableView的展现形式是为移动设备专门设计过的。有较好的人机交互体验。 从技术角度来说UITableView具有重用和延迟加载等特性。如果使用恰当。可以获得一个App流畅的用户体验。 这样，使得UITableView在iOS App中随处可见。 原生应用 一些有名的App.图片信息较老 包括游戏 这些都说明UITableView在一个App中其实是一个很常用的控件。我应该好好的学习它。 关于数据的思考没有UITableView的时候我是这样想的首先思考为什么会有UITableView这样的控件。我们做一个App的时候，就会有大量的数据需要显示。比如weibo的每一个状态。比如一个新闻App的很多条新闻。这些数据都会有一个特点就是他们的组织形式一样，只是内容变化。有时候我们可能会根据一些条件进行分组。使得看来了是分组的。例如：联系人里面会按照首字母来进行分组一样。我们还可能会点击数据以便查看更详细的内容。通过上面的简单描述，如果来自己实现一个类似UITableView的结构。需要得到最核心的： 需要得到一共多少条数据 数据的具体内容是什么 如果我们数据需要更加仔细的描述展示： 全部的数据一共有多少组 每一组有多少个数据 每一条数据的具体内容是什么 UITableView是怎么做的在UITableView中。最重要的就是data source中的两个方法。 123- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath; 什么是data source。字面意思就是很明白，数据的来源。一般情况下我们会设置拥有UITableView的这个UIViewController为他的data source。因为根据MVC来说。UITableView是View，UIViewController是Controller。View需要的数据，应该是Controller去跟Model协调然后获得，以后由Controller去给View来进行显示。View永远的不去直接跟Model联系。这样当UITableView初始化的时候。他就会去问他的data source。我需要显示多少行数据啊。每一行的数据都是什么内容啊。这时候UIViewController应该已经从Model拿到了数据。然后通过- (NSInteger)tableView:(UITableView )tableView numberOfRowsInSection:(NSInteger)section;告诉UITableview，恩你的这一组要显示n条数据。又用- (UITableViewCell )tableView:(UITableView )tableView cellForRowAtIndexPath:(NSIndexPath )indexPath函数告诉UITableView说，第几组第几条数据的具体内容是什么。 UITableView还有一个比较犀利的地方就是如果你的数据有10000条。它肯定不是把10000条都加载进来。而是只加载需要显示的条目数据。这样设计，使得UITableView的流畅程度大大提高。值得注意的是，如果Cell里面的数据是从网络 or Core Data等其他地方读取的。我们应该把读取动作写成异步的。不阻塞主线程。取到数据以后在回答主线程去刷新UI。 UITableView从创建到显示的调用顺序如下图 (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView这个函数是最先调用，但是它默认返回1.所以并不是必须的。如果你的UITableView分了好几组，这个就是用来返回组的数量的。 这样完成了设置UITableView的data source设置。在完成 123- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath; 这两个函数。我们就可以得到一个能显示的UITableView了。 现在是是仅仅解释了UITableView的数据是怎么来的，然后怎么对应到UITableView上面。 UITableViewCellUITableViewCell具体的每一条数据展示的具体View。首先在UITableView里面有这样一个特点，每一个Cell的大概样子都长的差不多，只是里面具体的内容稍有变化。这样在UI里面我们应该是重用相同的部分，改变不同的部分。这样才能提高效率。因为在UiTableView这个视图里面，用户习惯性快速的滚动，视图和数据内容都会快速的变化，如果效率问题处理不好，很容易有卡顿的现象。造成用户体验的降低。 如果使用默认的UITableViewCell风格，有以下四种 UITableViewCellStyleDefault UITableViewCellStyleSubtile UITableViewCellStyleValue1 UITableViewCellStyleValue2 当然如果是需要自定义Cell也是很简单。 用xib拖一个，完全可以GUI的方式来创建，很是方便。 (Google一个栗子吧，写不动了) 插一句，Cell的重用是需要下面这样的实现方法 123456789- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{ static NSString *Cell = @\"MyCell\"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:Cell]; if (!cell) { cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:Cell]; } return cell;} 重要的是UITableView的dequeueReusableCellWithIdentifier方法。 dequeueReusableCellWithIdentifier去一个队列里面需找有没有相同ID的的Cell。如果有就提出来重用。可以重用的部分。如果没有就跳进if里面去创建。所以我们在if里面创建的时候，不会改变的内容都可以在里面创建，这样就只用创建一次。需要改变的内容我们就放到if后面去写。 这样我们就能完成高效的UITableView。当然，理论上来说，你可以不用这样的机制，而去直接每次创建一个Cell。不过这是非常浪费资源的一个做法，直接不提倡。 UITableView Delegate当然，在写UITableView肯定想控制的更多。才能完成设计师们辛辛苦苦画出来的稿。这样我们可以去看看Data source里面剩下的函数和Delegate。 当然就说一点 123456//选中Cell响应事件- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath{ //选中后的反显颜色即刻消失 [tableView deselectRowAtIndexPath:indexPath animated:YES];} 这个是选中Cell时候会的出发点。如果要点击以后做什么事情 就在这里做了。 找了篇目测还ok的中文blog可以先看看了解 数据刷新如果我们的modle更新了。相应的要体现到UITableView上面。简单的我们可以reload整个TableView。这样做很方便，而且数据上没有问题。唯一的问题就是，reload整个TableView的效率太低了。而且，往往我们只是少数的Cell内容变化。所以没有必要去reload整个TableView。而是那条数据变化去刷新对应的Cell就好了。这样做效率提高很多。 具体涉及到的几个函数 12345678910- (void)beginUpdates;- (void)endUpdates; - (void)insertSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;- (void)deleteSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;- (void)reloadSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation; - (void)insertRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation: (UITableViewRowAnimation)animation;- (void)deleteRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation: (UITableViewRowAnimation)animation;- (void)reloadRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation; 这里有实例代码可以参考 官方教程 里面写了如何优化UITableView： 又找了一篇blog写的很不错的样子，优化UITableView性能 后记总结就是UITableView是一个高度设计的控件。它具有重用，分组，异步加载数据等方面需要我们注意。 其实这里插进来写UITableView是为了写NSFetchedResultsController。因为NSFetchedResultsController就是为UITableview量身打造的Core Data的类。 所以，先说明以下UITableView，然后再写NSFetchedResultsController。","link":"/2013/04/15/learning-ios-notes-twenty/"},{"title":"谈谈2012年苹果的所有发布会","text":"序2012是我的本命年，按照我的风格理所当然的我肯定没有穿大红内裤。但不妨碍2012年成为我转折的一年。现在已经看完了发布会，回过头来写写这篇blog吧。本来今天这场发布会有点纠结看不看，因为看iPhone5那场觉得不激情。但是今年苹果的发布会我都看了直播，这个不看感觉不完整。结果今天加班回来就12点多了。也就不纠结，顺势就看了，而且有视频直播，确实看着感觉很好。iMac太cool了。 Apple现在整个Apple的生态系统就像在滚雪球。已经是一个巨大无比的雪球，只要山势还高，这个雪球就会一直滚下去。而且越滚越大。就算中途遇到一个石头， 大石头。顶多磕掉雪球的一部分。雪球还是能向下滚，继续变大。 而世界上并不可能存在一直利好的事情。天下大势，分分合合。在正常不过。谁也敌不过时间。所以苹果也一定会衰落下去。以我可以遇见的将来5年，这个雪球的势头可能下降，可能放慢变大的速度。但是离蒸发殆尽的时刻还很遥远。写到这里，我不禁能想象一些IT评论家。在几十年后，等苹果衰落的时候，跳出来说。我xx年前就预测苹果会衰落。我还能预测你100年后一定是黄土。 不管怎样，我目前是跟着苹果混。谁说苹果不好我就跟谁急。这不是砸我饭碗么。我就是脑残粉。 iPadiPad 3应该是今年第一场发布会吧，我那会还在东莞。 一个人在宿舍里面，看图文直播。还是很激动，激动的原因就是retina屏。而且那会iPad3的屏确实是我听说过最高分辨率的屏幕（原谅我的土鳖）。retina屏最好的地方就是能舒服的看书了。之前就有一个kindle 3。 e-lnk确实已经无限的接近实体书。对于我这种看见书就会有购买冲动的人来说，确实开心很多。因为在有kindle 3之前。在电子设备上，我是无法进行长时间的阅读。kindle 3的push服务也很舒心。的确是实体书的接近完美替代品。 kindle 3对于我来说有几个不足。一是必须在能观看实体书的地方看（光线）。二是，6寸的屏幕对于已经存在的pdf来说。确实小太多了。三、刷新还是会闪一下。其实这些都不是kindle 3的致命之处。kindle 3的致命之处是因为它太接近实体书了。我意识到这个问题是今年过年时候ibooks author发布的时候吧。我看了ibooks author的视频。深深的被震撼了。觉得ibooks author做出来的教科书就是改变世界的东西。 书书所以有价值，是它上面记载着有价值的内容。纸张本身只是一种介质和载体。内容才是价值。所以，我们的介质从石头-&gt;乌龟壳-&gt;竹简-&gt;羊皮卷-&gt;纸张-&gt;电子设备。（这里我只是粗略的描述一下）我们用来记载的介质越来越方便。记录方式越来越多样方便。（雕刻-&gt;笔-&gt;数字记录 单调颜色-&gt;彩色 文字-&gt;图片-&gt;声音-&gt;影像）。从这里我觉得我能看到未来记录内容的方式肯定是各种视频、图片、文字、声音交织在一起的内容。书本，已经在时代科技之下处于淘汰的边缘。苹果的ibooks author出现，第一次使得我们大规模淘汰书本迈出了第一步。所以是苹果来迈，原因很多，其中一个就是当时包括现在iPad在统治着平板电脑。而且还在增长中。 回到刚刚说的iPad3上，kindle 3的致命之处就在它太像书了，而书并不是下一代记录内容的介质。（这里有人要说kindle fire以及其他类似平板等一会儿一起说）。 iPad 3发布之前，iPad 1和2 并不是retina屏。阅读上有颗粒感。这种感觉就是我无法在电子设备上长时间阅读的主要原因。iPad 3的发布和年初ibooks author的发布。让我觉得苹果在做他们已经在音像行业做的事情一样。开始颠覆整个世界的原有规则。这种远见和胸襟，才是是我成为苹果脑残粉的原因。 所以，我很快就入了iPad 3，但是的价格比这次发布会前一天苹果团的贵了近1k。可是我现在依然觉得很值得。在上面阅读的体验确实很好。并且购入了一本专门用ibooks author写的中文书籍。（\u0005ibuick那本）。书本确实在被淘汰了。尽管我还是会怀念书本们的不同厚度，不同油墨味。不同的纸张触觉。可是我也能想象出，当初竹简过渡到书本的时候。那代人也会怀念竹简的味道，竹简的重量、竹简的磨损。但是并没有阻碍书本成为新的内容介质。 iPad 4就说一句: 获得成就：拥有最短命那代iPad iPad mini在今天以前，我以为7寸的iPad出现是为了阅读。因为，确实iPad不适合单手把持，在真实的应用场景上确实存在单手操作的需求。但是我并不喜欢，因为我真心看不出来，在iPhone和iPad之间有一个足够改变世界的空间。而单手把持的时候，是不方便进行复杂繁琐的操作，所以最适合的应用场景我认为是阅读。很可惜，iPad mini并没有上retina屏。这样就根本不适合阅读。而且从发布会来的种种细节来看。iPad mini就是为了抢钱抢地盘来了。对比nexus 7的keynote。跟iPad 1和2一样的分辨率，329刀的定价等。iPad mini的出现就是抢钱抢地盘，细分了Apple的平板。2000rmb出头（当然最终国行不是这个价钱）的价钱，获得拥有目前为止最强大的软件生态系统。确实很超值。 虽然我不喜欢，但是可以让apple巩固地位的东西。也就巩固了我的饭碗嘛。so 我也不讨厌是不。 Macmac系列一如既往的更新。跟上着科技的进步，硬件的更新。主流的配置。iMac 27是最亮的地方。一切都在向好的方向发展good。没啥好说的。 iPhone虽然现在剧透很严重，发布会一般就是确认会。但是我认为苹果的保密已经做的很好了。可能能做的更好。但是在全世界都关注的情况下，在发布后就必须开始有供货的这种情况下。在发布之前，还是没有一个泄漏的版本是一个完整能运行起来的机器。这个我觉得已经保密到很了不起的状态了。好扯完这些。来扯iPhone5。 iPhone5那天的直播看着确实没激情，因为发布的都是已经知道的。只是等确认而已。发布完以后，weibo上也是一片唱衰（不得不说那天看的图文直播里面的图片真的很坑爹）不禁想到iPad发布的时候，也是说一个大号iPod touch有啥。然后市场表现和iPad上的Apps一起证明了一切。iPhone 5这么多人不喜欢的情况下，为啥过了这么久了，还出现供不应求的情况，为啥还不降价。我等的好揪心啊。不是说烂么，我求一个来看看怎么样烂法。起码现在看来，iPhone 5依然叫座啊。 而且根据一些weibo来看，拿到实机的人大部分都觉得是一部很好的手机。 V2ex帖子在这里我起先只是回答了一下楼主的问我的问题，在51楼。然后发表了一下观看直播的感受。 然后@onfire @coldear 就一起讨论了一下观后感。由于铜币不多。和本来很晚了，本来也计划写blog。我就一起写这边把。 先回复关于价格的问题 @onfire @coldear。首先是硬件问题：小时候，我也会去看啥cpu是奔III，内存是256MB的电脑很nb啥的。很关注一些参数。然后看一些杂志上各种跑分。各种测评。结果呢，我确实顺利成为了周围亲戚朋友的会修电脑的人。配多了电脑，修多了电脑。你就会发现，大家其实都不关心你帮他们配的是Intel还是AMD。安装的是原装windows还是ghost。他们只关心我的电脑快不快。预算在5k能不能配一个比1w的还要nb的电脑。接着发现，预算5k。能买神舟的定配，却只能买一个thinkpad的低配。why，why。我是一个爱思考的少年。我陷入了深深的思考。 其实大家都只是产生了一个需求需要某种物品or某种需求。结果不懂，然后害怕。其实真正需要的是把钱花出去以后，我使用这个物品和这种需求如果很爽，就很值。如果不爽，就不值。跟那些狗屁参数一点关系都没有。这种想法我一直都有。描述的不是很好。直到我看了tinyfool的一篇blog。上面说了iPod是这样写容量的。可以存储2000首歌。而不是写着4g的存储控件。然后我就顿悟了其实一个东西最重要的是我用的爽不爽。更参数真的没关系。 我觉得我开始扯偏了，因为5点了。我还在想把这个问题写清楚。 关于价格，我想说的是，如果预算就200刀左右。然后你的需求只是一个kindle fire和nexus 7已经能解决很好的问题。那果断kindle fire or nexus 7。你一样很爽。因为解决了你的需求并且花了较少的钱。但是如果是一个普通的大家呢，需求就是想要一个平板，做一些我能在平板上做的事情。预算也没有那么紧张。那你们觉得会选择iPad还是Android呢。而且，200刀买了Android的平板。我就算想在多出200刀。然后可以让我买我需要的App。我能用到那些App么。200刀买了个跑分机器回去能用爽么。性能的标准是啥，现在在我看来就是我想要玩某个游戏，很流畅就好。不需要那些啥参数。看了头晕。参数再高，没那个游戏。一样用的不爽。同样适用于apple，如果某一天，就像apple II后面那代苹果的电脑一样。大家都用的不爽了。自然apple就衰落了。至于iPad mini一出， kindle fire和nexus 7就要大卖这种情况要是能出现。那我觉得苹果早关门了，iPad mini也出不出来了。 回到看书的这个地方来。kindle fire能比过ibooks author + iPad 3 or 4么。因为那个才是我看来真正的下一代书籍。然后又要提价格。我的天。你kindle fire 200刀+ (499 - 200)刀的价钱能体验到跟ibooks author + iPad 3一样爽的书籍感受么。我觉得是这样比才正确。 至于说nexus 7 200刀 + （329 - 200）刀的价钱能让nexus 7那巨多的应用市场有一个拥有apple app store这么多高质量的应用，和方便快捷的购买app体验么。 200刀买回去的只是一坨硬件。没灵魂。没有软件，跑分再高，参数再高没用的。 比数据性能 比参数。个人认为是反人类的。看看apple的产品更新就知道了。apple一直在硬件上保持主流。够用就好。 其实还想举KK书里面的例子。比如科技的趋同发展。如果以KK的观点来看今天的所有专利站都忒恶心。因为当科技发展到一定程度的时候，该出现的科技会在不同地方，不同人群中产生。所以，以后Android也肯定会出现ibooks author这样的软件能制作出下一代书籍。也可能某公司 某人迈出了淘汰书籍的第二步从而超越苹果。因为这是科技发展的结果。等等觉得写是写不完了。 最后我媳妇儿说过我这个人有个毛病，就是我认为不正确的，就一定想把别人也给统一到一个想法上去。然后扯着扯着就不知道扯哪里去了。因为我得出的结论是各种东西混杂一起的结论。一时半会怎么可能解释的清楚。偏偏还喜欢拉着人家扯。其实，我觉得我挺客观的。只要你能客观的各种举例深入思考的东西来说明。我觉得我挺容易接受一些正确的经过各种思考的思维。而且我也希望跟我扯的人能真心的听进我的思想。如果我的思想有不完善的地方，欢迎指出。","link":"/2012/10/24/talk-about-the-2012-apple-conference/"},{"title":"谈谈软件的一些事","text":"最近，思想里面很是混乱。估计就是心事重重一类型的吧。脑子里面不断闪现一些零碎的东西。所以我还是把一些认为比较有价值的记录一下，以免丢失。 科技的进步使得我们的世界变得美好了那么一点。电脑软件的不断丰富也使得我们的生活变的美好了一些。做为一个365天几乎360天+都要在电脑上度过的苦逼码畜来说，一个软件深度的长时间的去用，不仅仅是它能解决一些问题，而且还关系到解决问题的效果，效率。以及看起来装不装13,用起来爽不爽。 除去一些毫无创意，没有价值，千篇一律的软件以外，接下来讨论的前提是一些值得尝试的软件。 根据我最近的经验来看一个软件有以下三个因素或成正比，或成反比： 易用性 学习时间 工作效率 易用性 易用：iPhone第一次出现的时候的解锁。没有任何说明的情况下，绝大部分人都会轻轻一划，手机解锁。（如果这个你觉得理所当然的时候，想一想回到2007年之前，满大街的诺基亚，我拿同学的N8x玩每次都要问怎么解锁） 难用：当没有看任何帮助文档第一次打开Emacs和Vim的时候，喵了个咪，这两货外星来的吧，怎么关闭啊。 易用性是一个很大的范围，我觉得就能包含交互、UI、逻辑、用户习惯、用户直觉、使用环境等因素。在apple再次征服世界之前，我还在使用Windows的时候，如果你说易用。我还真特喵没觉得哪些易用。哪些难用。但当我第一次放开我的眼界脱离了windows，了解了世界一些一流产品的时候，开始自己考虑一个软件要怎么写才能写的好的时候。我觉得，我开始窥探其中道理。 一个软件越易用，就可能带来更大的客户群体，更多的用户，更广阔的市场。 怎样把软件做的易用这里不想高谈阔论，就只想说一个简单的道理： 小时候的语文课文有那么一课吧：唐代诗人白居易做诗，力求通俗易懂，明白晓畅。据说他每写一诗，必对家中老妪读之，老太太能理解的就抄录，不明白的就改写。 还有一个电影《101真狗》还是续集当中，男主是一个制作游戏的，他的游戏做了拿去公司的通过标准是给一个5-6岁的小孩子玩。小孩觉得好玩就通过。这也就是现在业界流行的你的IOS游戏如果能被5岁小孩玩懂就成功的证据之一吧。 引古博今，最后总结一下：如果你的应用能给上到70老太，下到5岁小萝莉or正太用。你的软件一定非常易用。 学习时间 短时：教妹子划西瓜，打小鸟。几乎点开以后看完tutorial妹子就知道怎么玩了。 长时：如果你要教一个妹子打dota，你首先要从鼠标的左右键有不同的功能说起，然后告诉她她要打的坏人是那些blah blah blah。最后你筋疲力尽了，妹子估计也没有弄懂她在干什么。 学习时间是一个很重要的因素，意味着软件的用户在使用你的软件以后多长时间能达到预期目的。如果时间过长，大部份用户就会选择放弃然后选择其他。学习时间的长短直接影响着，用户的时间成本。如果时间成本过高，而用户预期目的比较低。用户就必然不会选择。 例如： 普通用户只想在一个文本文件里面记录一下刚刚某个妹子发过来的电话，时间，电影院什么的。在记事本和Emacs之间，肯定会选择记事本。然后在适当的时间打电话约妹子看电影。 但是如果是一个已经在Emacs下生活了几年的极品宅男，妹子电话才出现的时候。可能就已经切换到Emacs然后调出某个估计只要电脑开着就打开的org TODO标记到了最醒目的位置。整个动作一气呵成，手连键盘都没有离开过。如果妹子在旁边看着一点会觉得这是魔法。可是，如果宅男肯把花到Emacs上的一半时间去找妹子，很可能已经是几个孩子的爹了。 上面举例的是比较极端的情况。可是也是我要说明的，就是你要学习一个软件的时间，其实应该算在你人生的时间成本里面。前几天看过一个很cool的电影叫《时间统计局》里面的设定换成现实又何尝不是呢。一生短暂，生，不挂一丝，死，一丝不挂。所以，不是说这个软件好，你就可以去用，可以去学习。如果它带给你的效果，小于带给你的收益的时候。应该果断的放弃它。 工作效率上面说学习时间，其实没有说完。应该结合工作效率来说。简单来说，就是你达成某一个期望的时间长短。 在我了解的现实情况是这样的，工作效率越高的软件、功能越多的软件、功能越专业的软件，只要每沾上一条，你必须投入越多的学习时间。 “业精于勤，荒于嬉；行成于思，毁于随。”——韩愈《昌黎先生集》 英国神经学家DanielLevitin认为，人类脑部确实需要这么长的时间，去理解和吸收一种知识或者技能，然后才能达到大师级水平。顶尖的运动员、音乐家、棋手，需要花一万小时，才能让一项技艺至臻完美。美国游泳好手麦克．菲尔普斯，除了手脚特长的天赋异禀，他每天练习八小时，全年无休，这样持续五六年，方能谛造一人独得八面金牌的奥运奇迹。 庖丁为文惠君解牛。手之所触，肩之所倚，足之所履，膝之所踦， 砉然向然，奏刀騞然，莫不中音：合于《桑林》之舞，乃中《经首》 之会。 文惠君曰：“嘻，善哉！技盖至此乎？” 庖丁释刀对曰：“臣之所好者，道也；进乎技矣。始臣之解牛之时， 所见无非牛者；三年之后，未尝见全牛也。方今之时，臣以神遇而 不以目视，官知目而神欲行。依乎天理，批大却，导大窾，因其固 然，技经肯綮之未尝，而况大軱乎！良庖岁更刀，割也；族庖月更 刀，折也。今臣之刀十九年矣，所解数千牛矣，而刀刃若新发于硎。 彼节者有间，而刀刃者无厚；以无厚入有间，恢恢乎其于游刃必有 余地矣！是以十九年而刀刃若新发于硎。虽然，每至于族，吾见其 难为，怵然为戒，视为止，行为迟。动刀甚微，謋然已解，如土委 地。提刀而立，为之四顾，为之踌躇满志；善刀而藏之。” 文惠君曰：“善哉！吾闻庖丁之言，得养生焉。” 《庄子》 例子看来已经足够了。要一流的工作效率，必须投入大量的时间成本。用一个简单的公式来表达： 时间成本 = 学习时间 + (使用时间 + 学习时间）/ 工作效率*使用时间 用Emacs来煮咖啡举例就很简单，如果你是想要冲一杯咖啡。 正常青年就起身，去饮水机旁边自己冲一杯咖啡。花费5分钟。 高富帅会喊秘书冲一杯，花费5秒钟，然后调戏秘书30分钟。 2B青年先学习Emacs3年，然后在学各种电路3年。接着用1年的时间在自己家里面安装智能家电，配备自己研发的咖啡机器人。终于，可以调出Emacs啪啪啪~~~3秒种以内按键十几次。然后端起咖啡机人送到手上的咖啡，蔑视的看了高富帅和普通青年一眼。 总结看来最近的思绪太过于飘了，本来是先写一些对软件的一些想法。结果写到2b青年了。囧。。。。 其实，在我看来对于一个ios开发者来说，软件的易用性应该大于软件的效率。因为在tinyfool哥的视频里面有一个思想让我念念不忘，就是说，移动终端有个特点。就是用户可能掏出来就看一眼，然后又放进口袋里面。用户没有大量连续的时间去使用你的应用。这个时候，如果你的应用不够直观明白易用。怎么可能掏出来的时候用你的呢。 希望这些碎碎念对你又帮助。:)","link":"/2012/03/14/talk-about-the-software/"},{"title":"iOS笔记 (1)","text":"iOS 系统架构iOSCocoa Touch Media Core Services Core OS Core OSOSX kernel Power Management Mach 3.0 Keychain Access BSD Certificates Sockets File System Security Bonjour Core ServicesCollections Core Location Address Book Net Services networking Threading File Access Preferences SQLite URL Utilities MediaCore Audio JPEG PNG TIFF OpenAL PDF Audio Mixing Quartz(2D) Audio Recording Core Animation Video Playback OpenGL ES Cocoa TouchMulti-Touch Alerts Core Motion Web View View Hierarchy Map Kit Localization Image Picker Controls Camera MVC Model Controller View 斯坦福老头的课上是这么定义的： model = What your application is (but not how it is displayed) controller = How your model is presented to the user (UI logic) view = Your Controller&apos;s minions 这个定义太经典了。 以本人乡村洋文的水平理解如下： model里面有你应用需要的数据啥的。（只有东西但是不知道怎么显示） controller帮你把model里面的东西用UI logic给呈现给用户 view是什么呢，view是controller呈现数据时候负责跑腿的狗腿子。 在MVC里面有下面的规矩 controllers一直是直接跟他们的model进行交流。也跟他们的view直接交流。 model跟view是永远不知道对方的。（MVC精髓之一） 下面我来说一个故事： controller一直叫唤狗腿子view，叫view干啥view就干啥。某天，view出事情了，这时候view想在出事情的时候通知一下controller主子。controller主子也不是没有人性，在controller设置一个target。这时候要是出现了什么事情view这个狗腿子要发一个action给主子controller就好了。有时候view狗腿子要和主子controller步调保持一致（synchronize 同步）这个时候要怎么做呢。在controller里面设置view狗腿的delegate（代表）这个delegate就通过一个protocol来设置（协议。哈哈 objective-c的语法出现了。） view狗腿是不会拥有显示的数据，如果狗腿需要数据的时候数据会通过协议来取得。controllers几乎都是data source（但不是model），因为controller是把model里面的信息格式化以后给view的。那model能直接跟controller交流么？答案是不，model必须独立于UI之外。（好一个不为五斗米折腰）。那model有一些忠义之言（信息更新）要进谏给controller怎么办。model就自己想办法弄了一个广播电台（类似broadcast mechanism广播机制。PS：学过设计模式的童鞋还hold住么）controllers 或者其他model就可以“收听”到感兴趣的内容。view可能也有“收听”这个功能，但是很可能收到的不是model这个台。 MVC就是这样一个模式。 至此，乡村版的MVC介绍完毕。如果发现写的太烂直接导致看不懂。那就听斯坦福老头的第一课。 Objective-C简介本来自己整理了一些，然后看到有一篇写的超好，就搞过来了。原帖也找不到了，如果侵犯了原作者，请联系我。 一句话首先Objective-C是C的一个超集。 其次Objective-C是一个面向对象的语言。 #import = #include 在头文件定义的都是公共的（方法 or 变量） 在m文件里面定义的都是私有的（方法 or 变量） @property 这个后面的变量在声明的时候就一起声明了两个方法（getter setter） 第一节 总括 这一节是对Objective-C(以后简称ObjC)的简要介绍,目的是使读者对ObjC有一个概括的认识。 面象的读者：在阅读本文之前,应具备使用与C类似的编程语言(如C,C++,JAVA)的一些经验,同时熟悉面向对象编程。 ObjC简介：ObjC是以SmallTalk为基础，建立在C语言之上，是C语言的超集。20世纪80年代早期由 Brad J.Cox设计,2007年苹果公司发布了ObjC 2.0,并在iPhone上使用ObjC进行开发。 ObjC学习内容：习的内容主要包括语法和Cocoa框架两部分。本文主要对语法进行介绍。 IDE：编写ObjC程序最主要的编译环境是Xcode,它是苹果官方提供的IDE,官网中的SDK包括Xcode,可以通过下载SDK来获得它。但是Xcode只支持MacOS X,所以如果要在其它环境下编写ObjC程序,要使用其它IDE。Linux/FreeBSD用GNUStep,Windows NT5.x(2000,XP)要先安装cywin或mingw,然后安装GNUStep。同时仅仅通过文本编辑器,GCC的make工具也可以用于开发。注:如果要使用到Cocoa的话，只能在Apple公司的Xcode上。 框架： ObjC编程中主要用到的框架是Cocoa,它是MacOS X中五大API之一,它由两个不同的框架组成FoundationKit 和ApplicationKit。 Foundation框架拥有100多个类,其中有很多有用的、面向数据的低级类和数据类型,如NSString,NSArray, NSEnumerator和NSNumber。ApplicationKit包含了所有的用户接口对象和高级类。这些框架本文不做重点介绍,如果要深入了解可以去看Xcode自带的文档。 特别之处：初次接触ObjC时,会发现许多和其它语言不同的地方,会看到很多的+,-,[ ,] ,@, NS等符号,这些符号在以后的编程中将经常看到,这部分内容在第二节中介绍。先熟悉一下ObjC的代码 123456789101112131415161718192021222324#import \"ClassA.h\"#import &lt;stdio.h&gt; int main( int argc, const char *argv[] ) { ClassA *c1 = [[ClassA alloc] init]; ClassA *c2 = [[ClassA alloc] init]; // print count printf( \"ClassA count: %i\\n\", [ClassA initCount] ); ClassA *c3 = [[ClassA alloc] init]; // print count again printf( \"ClassA count: %i\\n\", [ClassA initCount] ); [c1 release]; [c2 release]; [c3 release]; return 0;} 除了这些语言要素上的不同,ObjC也提供了一些很好的特性,如类别,扮演(Posing)等,这些在运行时的特性使得编程更加灵活。 优缺点: 每一个语言都有其优缺点,ObjC也不例外,这就要求在选择语言时权衡利弊。对于ObjC,只要善于利用它的优点,你会发现它是一个简单,灵活,高效的语言。以下列举了它的一些特点: 优点: 类别、扮演(Posing)、动态类型、指针计算、弹性信息传递、不是一个过度复杂的c衍生语言、可通过Objective-c++与c++结合 缺点: 没有命名空间、没有操作符重载、不像c++那样复杂 第二节对C的扩展1.扩展名 ObjC是ANSI版本C的一个超集,它支持相同的C语言基本语法。与C一样,文件分为头文件和源文件,扩展名分别为.h和.m。如果要加入c++的语法,需要用到.mm,这里不做介绍。 .h 头文件。头文件包涵类的定义、类型、方法以及常量的声明 .m 源文件。这个典型的扩展名用来定义源文件，可以同时包含C和Objective-C的代码。 2.#import 在ObjC里,包含头文件有比#include更好的方法#import。它的使用和#include相同,并且可以保证你的程序只包含相同的头文件一次。相当于#include+ #pragma once的组合。例如要包含Foundation框架中的Foundation.h文件,可以像下面这样。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687 #import&lt;Foundation/Foundation.h&gt; ``` 注:每个框架有一个主的头文件,只要包含了这个文件,框架中的所有特性都可以被使用。3.@符号 @符号是ObjC在C基础上新加的特性之一。常见到的形式有@”字符串”,%@ , @interface,@implement等。@”字符串”表示引用的字符串应该作为Cocoa的NSString元素来处理。@interface等则是对于C的扩展,是ObjC面向对象特性的体现。注:这里提一个小技巧,只要看到@符号,就可以认为它是对于C的一个扩展。4.NSLog() 在ObjC中用的打印函数是NSLog(),因为ObjC是加了一点”特殊语料”的C语言,所以也可以用printf()但是NSLog()提供了一些特性,如时间戳,日期戳和自动加换行符等,用起来更方便,所以推荐使用NSLog()。下面是两种输出的对比。 使用NSLog()输出任意对象的值时,都会使用%@格式说明。在使用这个说明符时,对象通过一个名为description的方法提供自己的NSLog()格式。 下面分别是使用NSLog()和使用printf()的相应输出: 2010-10-15 14:54:21。42610_15[1973:207] Hello World! Hello World! 注:NS前缀告诉你函数来自Cocoa而不是其他工具包。5.BOOL BOOL是ObjC中的布尔类型,它和C中的bool有如下区别 BOOL YES(1),NO(0) bool true(!0),false(0) 6.id 这是ObjC新加的一个数据类型,它是一般的对象类型,能够存储任何类型的方法。7.nil 在ObjC中,相对于C中的NULL,用的是nil。这两者是等价的。下面是nil的定义。 #define nil NULL #### 第三节创建对象1.接口和实现在ObjC中定义一个类需要有两个部分:接口和实现。接口文件包含了类的声明,定义了实例变量和方法。实现文件包含了具体的函数的实现代码。下图显示了一个叫MyClass的类,它继承自NSObject基类。类的定义总是从@interface开始到@end结束。在类名后面的是父类的名称。实例变量被定义在两个花括号之间。在实例变量下面的是方法的定义。一个分号用来结束一个变量或者方法。下面的代码显示了MyClass这个类的实现代码。就像类的定义规则一样,类实现文件也被两个标识框起来,一个是@implementation,还有一个是@end。这两个指令标识符告诉编译器程序从哪里开始编译到哪里结束。类中的方法名称的定义和它接口文件中的定义是一样的,除了实现文件中有具体的代码以外。``` c@implementation MyClass-(id)initWithString:(NSString *) aName{ if (self = [super init]) { count count = 0; data = nil; name = [aName copy]; return self; }}+(MyClass *)createMyClassWithString: (NSString *) aName{ return [[[self alloc] initWithString:aName] autorelease];}@end 当你要把一个对象保存进变量，要使用指针类型。ObjC同时支持强和弱变量对象。强类型对象在变量类型定义的时候包含了类名。弱对象使用id类型作为实例变量。下面的例子同时显示了定义MyClass中的强弱两种类型的变量 12MyClass* myObject1; // Strong typingid myObject2; // Weak typing 2.方法 一个方法定义包含了方法类型，返回类型，一个或者多个关键词，参数类型和参数名。在ObjC中一个类中的方法有两种类型：实例方法，类方法。实例方法前用(-)号表明,类方法用(+)表明,通过下图可以看到,前面有一个(-)号,说明这是一个实例方法。 在ObjC中，调用一个方法相当于传递一个消息，这里的消息指的是方法名和参数。所有的消息的分派都是动态的，这个体现了ObjC的多态性。消息调用的方式是使用方括号。如下面的例子中，向myArray对象发送insertObject:atIndex:这个消息。 123456[myArray insertObject:anObj atIndex:0];``` 这种消息传递允许嵌套``` c[[myAppObject getArray] insertObject:[myAppObject getObjectToInsert] atIndex:0]; 前面的例子都是把消息传递给实例变量，你也可以把消息传递给类本身。这时要用类方法来替代实例方法 。你可以 把他想象成静态C++类（当然不完全相同）。类方法的定义只有一个不一样那就是用加号（+）代替减号（-）。下面就是使用一个类方法。 123NSMutableArray* myArray = nil; // nil is essentially the same as NULL// Create a new array and assign it to the myArray variable.myArray = [NSMutableArray arrayWithCapacity:0]; 3.属性 属性提供了比方法更方便的访问方式。通过property标识符来替代getter和setter方法。使用方法就是在类接口文件中用@property标识符，后面跟着变量的属性，包括 copy, tetain, assign ,readonly , readwrite,nonatomic，然后是变量名。同时在实现文件中用@synthesize标识符来取代getter和setter方法。 1234@property BOOL flag;@property (copy) NSString* nameObject; // Copy the object during assignment.@property (readonly) UIView* rootView; // Create only a getter method 接口文件中使用@property 1234567891011121314151617181920@synthesize flag,nameObject,rootView;``` 实现文件中使用@synthesize属性的另一个好处就是，可以使用点（.）语法来访问，如下所示： ``` myObject.flag = YES; CGRect viewFrame = myObject.rootView.frame;``` #### 第四节继承 继承的语法如下，冒号后的标识符是需要继承的类。 @interface Circle : NSObject123456789101.不支持多继承 要注意的是ObjC只支持单继承，如果要实现多继承的话，可以通过类别和协议的方式来实现，这两种方法将在后面进行介绍。 2.Super关键字ObjC提供某种方式来重写方法，并且仍然调用超类的实现方式。当需要超类实现自身的功能，同时在前面或后面执行某些额外的工作时，这种机制非常有用。为了调用继承方法的实现，需要使用super作为方法调用的目标。下面是代码示例： @implementation Circle-(void)setFillColor: (ShapeColor) c{ if(c== kRedColor){ c = kGreenColor; } [super setFillColor: c];}@end12345678910Super来自哪里呢？它既不是参数也不是实例变量，而是由ObjC编译器提供的某种神奇功能。向super发送消息时，实际上是在请求ObjC向该类的超类发送消息。如果超类中没在定义该消息，ObjC将按照通常的方式在继承链中继续查找对应的消息。#### 第五节 对象初始化1.分配与初始化 对象的初始化有两种方法：一种是[类名new], 第二种是[[类名 alloc]init]。这两种方法是等价的，不过，通常的Cocoa惯例是使用alloc和init,而不使用new.一般情况下，Cocoa程序员只是在他们不具备足够的水平来熟练使用alloc和init方法时，才将new作为辅助方法使用。 [[类名alloc]init]有两个动作。alloc是分配动作，是从操作系统获得一块内存并将其指定为存放对象的实例变量的位置。同时，alloc方法还将这块内存区域全部初始化为0。与分配动作对应的是初始化。有如下两种初始化写法。 Car car = [[Class alloc] init];//写法1Car car = [Car alloc];[car init];//写法212345应该使用第一种写法，因为init返回的对象可能不是以前的那个。2.编写初始化方法下面是一段初始化的代码 -(id)init{ if(self = [super init]){ engine = [Engine new]; … }}12345678910使用self= [super init]的作用是使超类完成它们自己的初始化工作。同时因为init可能返回的是不同的对象，实例变量所在的内存位置到隐藏的self参数之间的跳离又是固定的，所以要这样使用。注：这部分可以参考书[1]144页。#### 第六节协议 这里的协议是正式协议，相对的还有非正式协议，这在类别一节中有介绍。正式协议是一个命名的方法列表。它要求显式地采用协议。采用协议意味着要实现协议的所有方法。否则，编译器会通过生成警告来提醒你。1.声明协议 @protocol NSCopying-(id) copyWithZone：（NSZone *)zone;@end12345678910 2.采用协议``` @interface Car : NSObject &lt;NSCopying , NSCoding&gt;{ // instance variables}@end 协议可以采用多个，并且可以按任意顺序列出这些协议，没有什么影响。 3.ObjC 2.0的新特性 ObjC2.0增加了两个新的协议修饰符：@optional和@required,因此你可以像下面这样编写代码： 12345678@protocol BaseballPlayer-(void)drawHugeSalary;@optional-(void)slideHome;-(void)catchBall;@required-(void)swingBat;@end 因此，一个采用BaseballPlayer协议的类有两个要求实现的方法：-drawHugeSalary和-swingBat,还有3个不可选择实现的方法：slideHome,catchBall和throwBall。 第七节委托Cocoa中的类经常使用一种名为委托（delegate）的技术，委托是一种对象，另一个类的对象会要求委托对象执行它的某些操作。常用的是，编写委托对象并将其提供给其他一些对象，通常是提供给Cocoa生成的对象。通过实现特定的方法，你可以控制Cocoa中的对象的行为。 通过下面的例子，可以更清楚地理解委托的实现原理。其中A对象需要把一些方法委托给其它对象来实现，例子中就是对象B，B实现了含A对象特定方法的协议ADelegate，从而可以在B中实现A委托的方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@protocol ADelegate &lt;NSObject&gt;- (void)aDelegateMethod;…… @end@interface A : NSObject { …… id &lt;ADelegate&gt; delegate;} @property (readwrite, assign) id&lt;ADelegate&gt; delegate;……@end @implementation A@synthesize delegate;- (void)aMethod{ [delegate aDelegateMethod]; ......}@end //A类 @interface B : NSObject &lt;ADelegate&gt; @end@implementation B- (id)init { [[A sharedA] setDelegate:self];} - (void)aDelegateMethod{ //B中实现A委托的方法}@end //B类 注：实现委托还可以使用类别，在第八节中将做介绍 第八节 类别 类别允许你在现有的类中加入新功能，这些类可以是框架中的类，并且不需要扩充它。 1.声明类别 1234567891011@interface NSString (NumberConvenience)-(NSNumber *) lengthAsNumber;@end``` 该声明表示，类别的名称是NumberConvenience，而且该类别将向NSString类中添加方法。2.实现类别 @implementation NSString (NumberConvenience)-(NSNumber *) lengthAsNumber{ unsigned int length = [self length]; return ([NSNumber numberWithUnsignedInt: length]);}@end1234567893.局限性 类别有两方面的局限性。第一，无法向类中添加新的实例变量。类别没有位置容纳实例变量。第二，名称冲突，即类别中的方法与现有的方法重名。当发生名称冲突时，类别具有更高的优先级。这点可以通过增加一个前缀的方法解决。 4.非正式协议和委托类别实现委托除了第七节中应用协议的方式，还可以使用类别。具体做法就是把委托对象要实现的方法声明为一个NSObject的类别。如下面的代码所示: @interface NSObject(NSSomeDelegateMethods)-(void)someMethod;…@end12345678 通过将这些方法声明为NSObject的类别，使得只要对象实现了委托方法，任何类的对象都可以成为委托对象。创建一个NSObject的类别称为“创建一个非正式协议”。非正式协议只是一种表达方式，它表示“这里有一些你可能想实现的方法”,第六节介绍的协议可以叫做正式协议。 非正式协议的作用类似于使用许多@optional的正式协议，并且前者正逐渐被后者所代替。 5.选择器 选择器只是一个方法名称，它以ObjC运行时使用的特殊方式编码，以快速执行查询。你可以使用@selector()预编译指令指定选择器，其中方法名位于圆括号中。如一个类中setEngine:方法的选择器是： @selector(setEngine:)123456789 因为选择器可以被传递，可以作为方法的参数使用，甚至可以作为实例变量存储。这样可以生成一些非常强大和灵活的构造。#### 第九节PosingPosing有点像类别，但不太一样。它允许你扩充一个类，并且全面性地扮演(pose)这个超类。例如：你有一个扩充NSArry的NSArrayChild对象。如果你让NSArrayChild扮演NSArry,则在你的代码中所有的NSArray都会自动被替代为NSArrayChild. @interface FractionB: Fraction-(void) print;@end @implementation FractionB-(void) print { printf(“(%i/%i)”, numerator, denominator );}@end //Fraction.m123456789101112131415161718192021222324252627282930``` int main( int argc, const char *argv[] ) { Fraction *frac = [[Fraction alloc] initWithNumerator: 3 denominator: 10]; //print it printf(\"The fraction is: \" ); [frac print]; printf(\"\\n\" ); //make FractionB pose as Fraction [FractionB poseAsClass: [Fraction class]]; Fraction *frac2 = [[Fraction alloc] initWithNumerator: 3 denominator: 10]; // print it printf(\"The fraction is: \" ); [frac2 print]; printf( \"\\n\" ); //free memory [frac release]; [frac2 release]; return 0;} // Main.m 输出 The fraction is: 3/10 The fraction is: (3/10) 这个程序的输出中，第一个fraction会输出3/10,而第二个会输出（3/10)，这是FractionB中实现的方式。poseAsClass这个方法是NSObject的一部分，它允许子类扮演超类。 第十节动态识别 （Dynamictypes)下面是应用动态识别时所用到的方法: 1234567891011121314-(BOOL)isKindOfClass: classObj //是否是其子孙或一员 -(BOOL)isMemberOfClass: classObj // 是否是其一员 -(BOOL)respondsToSelector: selector // 是否有这种方法 +(BOOL)instancesRespondToSelector: selector // 类的对象是否有这种方法-(id)performSelector: selector // 执行对象的方法 通过下面的代码可以更清楚地理解动态类型的使用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#import \"Square.h\"#import \"Rectangle.h\"#import &lt;stdio.h&gt; int main( int argc, const char *argv[] ) { Rectangle *rec = [[Rectangle alloc] initWithWidth: 10 height: 20]; Square *sq = [[Square alloc] initWithSize: 15]; // isMemberOfClass // true if( [sq isMemberOfClass: [Square class]] == YES ) { printf( \"square is a member of square class\\n\" ); } // false if ( [sq isMemberOfClass: [Rectangle class]] == YES ) { printf( \"square is a member of rectangle class\\n\" ); } // false if( [sq isMemberOfClass: [NSObject class]] == YES ) { printf(\"square is a member of object class\\n\" ); } // isKindOfClass // true if ( [sq isKindOfClass: [Square class]] == YES ) { printf(\"square is a kind of square class\\n\" ); } // true if( [sq isKindOfClass: [Rectangle class]] == YES ) { printf(\"square is a kind of rectangle class\\n\" ); } // true if( [sq isKindOfClass: [NSObject class]] == YES ) { printf(\"square is a kind of object class\\n\" ); } // respondsToSelector // true if( [sq respondsToSelector: @selector( setSize: )] == YES ) { printf(\"square responds to setSize: method\\n\" ); } // false if( [sq respondsToSelector: @selector( nonExistant )] == YES ) { printf(\"square responds to nonExistant method\\n\" ); } // true if( [Square respondsToSelector: @selector( alloc )] == YES ) { printf(\"square class responds to alloc method\\n\" ); } // instancesRespondToSelector // false if( [Rectangle instancesRespondToSelector: @selector( setSize: )] == YES ) { printf(\"rectangle instance responds to setSize: method\\n\" ); } // true if( [Square instancesRespondToSelector: @selector( setSize: )] == YES ) { printf(\"square instance responds to setSize: method\\n\" ); }// free memory [rec release]; [sq release]; return 0;} 输出： square is a member of square class square is a kind of square class square is a kind of rectangle class square is a kind of object class square responds to setSize: method square class responds to alloc method square instance responds to setSize: method","link":"/2012/02/28/learning-ios-notes-one/"}],"tags":[{"name":"just-talk","slug":"just-talk","link":"/tags/just-talk/"},{"name":"PM","slug":"PM","link":"/tags/PM/"},{"name":"产品汪","slug":"产品汪","link":"/tags/产品汪/"},{"name":"随便瞎扯","slug":"随便瞎扯","link":"/tags/随便瞎扯/"},{"name":"胡思乱想","slug":"胡思乱想","link":"/tags/胡思乱想/"},{"name":"产品思考","slug":"产品思考","link":"/tags/产品思考/"},{"name":"新西兰","slug":"新西兰","link":"/tags/新西兰/"},{"name":"新西兰徒步","slug":"新西兰徒步","link":"/tags/新西兰徒步/"},{"name":"徒步指南","slug":"徒步指南","link":"/tags/徒步指南/"},{"name":"新西兰徒步指北","slug":"新西兰徒步指北","link":"/tags/新西兰徒步指北/"},{"name":"新西兰徒步指南","slug":"新西兰徒步指南","link":"/tags/新西兰徒步指南/"},{"name":"read book notes","slug":"read-book-notes","link":"/tags/read-book-notes/"},{"name":"Emacs","slug":"Emacs","link":"/tags/Emacs/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"Design","slug":"Design","link":"/tags/Design/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"Software","slug":"Software","link":"/tags/Software/"},{"name":"写给18岁的自己","slug":"写给18岁的自己","link":"/tags/写给18岁的自己/"}],"categories":[]}