<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"/><meta content="yes" name="apple-mobile-web-app-capable"/><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/><meta content="telephone=no" name="format-detection"/><meta name="description" content="iOS Cocoa OSX 如果不能成为拯救世界的神 那就堕落到征服世界的魔吧 产品 产品原型 产品设计"/><title>iOS笔记 (1) | 萧宸宇</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"/><link rel="stylesheet" type="text/css" href="/css/pure-min.css"/><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"/><link rel="stylesheet" type="text/css" href="/css/style.css"/><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"/><link rel="apple-touch-icon" href="/apple-touch-icon.png"/><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"/><link rel="alternate" type="application/atom+xml" href="/atom.xml"/></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS笔记 (1)</h1><a id="logo" href="/">萧宸宇</a><p class="description">如果不能成为拯救世界的神，那就堕落到征服世界的魔吧。</p></div><div id="nav-menu"><a href="/" class="current"><i class="icon-home"> 首页</i></a><a href="/archives/"><i class="icon-archive"> 归档</i></a><a href="/about-me/"><i class="icon-about"> 关于</i></a><a href="/atom.xml"><i class="icon-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">iOS笔记 (1)</h1><div class="post-meta">2012 Feb 28日 | </div><span data-disqus-identifier="2012/02/28/learning-ios-notes-one/" class="disqus-comment-count"></span><div class="post-content"><h2 id="iOS__u7CFB_u7EDF_u67B6_u6784"><a href="#iOS__u7CFB_u7EDF_u67B6_u6784" class="headerlink" title="iOS 系统架构"></a>iOS 系统架构</h2><h4 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h4><pre><code>Cocoa Touch
Media
Core Services
Core OS
</code></pre><h4 id="Core_OS"><a href="#Core_OS" class="headerlink" title="Core OS"></a>Core OS</h4><pre><code>OSX kernel
Power Management
Mach 3.0
Keychain Access
BSD
Certificates
Sockets
File System
Security 
Bonjour  
</code></pre><h4 id="Core_Services"><a href="#Core_Services" class="headerlink" title="Core Services"></a>Core Services</h4><pre><code>Collections 
Core Location
Address Book
Net Services
networking 
Threading
File Access
Preferences
SQLite
URL Utilities
</code></pre><h4 id="Media"><a href="#Media" class="headerlink" title="Media"></a>Media</h4><pre><code>Core Audio
JPEG PNG TIFF
OpenAL 
PDF
Audio Mixing 
Quartz(2D)
Audio Recording
Core Animation
Video Playback
OpenGL ES
</code></pre><h4 id="Cocoa_Touch"><a href="#Cocoa_Touch" class="headerlink" title="Cocoa Touch"></a>Cocoa Touch</h4><pre><code>Multi-Touch
Alerts
Core Motion
Web View
View Hierarchy
Map Kit
Localization
Image Picker
Controls
Camera
</code></pre><a id="more"></a>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><blockquote>
<p>Model Controller View</p>
</blockquote>
<p>斯坦福老头的课上是这么定义的：</p>
<pre><code>model = What your application is (but not how it is displayed)
controller = How your model is presented to the user (UI logic)
view = Your Controller&apos;s minions
</code></pre><p>这个定义太经典了。</p>
<p>以本人乡村洋文的水平理解如下：</p>
<pre><code>model里面有你应用需要的数据啥的。（只有东西但是不知道怎么显示）

controller帮你把model里面的东西用UI logic给呈现给用户

view是什么呢，view是controller呈现数据时候负责跑腿的狗腿子。
</code></pre><p>在MVC里面有下面的规矩    </p>
<pre><code>controllers一直是直接跟他们的model进行交流。也跟他们的view直接交流。

model跟view是永远不知道对方的。（MVC精髓之一）
</code></pre><p>下面我来说一个故事：</p>
<p>   controller一直叫唤狗腿子view，叫view干啥view就干啥。某天，view出事情了，这时候view想在出事情的时候通知一下controller主子。controller主子也不是没有人性，在controller设置一个target。这时候要是出现了什么事情view这个狗腿子要发一个action给主子controller就好了。有时候view狗腿子要和主子controller步调保持一致（synchronize 同步）这个时候要怎么做呢。在controller里面设置view狗腿的delegate（代表）这个delegate就通过一个protocol来设置（协议。哈哈 objective-c的语法出现了。）</p>
<p>   view狗腿是不会拥有显示的数据，如果狗腿需要数据的时候数据会通过协议来取得。controllers几乎都是data source（但不是model），因为controller是把model里面的信息格式化以后给view的。<br>那model能直接跟controller交流么？答案是不，model必须独立于UI之外。（好一个不为五斗米折腰）。<br>那model有一些忠义之言（信息更新）要进谏给controller怎么办。<br>model就自己想办法弄了一个广播电台（类似broadcast mechanism广播机制。PS：学过设计模式的童鞋还hold住么）controllers 或者其他model就可以“收听”到感兴趣的内容。view可能也有“收听”这个功能，但是很可能收到的不是model这个台。</p>
<p>MVC就是这样一个模式。</p>
<p>至此，乡村版的MVC介绍完毕。如果发现写的太烂直接导致看不懂。那就听斯坦福老头的第一课。</p>
<h2 id="Objective-C_u7B80_u4ECB"><a href="#Objective-C_u7B80_u4ECB" class="headerlink" title="Objective-C简介"></a>Objective-C简介</h2><p>本来自己整理了一些，然后看到有一篇写的超好，就搞过来了。原帖也找不到了，如果侵犯了原作者，请联系我。</p>
<h4 id="u4E00_u53E5_u8BDD"><a href="#u4E00_u53E5_u8BDD" class="headerlink" title="一句话"></a>一句话</h4><pre><code>首先Objective-C是C的一个超集。

其次Objective-C是一个面向对象的语言。

#import = #include

在头文件定义的都是公共的（方法 or 变量）

在m文件里面定义的都是私有的（方法 or 变量）

@property 这个后面的变量在声明的时候就一起声明了两个方法（getter setter）
</code></pre><h4 id="u7B2C_u4E00_u8282__u603B_u62EC"><a href="#u7B2C_u4E00_u8282__u603B_u62EC" class="headerlink" title="第一节 总括"></a>第一节 总括</h4><p>  这一节是对Objective-C(以后简称ObjC)的简要介绍,目的是使读者对ObjC有一个概括的认识。</p>
<ul>
<li><p>面象的读者：在阅读本文之前,应具备使用与C类似的编程语言(如C,C++,JAVA)的一些经验,同时熟悉面向对象编程。  </p>
</li>
<li><p>ObjC简介：ObjC是以SmallTalk为基础，建立在C语言之上，是C语言的超集。20世纪80年代早期由 Brad J.Cox设计,2007年苹果公司发布了ObjC 2.0,并在iPhone上使用ObjC进行开发。</p>
</li>
<li>ObjC学习内容：习的内容主要包括语法和Cocoa框架两部分。本文主要对语法进行介绍。</li>
<li>IDE：编写ObjC程序最主要的编译环境是Xcode,它是苹果官方提供的IDE,官网中的SDK包括Xcode,可以通过下载SDK来获得它。但是Xcode只支持MacOS X,所以如果要在其它环境下编写ObjC程序,要使用其它IDE。Linux/FreeBSD用GNUStep,Windows NT5.x(2000,XP)要先安装cywin或mingw,然后安装GNUStep。同时仅仅通过文本编辑器,GCC的make工具也可以用于开发。<br>注:如果要使用到Cocoa的话，只能在Apple公司的Xcode上。  </li>
<li>框架： ObjC编程中主要用到的框架是Cocoa,它是MacOS X中五大API之一,它由两个不同的框架组成FoundationKit 和ApplicationKit。 Foundation框架拥有100多个类,其中有很多有用的、面向数据的低级类和数据类型,如NSString,NSArray, NSEnumerator和NSNumber。ApplicationKit包含了所有的用户接口对象和高级类。这些框架本文不做重点介绍,如果要深入了解可以去看Xcode自带的文档。</li>
<li>特别之处：初次接触ObjC时,会发现许多和其它语言不同的地方,会看到很多的+,-,[ ,] ,@, NS等符号,这些符号在以后的编程中将经常看到,这部分内容在第二节中介绍。先熟悉一下ObjC的代码</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"ClassA.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;stdio.h&gt;</span></span></span><br><span class="line">            </span><br><span class="line"><span class="keyword">int</span> main( <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[] ) &#123;</span><br><span class="line">	ClassA *c1 = [[ClassA alloc] init];</span><br><span class="line">    ClassA            *c2 = [[ClassA alloc] init];</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">    <span class="comment">//            print count</span></span><br><span class="line">    printf(            <span class="string">"ClassA count: %i\n"</span>, [ClassA initCount] );</span><br><span class="line">             </span><br><span class="line">    ClassA            *c3 = [[ClassA alloc] init];</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">    <span class="comment">//            print count again</span></span><br><span class="line">    printf(            <span class="string">"ClassA count: %i\n"</span>, [ClassA initCount] );</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">    [c1            release];</span><br><span class="line">    [c2            release];</span><br><span class="line">    [c3            release];</span><br><span class="line">             </span><br><span class="line">    <span class="keyword">return</span>            <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  除了这些语言要素上的不同,ObjC也提供了一些很好的特性,如类别,扮演(Posing)等,这些在运行时的特性使得编程更加灵活。</p>
<ul>
<li><p>优缺点: 每一个语言都有其优缺点,ObjC也不例外,这就要求在选择语言时权衡利弊。对于ObjC,只要善于利用它的优点,你会发现它是一个简单,灵活,高效的语言。以下列举了它的一些特点:</p>
<p>优点: 类别、扮演(Posing)、动态类型、指针计算、弹性信息传递、不是一个过度复杂的c衍生语言、可通过Objective-c++与c++结合</p>
<p>缺点: 没有命名空间、没有操作符重载、不像c++那样复杂</p>
</li>
</ul>
<h4 id="u7B2C_u4E8C_u8282_u5BF9C_u7684_u6269_u5C55"><a href="#u7B2C_u4E8C_u8282_u5BF9C_u7684_u6269_u5C55" class="headerlink" title="第二节对C的扩展"></a>第二节对C的扩展</h4><p>1.扩展名</p>
<p>  ObjC是ANSI版本C的一个超集,它支持相同的C语言基本语法。与C一样,文件分为头文件和源文件,扩展名分别为.h和.m。如果要加入c++的语法,需要用到.mm,这里不做介绍。</p>
<pre><code>.h 头文件。头文件包涵类的定义、类型、方法以及常量的声明

.m 源文件。这个典型的扩展名用来定义源文件，可以同时包含C和Objective-C的代码。
</code></pre><p>2.#import   </p>
<p>在ObjC里,包含头文件有比#include更好的方法#import。它的使用和#include相同,并且可以保证你的程序只包含相同的头文件一次。相当于#include+ #pragma once的组合。<br>例如要包含Foundation框架中的Foundation.h文件,可以像下面这样。</p>
   <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">   #import&lt;Foundation/Foundation.h&gt;</span><br><span class="line">   ```      </span><br><span class="line">   </span><br><span class="line">   注:每个框架有一个主的头文件,只要包含了这个文件,框架中的所有特性都可以被使用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.@符号</span><br><span class="line">        </span><br><span class="line">   @符号是ObjC在C基础上新加的特性之一。常见到的形式有@”字符串”,%@ , @interface,@implement等。@”字符串”表示引用的字符串应该作为Cocoa的NSString元素来处理。@interface等则是对于C的扩展,是ObjC面向对象特性的体现。</span><br><span class="line">注:这里提一个小技巧,只要看到@符号,就可以认为它是对于C的一个扩展。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4.NSLog()</span><br><span class="line"></span><br><span class="line">   在ObjC中用的打印函数是NSLog(),因为ObjC是加了一点”特殊语料”的C语言,所以也可以用printf()但是NSLog()提供了一些特性,如时间戳,日期戳和自动加换行符等,用起来更方便,所以推荐使用NSLog()。下面是两种输出的对比。</span><br><span class="line">   </span><br><span class="line">   使用NSLog()输出任意对象的值时,都会使用%@格式说明。在使用这个说明符时,对象通过一个名为description的方法提供自己的NSLog()格式。</span><br><span class="line">   </span><br><span class="line">  下面分别是使用NSLog()和使用printf()的相应输出:</span><br><span class="line"></span><br><span class="line">     2010-10-15 14:54:21。42610_15[1973:207] Hello World!</span><br><span class="line">     </span><br><span class="line">     Hello World!</span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">注:NS前缀告诉你函数来自Cocoa而不是其他工具包。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5.BOOL</span><br><span class="line">   </span><br><span class="line">   BOOL是ObjC中的布尔类型,它和C中的bool有如下区别</span><br><span class="line"></span><br><span class="line">                                                        </span><br><span class="line">    BOOL YES(1),NO(0)</span><br><span class="line">         </span><br><span class="line">    bool true(!0),false(0)</span><br><span class="line">         </span><br><span class="line"></span><br><span class="line">6.id</span><br><span class="line">    </span><br><span class="line">   这是ObjC新加的一个数据类型,它是一般的对象类型,能够存储任何类型的方法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7.nil</span><br><span class="line"></span><br><span class="line">   在ObjC中,相对于C中的NULL,用的是nil。这两者是等价的。下面是nil的定义。</span><br><span class="line"></span><br><span class="line">	#define nil NULL</span><br><span class="line">         </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 第三节创建对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1.接口和实现</span><br><span class="line"></span><br><span class="line">在ObjC中定义一个类需要有两个部分:接口和实现。接口文件包含了类的声明,定义了实例变量和方法。实现文件包含了具体的函数的实现代码。下图显示了一个叫MyClass的类,它继承自NSObject基类。类的定义总是从@interface开始到@end结束。在类名后面的是父类的名称。实例变量被定义在两个花括号之间。在实例变量下面的是方法的定义。一个分号用来结束一个变量或者方法。</span><br><span class="line"></span><br><span class="line">下面的代码显示了MyClass这个类的实现代码。就像类的定义规则一样,类实现文件也被两个标识框起来,一个是@implementation,还有一个是@end。这两个指令标识符告诉编译器程序从哪里开始编译到哪里结束。类中的方法名称的定义和它接口文件中的定义是一样的,除了实现文件中有具体的代码以外。</span><br><span class="line"></span><br><span class="line">``` c</span><br><span class="line">@implementation MyClass</span><br><span class="line">-(id)initWithString:(NSString *) aName</span><br><span class="line">&#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        count count = 0;</span><br><span class="line">        data = nil;</span><br><span class="line">        name = [aName copy];</span><br><span class="line">        return self;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">+(MyClass *)createMyClassWithString: (NSString *) aName</span><br><span class="line">&#123;</span><br><span class="line">    return [[[self alloc] initWithString:aName] autorelease];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>   当你要把一个对象保存进变量，要使用指针类型。ObjC同时支持强和弱变量对象。强类型对象在变量类型定义的时候包含了类名。弱对象使用id类型作为实例变量。下面的例子同时显示了定义MyClass中的强弱两种类型的变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass* myObject1;    <span class="comment">// Strong typing</span></span><br><span class="line">id myObject2;    <span class="comment">// Weak typing</span></span><br></pre></td></tr></table></figure>
<p>2.方法</p>
<p>   一个方法定义包含了方法类型，返回类型，一个或者多个关键词，参数类型和参数名。在ObjC中一个类中的方法有两种类型：实例方法，类方法。实例方法前用(-)号表明,类方法用(+)表明,通过下图可以看到,前面有一个(-)号,说明这是一个实例方法。</p>
<p>   在ObjC中，调用一个方法相当于传递一个消息，这里的消息指的是方法名和参数。所有的消息的分派都是动态的，这个体现了ObjC的多态性。消息调用的方式是使用方括号。如下面的例子中，向myArray对象发送insertObject:atIndex:这个消息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[myArray insertObject:anObj atIndex:<span class="number">0</span>];</span><br><span class="line">```        </span><br><span class="line">这种消息传递允许嵌套</span><br><span class="line"></span><br><span class="line">``` c</span><br><span class="line">[[myAppObject getArray] insertObject:[myAppObject getObjectToInsert] atIndex:<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>前面的例子都是把消息传递给实例变量，你也可以把消息传递给类本身。这时要用类方法来替代实例方法 。你可以 把他想象成静态C++类（当然不完全相同）。<br>类方法的定义只有一个不一样那就是用加号（+）代替减号（-）。下面就是使用一个类方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray* myArray = nil;    <span class="comment">// nil is essentially the same as NULL</span></span><br><span class="line"><span class="comment">//            Create a new array and assign it to the myArray variable.</span></span><br><span class="line">myArray = [NSMutableArray arrayWithCapacity:<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>3.属性</p>
<p>   属性提供了比方法更方便的访问方式。通过property标识符来替代getter和setter方法。使用方法就是在类接口文件中用@property标识符，后面跟着变量的属性，包括 copy, tetain, assign ,readonly , readwrite,nonatomic，然后是变量名。同时在实现文件中用@synthesize标识符来取代getter和setter方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@property BOOL flag;</span><br><span class="line">@property (copy) NSString* nameObject;              </span><br><span class="line"><span class="comment">//            Copy the object during assignment.</span></span><br><span class="line">@property (readonly) UIView* rootView;  <span class="comment">// Create only a getter method</span></span><br></pre></td></tr></table></figure>
<p>接口文件中使用@property</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@synthesize</span>            flag,nameObject,rootView;</span><br><span class="line">```         </span><br><span class="line"></span><br><span class="line">实现文件中使用<span class="keyword">@synthesize</span></span><br><span class="line"></span><br><span class="line">属性的另一个好处就是，可以使用点（.）语法来访问，如下所示：</span><br><span class="line">   </span><br><span class="line">```              </span><br><span class="line">  myObject<span class="variable">.flag</span> = <span class="literal">YES</span>;</span><br><span class="line">  <span class="built_in">CGRect</span> viewFrame = myObject<span class="variable">.rootView</span><span class="variable">.frame</span>;</span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#### 第四节继承</span></span><br><span class="line"></span><br><span class="line"> 继承的语法如下，冒号后的标识符是需要继承的类。</span><br></pre></td></tr></table></figure>
<p> @interface            Circle : NSObject<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="cpp"></span><br><span class="line"><span class="number">1.</span>不支持多继承</span><br><span class="line"></span><br><span class="line">  要注意的是ObjC只支持单继承，如果要实现多继承的话，可以通过类别和协议的方式来实现，这两种方法将在后面进行介绍。</span><br><span class="line">  </span><br><span class="line"><span class="number">2.</span>Super关键字</span><br><span class="line"></span><br><span class="line">ObjC提供某种方式来重写方法，并且仍然调用超类的实现方式。当需要超类实现自身的功能，同时在前面或后面执行某些额外的工作时，这种机制非常有用。为了调用继承方法的实现，需要使用super作为方法调用的目标。下面是代码示例：</span></span><br></pre></td></tr></table></figure></p>
<p>@implementation Circle<br>-(void)setFillColor: (ShapeColor) c<br>{<br>    if(c== kRedColor){<br>        c = kGreenColor;<br>    }<br>    [super setFillColor: c];<br>}<br>@end<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Super来自哪里呢？它既不是参数也不是实例变量，而是由ObjC编译器提供的某种神奇功能。向super发送消息时，实际上是在请求ObjC向该类的超类发送消息。如果超类中没在定义该消息，ObjC将按照通常的方式在继承链中继续查找对应的消息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#### 第五节 对象初始化</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>分配与初始化</span><br><span class="line"></span><br><span class="line">   对象的初始化有两种方法：一种是[类名<span class="keyword">new</span>], 第二种是[[类名 alloc]init]。这两种方法是等价的，不过，通常的Cocoa惯例是使用alloc和init,而不使用<span class="keyword">new</span>.一般情况下，Cocoa程序员只是在他们不具备足够的水平来熟练使用alloc和init方法时，才将<span class="keyword">new</span>作为辅助方法使用。</span><br><span class="line">         </span><br><span class="line">   [[类名alloc]init]有两个动作。alloc是分配动作，是从操作系统获得一块内存并将其指定为存放对象的实例变量的位置。同时，alloc方法还将这块内存区域全部初始化为<span class="number">0</span>。与分配动作对应的是初始化。有如下两种初始化写法。</span><br></pre></td></tr></table></figure></p>
<p>Car <em>car = [[Class alloc] init];<br>//写法1<br>Car </em>car = [Car alloc];<br>[car init];<br>//写法2<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">应该使用第一种写法，因为init返回的对象可能不是以前的那个。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>编写初始化方法</span><br><span class="line"></span><br><span class="line">下面是一段初始化的代码</span><br></pre></td></tr></table></figure></p>
<p>-(id)init<br>{<br>    if(self = [super init]){<br>        engine = [Engine new];<br>        …<br>            }<br>}<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">使用<span class="keyword">self</span>= [<span class="keyword">super</span> <span class="keyword">init</span>]的作用是使超类完成它们自己的初始化工作。同时因为<span class="keyword">init</span>可能返回的是不同的对象，实例变量所在的内存位置到隐藏的<span class="keyword">self</span>参数之间的跳离又是固定的，所以要这样使用。</span><br><span class="line">注：这部分可以参考书[<span class="number">1</span>]<span class="number">144</span>页。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 第六节协议</span><br><span class="line"></span><br><span class="line">   这里的协议是正式协议，相对的还有非正式协议，这在类别一节中有介绍。正式协议是一个命名的方法列表。它要求显式地采用协议。采用协议意味着要实现协议的所有方法。否则，编译器会通过生成警告来提醒你。</span><br><span class="line"><span class="number">1</span>.声明协议</span><br></pre></td></tr></table></figure></p>
<p>@protocol NSCopying<br>-(id) copyWithZone：（NSZone *)zone;<br>@end<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="smali">2.采用协议</span><br><span class="line"></span><br><span class="line">```                  </span><br><span class="line">@interface Car<span class="keyword"> :</span> NSObject &lt;NSCopying , NSCoding&gt;</span><br><span class="line">&#123;</span><br><span class="line">    //<span class="instruction"> instance </span>           variables</span><br><span class="line">&#125;</span><br><span class="line">@end</span></span><br></pre></td></tr></table></figure></p>
<p>协议可以采用多个，并且可以按任意顺序列出这些协议，没有什么影响。</p>
<p>3.ObjC 2.0的新特性</p>
<p>  ObjC2.0增加了两个新的协议修饰符：@optional和@required,因此你可以像下面这样编写代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">protocol</span> BaseballPlayer</span><br><span class="line"><span class="function">-</span>(void)drawHugeSalary</span>;</span><br><span class="line"><span class="at_rule">@<span class="keyword">optional</span></span><br><span class="line"><span class="function">-</span>(void)slideHome</span>;</span><br><span class="line"><span class="tag">-</span>(<span class="tag">void</span>)<span class="tag">catchBall</span>;</span><br><span class="line"><span class="at_rule">@<span class="keyword">required</span></span><br><span class="line"><span class="function">-</span>(void)swingBat</span>;</span><br><span class="line"><span class="at_rule">@<span class="keyword">end</span></span></span><br></pre></td></tr></table></figure>
<p>因此，一个采用BaseballPlayer协议的类有两个要求实现的方法：-drawHugeSalary和-swingBat,还有3个不可选择实现的方法：slideHome,catchBall和throwBall。</p>
<h4 id="u7B2C_u4E03_u8282_u59D4_u6258"><a href="#u7B2C_u4E03_u8282_u59D4_u6258" class="headerlink" title="第七节委托"></a>第七节委托</h4><p>Cocoa中的类经常使用一种名为委托（delegate）的技术，委托是一种对象，另一个类的对象会要求委托对象执行它的某些操作。常用的是，编写委托对象并将其提供给其他一些对象，通常是提供给Cocoa生成的对象。通过实现特定的方法，你可以控制Cocoa中的对象的行为。</p>
<p> 通过下面的例子，可以更清楚地理解委托的实现原理。其中A对象需要把一些方法委托给其它对象来实现，例子中就是对象B，B实现了含A对象特定方法的协议ADelegate，从而可以在B中实现A委托的方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ADelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">- (<span class="keyword">void</span>)aDelegateMethod;</span><br><span class="line">……             </span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">A</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    ……</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> &lt;ADelegate&gt; delegate;</span><br><span class="line">&#125;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">assign</span>)             </span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span>&lt;ADelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">A</span></span></span><br><span class="line"><span class="keyword">@synthesize</span> delegate;</span><br><span class="line">- (<span class="keyword">void</span>)aMethod</span><br><span class="line">&#123;</span><br><span class="line">    [delegate aDelegateMethod];</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">         </span><br><span class="line"><span class="comment">//A类</span></span><br><span class="line">                  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">B</span> : <span class="title">NSObject</span> &lt;<span class="title">ADelegate</span>&gt;             </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">B</span></span></span><br><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">    [[A sharedA] setDelegate:<span class="keyword">self</span>];</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)aDelegateMethod&#123;   <span class="comment">//B中实现A委托的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">         </span><br><span class="line"><span class="comment">//B类</span></span><br></pre></td></tr></table></figure>
<p>注：实现委托还可以使用类别，在第八节中将做介绍</p>
<h4 id="u7B2C_u516B_u8282__u7C7B_u522B"><a href="#u7B2C_u516B_u8282__u7C7B_u522B" class="headerlink" title="第八节 类别"></a>第八节 类别</h4><p> 类别允许你在现有的类中加入新功能，这些类可以是框架中的类，并且不需要扩充它。</p>
<p>1.声明类别</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSString</span> (<span class="title">NumberConvenience</span>)</span></span><br><span class="line">-(<span class="built_in">NSNumber</span> *) lengthAsNumber;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">```         </span><br><span class="line"></span><br><span class="line">该声明表示，类别的名称是NumberConvenience，而且该类别将向<span class="built_in">NSString</span>类中添加方法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>实现类别</span><br></pre></td></tr></table></figure>
<p>@implementation NSString (NumberConvenience)<br>-(NSNumber *) lengthAsNumber<br>{<br>    unsigned int length = [self length];<br>    return ([NSNumber numberWithUnsignedInt: length]);<br>}<br>@end<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="cpp"><span class="number">3.</span>局限性</span><br><span class="line"></span><br><span class="line">   类别有两方面的局限性。第一，无法向类中添加新的实例变量。类别没有位置容纳实例变量。第二，名称冲突，即类别中的方法与现有的方法重名。当发生名称冲突时，类别具有更高的优先级。这点可以通过增加一个前缀的方法解决。</span><br><span class="line">   </span><br><span class="line"><span class="number">4.</span>非正式协议和委托类别</span><br><span class="line"></span><br><span class="line">实现委托除了第七节中应用协议的方式，还可以使用类别。具体做法就是把委托对象要实现的方法声明为一个NSObject的类别。如下面的代码所示:</span></span><br></pre></td></tr></table></figure></p>
<p>@interface NSObject(NSSomeDelegateMethods)<br>-(void)someMethod;<br>…<br>@end<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  通过将这些方法声明为<span class="built_in">NSObject</span>的类别，使得只要对象实现了委托方法，任何类的对象都可以成为委托对象。创建一个<span class="built_in">NSObject</span>的类别称为“创建一个非正式协议”。非正式协议只是一种表达方式，它表示“这里有一些你可能想实现的方法”,第六节介绍的协议可以叫做正式协议。</span><br><span class="line">  </span><br><span class="line">   非正式协议的作用类似于使用许多<span class="keyword">@optional</span>的正式协议，并且前者正逐渐被后者所代替。</span><br><span class="line">   </span><br><span class="line"><span class="number">5.</span>选择器</span><br><span class="line"></span><br><span class="line">   选择器只是一个方法名称，它以ObjC运行时使用的特殊方式编码，以快速执行查询。你可以使用<span class="keyword">@selector</span>()预编译指令指定选择器，其中方法名位于圆括号中。如一个类中setEngine:方法的选择器是：</span><br></pre></td></tr></table></figure></p>
<p>@selector(setEngine:)<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   因为选择器可以被传递，可以作为方法的参数使用，甚至可以作为实例变量存储。这样可以生成一些非常强大和灵活的构造。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#### 第九节Posing</span></span><br><span class="line"></span><br><span class="line">Posing有点像类别，但不太一样。它允许你扩充一个类，并且全面性地扮演(pose)这个超类。例如：你有一个扩充<span class="built_in">NSArry</span>的<span class="built_in">NSArrayChild</span>对象。如果你让<span class="built_in">NSArrayChild</span>扮演<span class="built_in">NSArry</span>,则在你的代码中所有的<span class="built_in">NSArray</span>都会自动被替代为<span class="built_in">NSArrayChild</span>.</span><br></pre></td></tr></table></figure></p>
<p>@interface FractionB: Fraction<br>-(void) print;<br>@end</p>
<p>@implementation FractionB<br>-(void) print {<br>    printf(“(%i/%i)”, numerator, denominator );<br>}<br>@end</p>
<p>//Fraction.m<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">```                    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    Fraction *frac = [[Fraction alloc] initWithNumerator: <span class="number">3</span> denominator: <span class="number">10</span>];</span><br><span class="line">    <span class="comment">//print it</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The fraction is: "</span> );</span><br><span class="line">    [frac print];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span> );</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    <span class="comment">//make FractionB pose as Fraction</span></span><br><span class="line">    [FractionB poseAsClass: [Fraction <span class="keyword">class</span>]];</span><br><span class="line">    Fraction *frac2 = [[Fraction alloc] initWithNumerator: <span class="number">3</span> denominator: <span class="number">10</span>];</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    <span class="comment">// print it</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The fraction is: "</span> );</span><br><span class="line">    [frac2  print];</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"\n"</span> );</span><br><span class="line">    <span class="comment">//free memory</span></span><br><span class="line">    [frac release];</span><br><span class="line">    [frac2 release];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">         </span><br><span class="line"><span class="comment">// Main.m</span></span><br></pre></td></tr></table></figure></p>
<pre><code>输出
The fraction is: 3/10
The fraction is: (3/10)
</code></pre><p>这个程序的输出中，第一个fraction会输出3/10,而第二个会输出（3/10)，这是FractionB中实现的方式。poseAsClass这个方法是NSObject的一部分，它允许子类扮演超类。</p>
<h4 id="u7B2C_u5341_u8282_u52A8_u6001_u8BC6_u522B__uFF08Dynamictypes_29"><a href="#u7B2C_u5341_u8282_u52A8_u6001_u8BC6_u522B__uFF08Dynamictypes_29" class="headerlink" title="第十节动态识别 （Dynamictypes)"></a>第十节动态识别 （Dynamictypes)</h4><p>下面是应用动态识别时所用到的方法:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-(BOOL)<span class="string">isKindOfClass:</span> classObj</span><br><span class="line">    <span class="comment">//是否是其子孙或一员</span></span><br><span class="line">         </span><br><span class="line">-(BOOL)<span class="string">isMemberOfClass:</span> classObj</span><br><span class="line">    <span class="comment">// 是否是其一员</span></span><br><span class="line">         </span><br><span class="line">-(BOOL)<span class="string">respondsToSelector:</span> selector</span><br><span class="line">    <span class="comment">// 是否有这种方法</span></span><br><span class="line">         </span><br><span class="line">+(BOOL)<span class="string">instancesRespondToSelector:</span> selector</span><br><span class="line">    <span class="comment">// 类的对象是否有这种方法</span></span><br><span class="line"></span><br><span class="line">-(id)<span class="string">performSelector:</span> selector</span><br><span class="line">    <span class="comment">// 执行对象的方法</span></span><br></pre></td></tr></table></figure>
<p>通过下面的代码可以更清楚地理解动态类型的使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="string">"Square.h"</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="string">"Rectangle.h"</span></span></span><br><span class="line"><span class="preprocessor">#import &lt;stdio.h&gt;  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[] )</span> </span>&#123;</span><br><span class="line">    Rectangle *rec = [[Rectangle alloc] initWithWidth: <span class="number">10</span> height: <span class="number">20</span>];</span><br><span class="line">    Square *sq = [[Square alloc] initWithSize: <span class="number">15</span>];</span><br><span class="line">    <span class="comment">//            isMemberOfClass</span></span><br><span class="line">    <span class="comment">//            true             </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( [sq isMemberOfClass: [Square <span class="keyword">class</span>]] == YES ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">"square is a member of square class\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//            false</span></span><br><span class="line">    <span class="keyword">if</span> ( [sq isMemberOfClass: [Rectangle <span class="keyword">class</span>]] == YES ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">"square is a member of rectangle class\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//            false</span></span><br><span class="line">    <span class="keyword">if</span>( [sq isMemberOfClass: [NSObject <span class="keyword">class</span>]] == YES ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"square is a member of object class\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//            isKindOfClass</span></span><br><span class="line">    <span class="comment">//            true             </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( [sq isKindOfClass: [Square <span class="keyword">class</span>]] == YES ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"square is a kind of square class\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//            true</span></span><br><span class="line">    <span class="keyword">if</span>( [sq isKindOfClass: [Rectangle <span class="keyword">class</span>]] == YES ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"square is a kind of rectangle class\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//            true</span></span><br><span class="line">    <span class="keyword">if</span>( [sq isKindOfClass: [NSObject <span class="keyword">class</span>]] == YES ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"square is a kind of object class\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//            respondsToSelector</span></span><br><span class="line">    <span class="comment">//            true</span></span><br><span class="line">    <span class="keyword">if</span>( [sq respondsToSelector: @selector( setSize: )] == YES ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"square responds to setSize: method\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//            false</span></span><br><span class="line">    <span class="keyword">if</span>( [sq respondsToSelector: @selector( nonExistant )] == YES ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"square responds to nonExistant method\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//            true</span></span><br><span class="line">    <span class="keyword">if</span>( [Square respondsToSelector: @selector( alloc )] == YES ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"square class responds to alloc method\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//            instancesRespondToSelector</span></span><br><span class="line">    <span class="comment">//            false</span></span><br><span class="line">    <span class="keyword">if</span>( [Rectangle instancesRespondToSelector: @selector( setSize: )] == YES ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"rectangle instance responds to setSize: method\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//            true</span></span><br><span class="line">    <span class="keyword">if</span>( [Square instancesRespondToSelector: @selector( setSize: )] == YES ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"square instance responds to setSize: method\n"</span> );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//            free memory</span></span><br><span class="line">    [rec release];</span><br><span class="line">    [sq  release];</span><br><span class="line">             </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>输出：
square is a member of square class
square is a kind of square class
square is a kind of rectangle class
square is a kind of object class
square responds to setSize: method
square class responds to alloc method
square instance responds to setSize: method
</code></pre></div><div class="tags"><a href="/tags/iOS/">iOS</a></div><div class="post-nav"><a href="/2012/02/29/emacs-set-up-2/" class="pre"><i class="icon-previous">调教Emacs(二)——更好 更强 更快</i></a><a href="/2012/02/26/emacs-set-up-1/" class="next">调教Emacs(一)——存活<i class="icon-next"></i></a></div><div id="disqus_thread"><script>var disqus_shortname = 'iiiyu';
var disqus_identifier = '2012/02/28/learning-ios-notes-one/';
var disqus_title = 'iOS笔记 (1)';
var disqus_url = 'http://iiiyu.com/2012/02/28/learning-ios-notes-one/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//iiiyu.disqus.com/count.js" async="async"></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><input placeholder="Search" type="text" class="st-default-search-input"/></div><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"><a href="/tags/just-talk/" style="font-size: 15px;">just-talk</a> <a href="/tags/Software/" style="font-size: 15px;">Software</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/read-book-notes/" style="font-size: 15px;">read book notes</a> <a href="/tags/Mac/" style="font-size: 15px;">Mac</a> <a href="/tags/Design/" style="font-size: 15px;">Design</a> <a href="/tags/Emacs/" style="font-size: 15px;">Emacs</a> <a href="/tags/随便瞎扯/" style="font-size: 15px;">随便瞎扯</a></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/01/12/2016-IT-professionals-Getting-Started/">2016年移动互联网职业入门规划指南</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/01/31/read-the-tipping-point/">读书笔记 「引爆点」</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/01/20/2014-oh-my-star-app-annual-summary/">2014年 Oh My Star 总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/01/16/read-contagious/">读书笔记 「疯传」</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/12/26/learning-ios-notes-thirty-six/">iOS 学习笔记 (36)  ReactiveCocoa 用 RACSignal 替代 Delegate</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/10/20/iCloud-and-iCloud-Drive/">iCloud 和 iCloud Drive</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/04/23/learn-ui-design-two/">怎样使用Sketch 3切图 —— 从想入设计大门的菜逼进化到切图仔（未完成）</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/04/08/learning-ios-notes-thirty-five/">iOS笔记(35) 格志周年系列之夏令时(三) 临时花絮</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/03/25/learn-ui-design-one/">学习UI设计笔记(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2014/03/19/learning-ios-notes-thirty-four/">iOS笔记(34) 格志周年系列之夏令时(二)</a></li></ul></div><div class="widget"><div class="widget-title">最近评论</div><script type="text/javascript" src="//iiiyu.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title">友情链接</div><ul></ul><a href="http://www.ohmystarapp.com/" title="Oh My Star" target="_blank">Oh My Star</a><ul></ul><a href="http://griddiaryapp.com" title="Grid Diary" target="_blank">Grid Diary</a></div></div></div></div><div id="footer">© <a href="/" rel="nofollow">萧宸宇.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/totop.js" type="text/javascript"></script><script src="/js/fancybox.pack.js" type="text/javascript"></script>
<script src="/js/jquery.fancybox.js" type="text/javascript"></script><link rel="stylesheet" href="/css/jquery.fancybox.css" type="text/css"><script>(function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
(w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
})(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

_st('install','Nm83mrKyygUM42socQtA','2.0.0');
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-29764460-1','auto');ga('send','pageview');
</script></div></body></html>